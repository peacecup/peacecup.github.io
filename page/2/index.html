<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <title>长夜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="打开新世界的大门">
  <meta property="og:type" content="website">
  <meta property="og:title" content="长夜">
  <meta property="og:url" content="https://peacecup.github.io/page/2/index.html">
  <meta property="og:site_name" content="长夜">
  <meta property="og:description" content="打开新世界的大门">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="长夜">
  <meta name="twitter:description" content="打开新世界的大门">

  <link rel="alternate" href="/atom.xml" title="长夜" type="application/atom+xml">

  <link rel="icon" href="/favicon.png">

  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="/css/style.css">

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
        <div id="banner"></div>
        <div id="header-outer" class="outer">
          <div id="header-title" class="inner">
            <h1 id="logo-wrap">
              <a href="/" id="logo">长夜</a>
            </h1>

            <h2 id="subtitle-wrap">
              <a href="/" id="subtitle">I Want More！</a>
            </h2>

          </div>
          <div id="header-inner" class="inner">
            <nav id="main-nav">
              <a id="main-nav-toggle" class="nav-icon"></a>

              <a class="main-nav-link" href="/">Home</a>

              <a class="main-nav-link" href="/archives">Archives</a>

            </nav>
            <nav id="sub-nav">

              <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>

              <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
            </nav>
            <div id="search-form-wrap">
              <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form">
                <input type="search" name="q" class="search-form-input" placeholder="Search">
                <button type="submit" class="search-form-submit">&#xF002;</button>
                <input type="hidden" name="sitesearch" value="https://peacecup.github.io">
              </form>
            </div>
          </div>
        </div>
      </header>

      <div class="outer">
        <section id="main">
          <article id="post-problems/javascript的attributes和property的异同" class="article article-type-post"
                                                                                          itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/08/11/problems/javascript的attributes和property的异同/" class="article-date">
                <time datetime="2017-08-11T06:34:42.000Z" itemprop="datePublished">2017-08-11</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/前端问题梳理/">前端问题梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/08/11/problems/javascript的attributes和property的异同/">javascript的attributes和property的异同</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="javascript中attributes和property的异同">
                  <a href="#javascript中attributes和property的异同" class="headerlink" title="javascript中attributes和property的异同?"></a>javascript中attributes和property的异同?</h3>
                <p>property用来保存DOM的特性，在javascript的DOM对象里其实是没有这个对象的。特性表示一个表单元素可能具有的一些特定属性，比如说id、class、name、value等，这些东西在创建DOM
                  Element元素的时候就会自动创建在元素上，这些就是property。 </p>
                <p>attributes是用来保存元素的属性的，任何属性包括自定义属性都会在attributes中存储，attributes本质上是一个NodeNamedMap，一个类似于数组的解构，里面的属性元素为Attr结构，是一个次一级的节点对象。</p>
                <p>两者只是在概念上有一些重叠，但是实际上，两者没有任何关系，改变任意一方都不会对对方有什么影响。 </p>
                <p>对应在jquery上，有attr和prop两个方法，这两者对应于attributes和property。老版本的DOM，可能是DOM2或者DOM3，把property设定为了attributes的一个子集，但是现在，经过测试，完全没有这回事，应该是已经修改过。</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/08/11/problems/javascript的attributes和property的异同/"
                                                                                                data-id="cjajctdrm002504qtbhdkml05" class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/前端/">前端</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-problems/CSS  BFC" class="article article-type-post" itemscope
                                                                                          itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/08/11/problems/CSS  BFC/" class="article-date">
                <time datetime="2017-08-11T06:34:42.000Z" itemprop="datePublished">2017-08-11</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/前端问题梳理/">前端问题梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/08/11/problems/CSS  BFC/">CSS 流体特性和BFC</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="块状元素的流体特性">
                  <a href="#块状元素的流体特性" class="headerlink" title="块状元素的流体特性"></a>块状元素的流体特性</h4>
                <p>html元素分为块级元素和内联元素，而块状元素在展示上具有流体特性，会像水一样自动流动填满整个空间，而内联元素则不会。</p>
                <p>流体特性会被margin padding border等特性影响，也就是说流体特性
                  <br>是针对于盒模型的content部分进行的。</p>
                <h4 id="BFC–块级格式化上下文">
                  <a href="#BFC–块级格式化上下文" class="headerlink" title="BFC–块级格式化上下文"></a>BFC–块级格式化上下文</h4>
                <p>BFC元素的特点是：不管内部元素怎么翻江倒海，外部的相邻元素纹丝未动，不会影响到外部元素。</p>
                <p>一个普通块级元素要变成BFC元素需要满足下面的某一个条件： </p>
                <ol>
                  <li>overflow属性设定为 auto、scroll、hidden。</li>
                  <li>float属性不为none。</li>
                  <li>display属性为table-cell、 table-caption、inline-block中的一个。</li>
                  <li>position属性不是relative或者static。</li>
                </ol>
                <p>一旦满足了任意一个情况，就会具有BFC属性。</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/08/11/problems/CSS  BFC/" data-id="cjajctdrl002204qtlryg1dh1"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/前端/">前端</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-problems/深复制和浅复制" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/08/11/problems/深复制和浅复制/" class="article-date">
                <time datetime="2017-08-11T06:34:42.000Z" itemprop="datePublished">2017-08-11</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/前端问题梳理/">前端问题梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/08/11/problems/深复制和浅复制/">深复制和浅复制</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="基础类型的值没有浅复制">
                  <a href="#基础类型的值没有浅复制" class="headerlink" title="基础类型的值没有浅复制"></a>基础类型的值没有浅复制</h4>
                <p>基础类型的值不存在浅复制问题，基础类型的值都是按值访问的。
                  <br>只有引用类型的值有浅复制，Object、function、Array都存在。</p>
                <h4 id="浅复制的几种情况">
                  <a href="#浅复制的几种情况" class="headerlink" title="浅复制的几种情况"></a>浅复制的几种情况</h4>
                <ol>
                  <li>
                    <p>对引用类型直接采用赋值表达式赋给另一个对象。 </p>
                    <pre><code>var a = {name: &apos;cn&apos;}
var b = a；
b == a // true
</code></pre>
                    <p> 引用类型的对象按引用访问，a和b指向同一个对象的引用。</p>
                  </li>
                  <li>Object.assign()等函数也是浅复制</li>
                </ol>
                <h4 id="深复制的办法">
                  <a href="#深复制的办法" class="headerlink" title="深复制的办法"></a>深复制的办法</h4>
                <ol>
                  <li>jquery.extend()方法。</li>
                  <li>JSON序列化，有缺陷，不能复制到原型值以及继承的值，不能复制函数。</li>
                  <li>通过for…in循环进行遍历，然后新建一个空对象进行赋值，for…in可以遍历出所有可枚举的属性以及集成的属性。</li>
                </ol>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/08/11/problems/深复制和浅复制/" data-id="cjajctdry002x04qt2vw37w3r"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/前端/">前端</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-problems/js实现继承的方式" class="article article-type-post" itemscope
                                                                                          itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/08/11/problems/js实现继承的方式/" class="article-date">
                <time datetime="2017-08-11T06:34:42.000Z" itemprop="datePublished">2017-08-11</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/前端问题梳理/">前端问题梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/08/11/problems/js实现继承的方式/">js实现继承的方式</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="js实现继承的方式">
                  <a href="#js实现继承的方式" class="headerlink" title="js实现继承的方式"></a>js实现继承的方式</h3>
                <p>js实现继承的方式目前我知道的大体可以分为两类： </p>
                <ol>
                  <li>es5通过原型链来实现继承，具体有构造函数继承、原型继承、组合构造函数和原型继承、寄生继承。寄生组合继承。</li>
                  <li>es6使用class extend supper来实现继承</li>
                </ol>
                <h4 id="es5的继承方式">
                  <a href="#es5的继承方式" class="headerlink" title="es5的继承方式"></a>es5的继承方式</h4>
                <h5 id="原型链">
                  <a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5>
                <p>原型链是实现继承的主要手段，首先是解释几个概念： </p>
                <ol>
                  <li>构造函数：构造函数用来生成对象。</li>
                  <li>原型：每个构造函数都有一个原型，原型的constructor属性指向构造函数。</li>
                  <li>prototype：构造函数的prototype指针指向原型。</li>
                  <li>实例：通过new关键字生成的构造函数的实例。</li>
                  <li>
                    <strong>proto</strong>：实例的
                    <strong>proto</strong>指针指向原型。</li>
                </ol>
                <p>那么，什么是原型链呢？</p>
                <p>实现原型的方法是使用
                  <strong>proto</strong>来串联对象与被继承对象：将对象的原型赋值为被继承对象的实例。 </p>
                <p>这样，new 出来的对象的实例的
                  <strong>proto</strong>就会指向它对应的原型也就是被继承对象的实例，而被继承对象的实例的
                  <strong>proto</strong>又指向了被继承对象的原型，这样就可以把被继承对象构造函数里的属性和原型里的属性都继承过来。 </p>
                <p>一直重复这个过程形成的链就是原型链。</p>
                <h5 id="借用构造函数">
                  <a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h5>
                <p>原型链存在一个很致命的问题，继承的属性是共享的，一旦某一个实例修改了继承属性值，另一个实例中中的值也会被修改。 </p>
                <p>因此衍生了借用构造函数实现继承。 </p>
                <p>借用构造函数就是在构造函数中使用call来调用被继承对象构造函数，这样，每一个构造函数实例都会拥有唯一的一份数据，互不影响。 </p>
                <p>但是这样又导致了属性方法不能共用的问题。</p>
                <h5 id="组合继承">
                  <a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5>
                <p>解决借用构造函数问题的方式是组合继承，和创建对象中的集合模式一样，这可以说是可以很好投入使用的一种成熟的模式。 </p>
                <p>组合继承，组合使用原型链和构造函数。 </p>
                <pre><code>function A(property){
    this.property = property
}
A.prototype.method = function(){

}
function B(property){
    A.call(this,property)
}
B.prototype = new A();
var C = new  B(&quot;hello&quot;);
C.property  // hello
var D = new  B(&quot;world&quot;);
D.property  // world
C.property = &quot;1&quot;;
D.property // world;
</code></pre>
                <p>组合继承使用构造函数模式来继承不应共享的数据和方法，使用原型链来继承共用的属性和方法。</p>
                <h5 id="原型继承">
                  <a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5>
                <p>原型继承也就是es5引入的函数Object.create(Object，options)。 </p>
                <p>Object.create()函数的原理是在函数内部创建一个函数，并且将该函数的原型赋值为传入对象，然后返回这个函数的实例，这种原型继承的方式依然存在每个实例都共享属性的问题。</p>
                <h5 id="寄生式继承">
                  <a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h5>
                <p>寄生式继承是在原型继承的基础上展开的，在原型继承的基础上，在函数内部继续扩充要被返回的实例。 </p>
                <p>缺点一样是每个实例共享属性。不能复用</p>
                <h5 id="组合寄生式继承">
                  <a href="#组合寄生式继承" class="headerlink" title="组合寄生式继承"></a>组合寄生式继承</h5>
                <p>组合继承虽然已经比较完善，但是依然有不够精简的问题，它调用了两次构造函数，组合继承式寄生就是为了解决这个问题出现的。 </p>
                <p>代码原理在于，使用寄生函数来替代原型赋值那一步，寄生函数实现了对原型的赋值以及对构造函数的重写。</p>
                <h4 id="es6的继承方式">
                  <a href="#es6的继承方式" class="headerlink" title="es6的继承方式"></a>es6的继承方式</h4>
                <p>使用class、extends、supper来实现继承。 </p>
                <pre><code>class A extends B{
    constructor(x,y){
        supper();
        this.x = x;
        this.y = y;
    }
}
</code></pre>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/08/11/problems/js实现继承的方式/" data-id="cjajctdrp002d04qtmgikhf1f"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/前端/">前端</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-s的事件循环机制（v8）（二）" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/08/02/s的事件循环机制（v8）（二）/" class="article-date">
                <time datetime="2017-08-02T08:03:25.000Z" itemprop="datePublished">2017-08-02</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/javascript/">javascript</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/08/02/s的事件循环机制（v8）（二）/">js事件循环机制（二）</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="事件循环的另一种解释">
                  <a href="#事件循环的另一种解释" class="headerlink" title="事件循环的另一种解释"></a>事件循环的另一种解释</h4>
                <ol>
                  <li>
                    <p>jsvascript是单线程高级脚本语言，每个线程拥有唯一的一个事件循环。</p>
                  </li>
                  <li>
                    <p>jsvascript代码在执行过程中，除了通过函数调用栈来解决函数执行顺序外，还依靠任务队列来搞定另外一些代码的执行顺序。</p>
                  </li>
                  <li>一个线程中，函数调用栈是唯一的，事件循环是唯一的，任务队列可以有多个。</li>
                  <li>任务队列又分为mocro-tasks（宏任务）和（micro-tasks）微任务，在最新的标准中也被称为tasks和jobs</li>
                  <li>宏任务mocro-tasks包括srcipt（整体代码）、setTimeout、 setInterval、 setImmediate、I/O、UI
                    renering（页面渲染）。
                  </li>
                  <li>微任务micro-tasks包括process.nextTrick、Promise、Mutation Observer（HTML5新特性）以及其他DOM事件</li>
                  <li>setTimeout、Promise、DOM事件等被称为任务源，而进入任务队列的是他们指定的具体执行的任务。
                    <br>setTimeout作为一个任务分发器，这个函数是会立即执行的，而他所要分发的任务是它的第一个参数，才会延迟执行。</li>
                  <li>来自不同任务源的任务会进入不同的任务队列，setTimeout和setInterval是同一个任务源。</li>
                  <li>不同任务源的执行有先后顺序。
                    <br>宏任务：script &gt; setTimeout/setInterval &gt; setImmediate &gt;I/O
                    &gt; UI rendering.
                    <br>微任务：process.nextTrick() &gt; Promise &gt;DOM事件</li>
                  <li>事件循环的顺序决定了javascript代码的执行顺序，事件循环从宏任务script开始执行，执行过程中遇到任务源就会分发对应的任务到任务队列，script全局代码运行完毕并退出函数调用栈，然后执行所有的微任务micro-tasks，第一次循环结束。第二次循环从宏任务开始，根据宏任务队列的先后顺序，执行完一条任务队列后执行，执行所有的微任务micro-tasks，然后回到宏任务执行下一个宏任务队列，之后执行所有的微任务队列事件，循环直到所有任务队列都为空，此时第二次事件循环结束。</li>
                </ol>
                <p>这里不准备结合例子展开了。</p>
                <h4 id="setTimeout定时函数的原理依然摸不清楚">
                  <a href="#setTimeout定时函数的原理依然摸不清楚" class="headerlink" title="setTimeout定时函数的原理依然摸不清楚"></a>setTimeout定时函数的原理依然摸不清楚</h4>
                <p>但是有一点可以肯定：定时器函数是在定时时间结束后才将定时器函数放入宏队列。
                  <br>所以就当是运行setTimeout函数的时候先休眠延迟时间，然后把回调事件发送到事件队列。</p>
                <h4 id="补充（17-08-02）">
                  <a href="#补充（17-08-02）" class="headerlink" title="补充（17-08-02）"></a>补充（17-08-02）</h4>
                <p>之前一直忽略了一个细节，那就是setTimeout函数是DOM API的东西，属于浏览器定时器，想到这里就瞬间想通了这个问题。 </p>
                <p>浏览器本身是多线程的。 </p>
                <p>浏览器线程有4种： </p>
                <ul>
                  <li>javascript引擎</li>
                  <li>GUI页面渲染</li>
                  <li>浏览器事件触发线程</li>
                  <li>http请求线程</li>
                </ul>
                <p>其中，前三个线程是常驻线程，http线程请求完成以后就会close。
                  <br>
                  <strong>这四个线程这怎么互相协作的呢？</strong>
                  <br>&nbsp;&nbsp;&nbsp;浏览器最重要的线程就是javascript引擎线程，其他的线程都是借助javascript引擎线程的事件循环机制来执行的。
                </p>
                <ol>
                  <li>
                    <p>GUI页面渲染线程，在需要渲染页面的时候就会给javascript宏任务中队列中添加一个事件，利用事件循环来执行。</p>
                  </li>
                  <li>
                    <p>http请求线程，在完成http请求以后将请求完成的回调事件添加到任务列表中。</p>
                  </li>
                  <li>浏览器事件触发线程，在触发浏览器事件，比如点击、界面缩放、滚动等事件时，就会将对应的回调函数事件添加在宏任务队列中，利用事件循环来进行，</li>
                </ol>
                <p>javascript引擎线程是所有线程的核心中枢，是师执行者，其他的几个线程都是消息捕获的执行者和消息分发的分配者。</p>
                <p>&nbsp;&nbsp;&nbsp;理解了这些就不难理解setTimeout的时间循环机制。javascript的任务队列中的任务并不是全部由它自己分发的，更多的是浏览器的其他线程分发的。setTimeout事件就是由浏览器事件触发线程分发。</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/08/02/s的事件循环机制（v8）（二）/" data-id="cjajctdqr000d04qtzok0smed"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/javascript/">javascript</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-js的事件循环机制（v8）（一）" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/09/js的事件循环机制（v8）（一）/" class="article-date">
                <time datetime="2017-07-09T08:02:25.000Z" itemprop="datePublished">2017-07-09</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/javascript/">javascript</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/09/js的事件循环机制（v8）（一）/">js事件循环机制（一）</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="问题">
                  <a href="#问题" class="headerlink" title="问题"></a>问题</h4>
                <p>&nbsp;&nbsp;对于js事件循环机自会的理解不清楚，经常导致一些代码执行顺序上的混乱，js事件循环机制决定了代码的执行顺序，下面将对事件循环机制的规则进行总结。
                  <br>&nbsp;&nbsp;自己写的博客不是为了写教程，更多的个人总结，我总喜欢带入第三人的角度去写这些东西</p>
                <h4 id="事件循环">
                  <a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4>
                <p>&nbsp;&nbsp;
                  <strong>什么是js事件循环呢</strong>
                  <br>我在网上看到的博文，我也不知道是否是完全正确的，阮一峰的博文在解释事件循环机制的时候只讲到时间循环的概念，简书签约作者波同学的博文更深一层的讲解了事件循环的执行规则，我暂时也不能确认哪些是正确的，哪些是错误的，后面的工作学习，我自己再慢慢总结吧。
                </p>
                <h5 id="阮一峰的博文解释">
                  <a href="#阮一峰的博文解释" class="headerlink" title="阮一峰的博文解释"></a>阮一峰的博文解释</h5>
                <p>实际上，我对阮一峰的博文还是有些怀疑的，写得很混乱也不清晰。反而波同学的相对写得清楚一些。</p>
                <p>
                  <strong>为什么js是单线程？</strong>
                  <br>&nbsp;&nbsp;js作为单线程的设计是事出有因的，其他语言大多都有设计多线程来满足并发需求。但是js没有，究其根本也正是因为js某种程度上不需要多线程。js语言本质上是浏览器的脚本语言，js固然可以进行逻辑业务运算，但是最后的目的还是为了控制界面展示，操作DOM。而操作DOM是不能兼容多线程的，比如一个线程修改了DOM节点，一个线程删除了DOM节点，这种矛盾逻辑作为页面体现是不可取的，因此js只能是单线程语言，现在是，以后也是。
                </p>
                <p>&nbsp;&nbsp;HTML5的新特性web Worker是js在多线程的尝试，但是也有主线程和子线程的区别，浏览器js线程是主线程，能完全控制web
                  Worker线程，web worker线程也不能操作DOM，只能进行业务逻辑运算。 </p>
                <p>
                  <strong>什么是任务队列？</strong>
                  <br>&nbsp;&nbsp;js作为单线程语言，就意味着任务的执行必须排队，和java等语言一样，单一线程的执行任务只能排队进行。而这个队列就是j任务队列。
                  <br>&nbsp;&nbsp;js的任务队列于qianww语言不通，java由于支持多线程，所以并不支持异步操作，异步操作完全由多线程完成。js则不行，单线程同步运行会导致线程阻塞，比如在进行IO操作的时候，一个ajax请求，已经请求到了数据，但是由于要进行io操作需要延迟执行，这就会导致阻塞。
                  <br>&nbsp;&nbsp;因此js有了异步任务这个概念，将同步任务和异步任务分开来处理，同步任务在主线程中处理，js主线程使用函数调用栈来处理任务运行，同步任务被直接分配到函数调用栈也就是主线程里运行，异步任务则被分配到异步任务队列，而异步任务队列里的任务通知主线程：“我可以执行了”，此时才会进入函数调用栈执行。
                  <br>&nbsp;&nbsp;这个异步任务的任务队列就是js的任务队列。 </p>
                <p>
                  <strong>什么是事件循环？</strong>
                  <br>&nbsp;&nbsp;任务队列就是一个事件队列，或者说消息队列，这个事件指的是异步操作已经完成的事件，异步操作已经完成时就会在异步任务队列里新增一条事件完成的回调事件。IO操作完成以后就会在任务队列里增加一天IO操作已经完成的回调事件。
                  <br>&nbsp;&nbsp;任务队列的事件包括：IO、DOM事件、setTimeout等指定了回调函数的任务。
                  <br>&nbsp;&nbsp;主线程在同步任务执行完毕后会读取异步任务队列，事件队列是一个先进先出的队列。先进入的异步事件会优先执行。
                  <br>&nbsp;&nbsp;对于setTimeout和setInterval定时函数是怎么分配分配任务到任务队列的呢，阮一峰的博客里说定时器事件会在主线程最早空闲的时候执行，在读取定时器事件时会检查执行延迟时间，时间到了才能进入主线程，这里还是没有解释清楚，延迟时间是怎么处理的。</p>
                <p>
                  <strong>这是个死循环</strong>
                </p>
                <p>&nbsp;&nbsp;我去查了MDN，MDN上关于定时器是这么说的：</p>
                <blockquote>
                  <p>调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout
                    消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间。 </p>
                </blockquote>
                <p>MDN的意思是会延迟给定时间后将讲事件放入队列。MDN该市不会有错的，也可以想到肯定有一个东西把异步事件分配到异步队列，这个东西还具有定时延迟的问题，但是这是个死循环，一个已经具备延迟执行能力的东西把异步事件分配到异步队列，那这个东西又是怎么实现延迟执行能力的呢？
                  <br>晕</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/09/js的事件循环机制（v8）（一）/" data-id="cjajctdqo000804qtdpzl10zs"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/javascript/">javascript</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-es6总结/es6-Symbol" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/09/es6总结/es6-Symbol/" class="article-date">
                <time datetime="2017-07-09T06:51:42.000Z" itemprop="datePublished">2017-07-09</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6总结/">es6总结</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/09/es6总结/es6-Symbol/">es6-Symbol</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h4>
                <p>&nbsp;&nbsp;现代前端编写js代码ed时候，经常要使用来自其他源的对象，有时候我们要给对象扩充属性方法，但是es5按照名称来区分属性的方式会很容易导致属性名冲突，es6引入了Symbol基础类型来解决这个问题，使用Symbol创建的属性名是唯一的，永远不会和其他属性名冲突</p>
                <h4 id="Symbol是es新的基础类型之一">
                  <a href="#Symbol是es新的基础类型之一" class="headerlink" title="Symbol是es新的基础类型之一"></a>Symbol是es新的基础类型之一</h4>
                <p>&nbsp;&nbsp;以前es有5种基本类型，Undefined、Null、String、Number、Boolean，一种复杂类型Object。
                  <br>&nbsp;&nbsp;现在引入了新的基础类型Symbol。 </p>
                <pre><code>var a = Symbol();
typeof(a) // symbol
</code></pre>
                <p>&nbsp;&nbsp;typeof也有了新的返回值。这里有另一个知识点，以前typeof不管面对什么对象都会有返回值，不会报错，未定义的变量会返回undefined。但是在es6里，typeof在面对未声明的let对象的时候，会直接报错。</p>
                <h4 id="Symbol的使用">
                  <a href="#Symbol的使用" class="headerlink" title="Symbol的使用"></a>Symbol的使用</h4>
                <p>
                  <strong>创建Symbol对象</strong>
                  <br>&nbsp;&nbsp;Symbol是用来创建对象的唯一属性的，由于Symbol是基础类型的不是复杂类型，因此不能使用new关键字来创建，而是直接使用构造函数创建。
                </p>
                <pre><code>var s = {
    size: 0
};
var name = Symbol(&apos;cn&apos;);
s[name] = 1;

console.log(s)   //[ size: 0, Symbol(cn): 1 ]
console.log(s.size) // 0
console.log(s.notExist) // undefined
console.log(s[name])  // 1
console.log(s.name)// undefined

for(var ele in s){
    console.log(ele)
}
// size
var a = Object.getOwnPropertySymbols(s);
console.log(a); // [Symbol(cn)]


var des = Object.getOwnProperyDescriptor(s,name)
console.log(des) // {value: 1, writable: true, enumerable: true, configurable: true}
</code></pre>
                <p>&nbsp;&nbsp;上面的代码说明了Symbol的用法。 </p>
                <ol>
                  <li>
                    <p>Symbol是基本类型，创建对象的时候使用Symbol()，而不是new Symbol()</p>
                  </li>
                  <li>
                    <p>Symbol(“test”)构造函数的参数是Symbol的key，可以填入任意值，但是一般也要求填入有意义的，如果填入一个对象就会变成Symbol([object
                      Object]),key其实是调用了toString()方法。
                    </p>
                  </li>
                  <li>使用[]将Symbol值作为属性添加给对象，也是用[]来访问，不能使用“.”,点号是普通访问方法。</li>
                  <li>普通的遍历方法遍历不到Symbol属性，需要使用特殊的函数Object.getOwnPropertyDescriptor()来获取。</li>
                  <li>通过查看Symbol属性的特性，发现枚举属性enumerable为true，这证明，不可被遍历的实现机制并不是利用了属性的枚举特性。</li>
                </ol>
                <h4 id="Symbol的登记">
                  <a href="#Symbol的登记" class="headerlink" title="Symbol的登记"></a>Symbol的登记</h4>
                <p>&nbsp;&nbsp;Symbol其实是一个登记策略，在当前环境中登记一个值，每次调用构造函数就会登记一个值。
                  <br>&nbsp;&nbsp;但是有时候并不需要每次都登记同一个值，因此有了两个相关的函数。
                  <br>
                  <strong>Symbol.for()</strong>
                  <br>&nbsp;&nbsp;Symbol.for(key)函数会查找当前环境是否登记了给定key的Symbol值，没有则会登记并且调用构造函数创建一个新的Symbol值，有则返回这个Symbol值。</p>
                <p>
                  <strong>Symbol.keyFor()</strong>
                  <br>Symbol.for(key)函数会查找当前环境是否登记了给定key的Symbol值，没有则会返回undefined，有则返回这个Symbol值。
                </p>
                <p>&nbsp;&nbsp;symbol值是否登记和是否有Simbol值是两个不冲突的概念。</p>
                <h4 id="Symbol内置了一堆Symbol值，">
                  <a href="#Symbol内置了一堆Symbol值，" class="headerlink" title="Symbol内置了一堆Symbol值，"></a>Symbol内置了一堆Symbol值，</h4>
                <p>&nbsp;&nbsp;es6在某些功能的实现中，使用了这些内置的值。这些值用到了再去记忆吧。</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/09/es6总结/es6-Symbol/" data-id="cjajctdrf001n04qt8yc12r2s"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-es6总结/es6对象扩展" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/08/es6总结/es6对象扩展/" class="article-date">
                <time datetime="2017-07-08T05:57:13.000Z" itemprop="datePublished">2017-07-08</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/08/es6总结/es6对象扩展/">es6-对象扩展</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="基础回顾">
                  <a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h4>
                <p>&nbsp;&nbsp;在js高级程序设计中已经知道了关于对象的一些定义和特性，对象是无序的属性的集合。 </p>
                <ol>
                  <li>对象的属性和分为数据属性和访问器属性。 </li>
                  <li>数据特性有value、configurable（能否被配置除）、writable（是否只读）、enumerable（是否可以被枚举遍历出来）</li>
                  <li>访问器特性有get、set、configurable、enumerable</li>
                  <li>获取特性的函数Object.getOwnPropertyDescriptor()、定义属性特性的函数Object.defineProperty()和Object.defineProperties()</li>
                  <li>一旦一个属性已经修改了configurable特性，被设定为false不可配置以后，就不能再次被修改除value外的其他属性了。</li>
                  <li>创建对象的发展历史：工厂模式-》构造函数模式-》原型模式-》组合使用构造函数和原型模式-》动态圆形模式-》计生/稳妥构造函数模式</li>
                  <li>原型、prototype属性、对象实例实例、构造函数、
                    <strong>proto</strong>属性之间的关系：对象的prototype指向对象的原型，对象的实例的
                    <strong>proto</strong>属性指向对象的原型，原型的constructor属性指向对象的构造函数。</li>
                  <li>函数的继承就是利用了原型链的原理，将对象的实例的原型赋值为被继承函数。</li>
                </ol>
                <p>这些对象的知识点看起来不多，但是每一条都展开确实还是要花费好一些时间。只是，原型相关的知识现在越来越用不到了，不论是继承还是封装对象，es6里都进行了扩展。有时候真觉得花的这么些时间来理解吃透原型究竟有多少用。</p>
                <h4 id="属性的简写">
                  <a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h4>
                <p>&nbsp;&nbsp;es6支持对属性名进行简写，就像解构里的模式一样，可以使用模式简写的方式来简写对象属性，对于属性方法，也可以省略掉function关键字。确实是很好用的简写方式，节省了大量冗余代码。</p>
                <h4 id="Object-is-函数">
                  <a href="#Object-is-函数" class="headerlink" title="Object.is()函数"></a>Object.is()函数</h4>
                <p>&nbsp;&nbsp;传统的判断上是否相等函数有一定的漏洞，比如-0不等于+0，NaN等于NaN，但是其实正确结果是相反的，es6使用了新的算法来进行全等判断，比===更加有效。</p>
                <h4 id="Object-assign-函数">
                  <a href="#Object-assign-函数" class="headerlink" title="Object.assign()函数"></a>Object.assign()函数</h4>
                <p>&nbsp;&nbsp;Object.assign(target,source)函数会将source对象中的所有可枚举属性复制到target对象中，并且会覆盖同名的对象。
                  <br>&nbsp;&nbsp;这个对象复制的方法并不是深复制，在面对可枚举属性是对象的时候，只是进行了浅复制，复制了引用地址。对于这一点要格外小心</p>
                <h4 id="属性的遍历">
                  <a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4>
                <p>&nbsp;&nbsp;属性石头可被遍历和它的enumerable属性有关，若是enumerable属性为false不可被枚举，此时使用for
                  in就不能遍历该对象，这里在总结列举一下遍历对象的方式：
                </p>
                <ol>
                  <li>for in：会遍历出自身的可枚举属性以及继承的可枚举属性</li>
                  <li>for of：会遍历出所有自身的可枚举属性</li>
                  <li>Object.keys()/values()/entries()：自身的可枚举属性</li>
                  <li>JSON.stringify()：只会串行化自身的可枚举属性</li>
                  <li>Object.assign()：可枚举的自身属性</li>
                  <li>Reflect.enumerate()：和for in 一样</li>
                </ol>
                <h4 id="对象扩展运算符">
                  <a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h4>
                <p>&nbsp;&nbsp;也可以对对象使用扩展运算符 … 。有下面两种用法。</p>
                <ol>
                  <li>解构赋值的时候使用…进行扩展</li>
                  <li>复制对象</li>
                </ol>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/08/es6总结/es6对象扩展/" data-id="cjajctdri001t04qtnhbk0qw3"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-es6总结/关于js递归的一个问题" class="article article-type-post" itemscope
                                                                                          itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/07/es6总结/关于js递归的一个问题/" class="article-date">
                <time datetime="2017-07-07T10:23:07.000Z" itemprop="datePublished">2017-07-07</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/javascript/">javascript</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/07/es6总结/关于js递归的一个问题/">关于js递归的一个问题</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="发现的两个递归问题">
                  <a href="#发现的两个递归问题" class="headerlink" title="发现的两个递归问题"></a>发现的两个递归问题</h4>
                <p>之前学习了es6递归的尾调用优化了，刚好在codewars刷题的时候就遇到了一个判断任意数是否是平方数的问题，正好利用递归来完成这个题目，原来的代码如下：
                </p>
                <pre><code>var isSquare = function(n){
    function square(index = 0,n){
        var res = index*index;
        if(res === n){
            return true;
        }else if(res &gt; n){
            return false;
        }
        index++;
        return square(index,n) //这里如果不用return来调用递归就得不到正常的返回值。
    }
    return  square(0,n);
}
</code></pre>
                <p>这里有一个小细节，在递归时如果想要递归结果返回某个值，那么在递归调用函数的时候必须使用return，很好理解，被调用的时候返回的只是一个数值，并没有在外层函数中返回。</p>
                <h4 id="内存溢出">
                  <a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4>
                <p>递归很容易导致内存溢出，上面的代码在n足够大的时候就会导致内存溢出，原因在于每次递归函数调用都会创建执行上下文，而js线程被分配的栈空间是有限的，每个执行上下文window分配为1M，在浏览器不支持尾调用优化的情况下，递归数量次数一旦过多就会内存溢出</p>
                <h4 id="在没有尾调用优化的情况下应该少用递归，尽量少用for循环。">
                  <a href="#在没有尾调用优化的情况下应该少用递归，尽量少用for循环。" class="headerlink" title="在没有尾调用优化的情况下应该少用递归，尽量少用for循环。"></a>在没有尾调用优化的情况下应该少用递归，尽量少用for循环。</h4>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/07/es6总结/关于js递归的一个问题/" data-id="cjajctdrh001r04qt9hoyc3q4"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/javascript/">javascript</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-es6总结/函数的扩展（二）" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/06/es6总结/函数的扩展（二）/" class="article-date">
                <time datetime="2017-07-06T11:32:47.000Z" itemprop="datePublished">2017-07-06</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/06/es6总结/函数的扩展（二）/">es6-函数扩展（二）</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="箭头函数">
                  <a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4>
                <p>箭头函数大大的简化了函数的写法，： </p>
                <pre><code>var a = x =&gt; x*x;
</code></pre>
                <p>箭头函数省去了function声明，省略了参数的写法，省略了返回的写法，有下面几个规则： </p>
                <ol>
                  <li>没有或者有多个参数，需要使用（）将参数包裹起来，只有一个参数则不用</li>
                  <li>如果箭头函数直接返回一个基础类型的值，则不需要使用{}，如果直接返回一个对象，那么需要使用（）括起来</li>
                  <li>箭头函数的函数体按照传统函数的写法使用{}括起来是永远没有错的，</li>
                  <li>如果函数体不只有一行代码，则需要使用{}括起来</li>
                </ol>
                <p>箭头函数的特性：</p>
                <ol>
                  <li>箭头函数在创建执行上下文的时候有两个特性，确认this指向时直接指向上层函数的this，创建变量对象的时候回跳过arguments对象的创建。因此，箭头函数会绑定this对象，并且，无法使用arguments对象。
                  </li>
                  <li>不能使用new关键字，箭头函数没有构造函数</li>
                  <li>不能使用yield命令，箭头函数不能用作generator函数。</li>
                </ol>
                <h4 id="函数绑定">
                  <a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h4>
                <p>就像箭头函数强行绑定了this一样，es7有了一条用来绑定函数的关键字提案天，而且babel也支持转化。
                  <br>es7使用::来作为绑定obj1::obj2.sayName()会将sayName函数绑定到obj1对象上。虽然没有看出来到底有啥用，不过确实要好写一些。</p>
                <h4 id="尾调用优化">
                  <a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4>
                <p>&nbsp;&nbsp;在函数的return语句里直接返回函数叫做尾调用，而被返回的函数在没有使用父函数的和参数变量有关的变量的情况下，呗返回函数会替换掉父函数的函数调用栈的情况叫做尾调用优化。
                  <br>这种情况下可以极大的减少内存消耗，因此要尽量高些递归变量的写法，做到尾调用优化。 </p>
                <pre><code>function factorial(n, total) {
    if (n === 1) return total;
    return factorial(n - 1, n * total);
} 
factorial(5, 1) // 120
</code></pre>
                <p>目前es6支持尾调用优化，这将去掉一些不必要的闭包内存消耗。</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/06/es6总结/函数的扩展（二）/" data-id="cjajctdrk001z04qttofmp8kw"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <nav id="page-nav">
            <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a>
            <a class="page-number" href="/">1</a>
            <span class="page-number current">2</span>
            <a class="page-number" href="/page/3/">3</a>
            <a class="page-number" href="/page/4/">4</a>
            <a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
          </nav>
        </section>

        <aside id="sidebar">

          <div class="widget-wrap">
            <h3 class="widget-title">Categorieën</h3>
            <div class="widget">
              <ul class="category-list">
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/HTTP-axios/">-- HTTP -- axios</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/es6总结/">es6总结</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/es6知识梳理/">es6知识梳理</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/github/">github</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/javascript/">javascript</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/js基础/">js基础</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/markDown/">markDown</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/react/">react</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/个人总结/">个人总结</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/前端问题梳理/">前端问题梳理</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/框架整理/">框架整理</a>
                </li>
              </ul>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Labels</h3>
            <div class="widget">
              <ul class="tag-list">
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/axios/">axios</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/es6/">es6</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/express/">express</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/github/">github</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/javascript/">javascript</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/js/">js</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/js基础/">js基础</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/lowdb/">lowdb</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/markDown/">markDown</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/moment/">moment</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/react/">react</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/vue/">vue</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/webpack/">webpack</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/前端/">前端</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/总结/">总结</a>
                </li>
              </ul>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Tag Cloud</h3>
            <div class="widget tagcloud">
              <a href="/tags/axios/" style="font-size: 10px;">axios</a>
              <a href="/tags/es6/" style="font-size: 16.67px;">es6</a>
              <a href="/tags/express/" style="font-size: 10px;">express</a>
              <a href="/tags/github/" style="font-size: 10px;">github</a>
              <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a>
              <a href="/tags/js/" style="font-size: 10px;">js</a>
              <a href="/tags/js基础/" style="font-size: 10px;">js基础</a>
              <a href="/tags/lowdb/" style="font-size: 10px;">lowdb</a>
              <a href="/tags/markDown/" style="font-size: 10px;">markDown</a>
              <a href="/tags/moment/" style="font-size: 10px;">moment</a>
              <a href="/tags/react/" style="font-size: 10px;">react</a>
              <a href="/tags/vue/" style="font-size: 10px;">vue</a>
              <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
              <a href="/tags/前端/" style="font-size: 20px;">前端</a>
              <a href="/tags/总结/" style="font-size: 10px;">总结</a>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Archieven</h3>
            <div class="widget">
              <ul class="archive-list">
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/11/">November 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/08/">August 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/07/">July 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/06/">June 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/05/">May 2017</a>
                </li>
              </ul>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Recente berichten</h3>
            <div class="widget">
              <ul>

                <li>
                  <a href="/2017/11/28/框架整理/框架整理（三）--mian入口文件/">万达监控预警项目前端框架整理（三）----项目入口文件</a>
                </li>

                <li>
                  <a href="/2017/11/28/框架整理/万达预警监控项目前端框架整理（二）/">前端框架（二）</a>
                </li>

                <li>
                  <a href="/2017/11/27/框架整理/万达预警监控项目前端框架整理（-）/">前端框架（一）</a>
                </li>

                <li>
                  <a href="/2017/11/27/vue源码学习/数据监控/">(no title)</a>
                </li>

                <li>
                  <a href="/2017/08/11/problems/事件委托、jq事件委托/">(no title)</a>
                </li>

              </ul>
            </div>
          </div>

        </aside>

      </div>
      <footer id="footer">

        <div class="outer">
          <div id="footer-info" class="inner">
            &copy; 2017 陈宁
            <br> Powered by
            <a href="http://hexo.io/" target="_blank">Hexo</a>
          </div>
        </div>
      </footer>

    </div>
    <nav id="mobile-nav">

      <a href="/" class="mobile-nav-link">Home</a>

      <a href="/archives" class="mobile-nav-link">Archives</a>

    </nav>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js">


    </script>

    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
    <script src="/fancybox/jquery.fancybox.pack.js"></script>

    <script src="/js/script.js"></script>

  </div>
</body>

</html>
