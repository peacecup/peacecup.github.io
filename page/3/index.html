<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">

  <title>长夜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="打开新世界的大门">
  <meta property="og:type" content="website">
  <meta property="og:title" content="长夜">
  <meta property="og:url" content="https://peacecup.github.io/page/3/index.html">
  <meta property="og:site_name" content="长夜">
  <meta property="og:description" content="打开新世界的大门">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="长夜">
  <meta name="twitter:description" content="打开新世界的大门">

  <link rel="alternate" href="/atom.xml" title="长夜" type="application/atom+xml">

  <link rel="icon" href="/favicon.png">

  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="/css/style.css">

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
        <div id="banner"></div>
        <div id="header-outer" class="outer">
          <div id="header-title" class="inner">
            <h1 id="logo-wrap">
              <a href="/" id="logo">长夜</a>
            </h1>

            <h2 id="subtitle-wrap">
              <a href="/" id="subtitle">I Want More！</a>
            </h2>

          </div>
          <div id="header-inner" class="inner">
            <nav id="main-nav">
              <a id="main-nav-toggle" class="nav-icon"></a>

              <a class="main-nav-link" href="/">Home</a>

              <a class="main-nav-link" href="/archives">Archives</a>

            </nav>
            <nav id="sub-nav">

              <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>

              <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
            </nav>
            <div id="search-form-wrap">
              <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form">
                <input type="search" name="q" class="search-form-input" placeholder="Search">
                <button type="submit" class="search-form-submit">&#xF002;</button>
                <input type="hidden" name="sitesearch" value="https://peacecup.github.io">
              </form>
            </div>
          </div>
        </div>
      </header>

      <div class="outer">
        <section id="main">
          <article id="post-es6总结/函数的扩展（一）" class="article article-type-post" itemscope
                                                                                          itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/05/es6总结/函数的扩展（一）/" class="article-date">
                <time datetime="2017-07-05T01:05:13.000Z" itemprop="datePublished">2017-07-05</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/05/es6总结/函数的扩展（一）/">es6-函数扩展（一）</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="函数默认值">
                  <a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h4>
                <p>&nbsp;&nbsp;es5是不支持默认函数值的，在以前要实现默认函数值只能够通过 </p>
                <pre><code>y = y||&apos;dadasd&apos;
</code></pre>
                <p>这样的方法，而es6支持了函数默认值。
                  <br>&nbsp;&nbsp;函数默认值的触发条件为undefined，只有在参数为undefined的时候才会默认赋值，参数为null或者false等值时不会默认赋值</p>
                <h5 id="函数默认值和结构赋值结合使用">
                  <a href="#函数默认值和结构赋值结合使用" class="headerlink" title="函数默认值和结构赋值结合使用"></a>函数默认值和结构赋值结合使用</h5>
                <p>&nbsp;&nbsp;函数默认值可以和解构赋值结合使用，需要弄清楚的规则只有一条： </p>
                <pre><code>1. 函数接受到参数的时候先判断参数是否是undefined，如果是，触发默认值，如果不是，则由传入参数进行解构赋值
2. 进行解构赋值的时候，如果解构得到的结果是undefined，则对被赋值对象赋予默认值
</code></pre>
                <h5 id="函数默认值的位置">
                  <a href="#函数默认值的位置" class="headerlink" title="函数默认值的位置"></a>函数默认值的位置</h5>
                <p>&nbsp;&nbsp;函数的默认值只有在末尾的时候可以省略不谢，这时默认会传入undefined，而默认值如果不在末尾则不能省略不写，如果实在不能复制，也要传入一个undefined。</p>
                <h5 id="length属性失效">
                  <a href="#length属性失效" class="headerlink" title="length属性失效"></a>length属性失效</h5>
                <p>&nbsp;&nbsp;length会在读取到默认参数时失效。</p>
                <ol>
                  <li>在没有默认参数时，函数的length属性会得到函数参数的个数</li>
                  <li>在有默认参数时，函数的length属性会从设置默认参数的参数位置开始失效。</li>
                </ol>
                <h5 id="默认参数的作用域">
                  <a href="#默认参数的作用域" class="headerlink" title="默认参数的作用域"></a>默认参数的作用域</h5>
                <p>&nbsp;&nbsp;函数的默认参数也有作用域。这里的作用域单凭函数代码很难判断：</p>
                <pre><code>let x = 1;
function f(y = x) {
    var x = 2;// let x =2 结果一样
    console.log(y);
}
f()//1
</code></pre>
                <p>在思考了这个例子以后我得出了一个结论： </p>
                <pre><code>默认参数作用域和传统作用域一样，先是函数作用域，然后是外部作用域。
</code></pre>
                <p>但是这个结论的理解对js原理要有一定的理解，首先，什么是作用域？</p>
                <pre><code>作用域是一套规则，创建执行上下文的时候就会创造作用域，js是词法作用域。  
它规定了查找变量的路径和方式，也就是先在自己内部找，找不到再去外部找
</code></pre>
                <p>默认参数在进行变量查找的时候就会按照作用域规则进行查找
                  <br>然后要理解，默认参数的运行时机，它是什么时候运行，什么时候完成赋值？</p>
                <pre><code>参数定义于赋值站在创建变量对象的第一步完成，前面提到过，先完成arguments  
对象的创建与赋值，然后针对var和函数声明进行提前声明。
然而在默认参数进行赋值的时候函数内部的变量和函数其实还没有被初始化。
因此其实默认参数的作用域是不包括自己的， 狭义上可以这么理解
</code></pre>
                <p>所以最后得到结论，默认参数的变量赋值是不参考内部作用域的。内部作用域找不到非参数变量，像y=x这种赋值，x只能去外部作用域找。</p>
                <h5 id="一个问题，let究竟有没有变量提升？">
                  <a href="#一个问题，let究竟有没有变量提升？" class="headerlink" title="一个问题，let究竟有没有变量提升？"></a>一个问题，let究竟有没有变量提升？</h5>
                <p>在知乎上看到这个专栏，虽然对使用let没有影响，但对理解它有帮助，let也是有变量提升的，只是这个变量提升与我们传统的理解有些不同，我们熟悉的是声明提升，也就是把函数声明提升，还有一种提升是创建提升，在let变量没有被声明提升这是肯定的，但是js对它进行了创建提升，一个变量是先被创建，然后被声明，let声明只有创建提升，没有变量提升，所以在重复声明let的时候，可以提前报错错误，is
                  already been decleared，js不允许重复创建，但是它允许重复声明。
                  <br>可能莫名其妙看到这里的人已经乱了。。。。。但是我不准备花时间把这个不重要的深度知识点详细说一遍，想看的可以自己去看知乎的这篇专栏吧
                  <br>
                  <a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28140450</a>
                </p>
                <h4 id="rest参数写法-…">
                  <a href="#rest参数写法-…" class="headerlink" title="rest参数写法 …"></a>rest参数写法 …</h4>
                <p>&nbsp;&nbsp;es6支持使用rest参数的方式来获取多余的参数，rest会将参数扩展成一个数组，可以不再使用arguments对象，但是rest参数不能放在参数中间，只能坐在最后一个</p>
                <h4 id="扩展运算符-…">
                  <a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h4>
                <p>&nbsp;&nbsp;rest参数和扩展运算符在形式上是一样的，但是作用完全相反，扩展运算符是用来将数组或者类似数组的具有iterable接口的对象转换成单个的元素。
                  <br>扩展运算符使用场景很多，可以扩展字符串成为数组改进apply，可以改进apply函数参数的写法，可以和解构结合使用获取数组内容。</p>
                <h4 id="name属性">
                  <a href="#name属性" class="headerlink" title="name属性"></a>name属性</h4>
                <p>&nbsp;&nbsp;函数的name属性指向函数的名称。</p>
                <ol>
                  <li>对于函数声明的函数对象，name指向函数名，对于对象字面量声明的匿名函数，es5中name属性为空的字符串‘’，而es6中为对象名。
                    </li>
                  <li>bind函数绑定使用的函数的名称前面都要加上bound。</li>
                </ol>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/05/es6总结/函数的扩展（一）/" data-id="cjajctdrj001w04qt66cdzjua"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-es6总结/es6数组扩展" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/04/es6总结/es6数组扩展/" class="article-date">
                <time datetime="2017-07-04T01:03:52.000Z" itemprop="datePublished">2017-07-04</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/04/es6总结/es6数组扩展/">es6-数组扩展</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h4 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h4>
                <p>&nbsp;&nbsp;数组不管在那个语言里都是很重要的一种数据类型，数组的使用广泛让怎么合理高效率的使用它成为一个问题，我目前遇到的问题主要集中两个部分：
                </p>
                <ol>
                  <li>空间、时间复杂度：滥用数组，动不动就新建数组，针对存储列表类数据向来是直接使用数组来操作。也不怎么考虑事件复杂度，大多数时候会做多层遍历，结合起来很容易写出低质量的代码，</li>
                  <li>数组复制，在需要复制数组数据的时候面对复杂数据类型，有些复制做起来完全是无效的，或者就是增大空间复杂度。</li>
                </ol>
                <p>&nbsp;&nbsp;我的编码经历来说，一段处理业务逻辑的代码很少有不用到数组或者说json这种这些数据结构的，对于数组、对象、json这些数据类型的操作要考虑清楚再动手敲代码
                </p>
                <p>&nbsp;&nbsp;es6对数组的扩展一定程度上解决了一些问题</p>
                <h4 id="新的扩展">
                  <a href="#新的扩展" class="headerlink" title="新的扩展"></a>新的扩展</h4>
                <p>&nbsp;&nbsp;新的扩展主要集中于数组的生成、复制，填充，查找，遍历上</p>
                <ol>
                  <li>生成：
                    <ul>
                      <li>Array.from()：可以将所有可遍历的类似数组的对象转化为数组，也就是有有iterable遍历接口的对象，进一步可以理解为只要是有length属性就可以转化，但是不是数值的length会被转化为空的数组[]。这样在这些类似数组的对象就可以使用数组遍历方法进行遍历，例如arguments对象，它并不是一个数组，不可以使用foreach等方法。</li>
                      <li>Array.of():扩展了数组的构造函数</li>
                    </ul>
                  </li>
                  <li>复制：原先的数组可以使用concat、slicee函数来进行赋复制</li>
                  <li>填充：es5原有一个splice函数可以进行删除和新增，es6扩充了一个copyWith函数来将数组的某一个连续元素赋值到另一个位置。还有fill（）函数可用来填充数组</li>
                  <li>查找：es6扩充了find（）和findIndex（）函数来查找数组元素，includes（）函数可以用来判断数组是否包含某个元素</li>
                  <li>遍历，es6中，实现了iterable接口的对象都可以使用新的遍历函数进行遍历：entries（）和value（），结合keys()作为三个遍历函数。
                    关于遍历还有一个要注意的问题就是，传统的遍历方法，every、some、map、forEach在遍历时都会一定程度上忽略空的数组元素，map会直接返回一个空元素，而es6扩展的数组方法在生成数组时就会将空元素解析为undefined，并且在使用for。。。of遍历时也会遍历undefined元素
                  </li>
                </ol>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/04/es6总结/es6数组扩展/" data-id="cjajctdrn002904qtu8b9mhk7"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-es6总结/es6字符串扩展" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/03/es6总结/es6字符串扩展/" class="article-date">
                <time datetime="2017-07-03T03:24:12.000Z" itemprop="datePublished">2017-07-03</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/03/es6总结/es6字符串扩展/">es6-字符串扩展</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h5 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h5>
                <p>&nbsp;&nbsp;es6很大程度上是对es5的扩展，完全向下兼容，并且扩展出新特性。</p>
                <h5 id="新特性">
                  <a href="#新特性" class="headerlink" title="新特性"></a>新特性</h5>
                <p>&nbsp;&nbsp;es6在字符串上增加了的新特性有一下面这几种特性。 </p>
                <ol>
                  <li>对unicode字符的进一步支持</li>
                  <li>includes()、startsWith()、endsWith()函数用来增强indexOf()能力</li>
                  <li>repeat()、padStart()、padEnd()函数用来充填字符串</li>
                  <li>字符串模板和标签模板
                    <h6 id="unicode">
                      <a href="#unicode" class="headerlink" title="unicode"></a>unicode</h6>&nbsp;&nbsp;unicode的部分没能深入进去了解，javasccript内部使用utf-16来存储，首先unicode是一种能囊括全世界的文字符号的一种编码方式，每一个字符都有一个码点，而utf-8以及gbk以及utf-16等都是针对unicode的进一步汉字转码。
                    <br>&nbsp;&nbsp;es5的汉字字符串很有可能并不只是占有一个32位的utf-16字符，很可能会超过32位，这个时候就会用两个utf-16码点来表示字符串，此时，length就会变成2，哪怕只是一个汉字，这是有问题的，es6扩充了一系列函数来解决这个问题。
                  </li>
                </ol>
                <h6 id="字符串模板">
                  <a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h6>
                <p>&nbsp;&nbsp;字符串的重点扩展在于字符串模板，字符串模板简化了使用js拼写html内容，在模板内使用${}就可以嵌入变量，在以前只能通过jquery的tmpl等类似的插件才能实现。
                  <br>&nbsp;&nbsp;而在字符串模板上进一步的标签模板则可以简化或者说扩充一种编写函数的新方式，标签模板作为参数传给函数，函数接受到的参数会有两部分，第一部分是字符串模板的静态部分被${}分隔开，以数组的方式传入，第二部分就是${}部分的内容，作为单个的参数传入。
                  <br>&nbsp;&nbsp;标签模板有两个强大的作用，一个是过滤HTML字符串，可以过滤掉一些不合法的内容，一个是用来做国际化，可以把需要国际化的部分使用${}变量表示，然后使用国际化转义来重新写入字符串</p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/03/es6总结/es6字符串扩展/" data-id="cjajctdrg001o04qthh14g66x"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-解构赋值" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/02/解构赋值/" class="article-date">
                <time datetime="2017-07-02T01:37:21.000Z" itemprop="datePublished">2017-07-02</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/02/解构赋值/">es6-解构赋值</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h5 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h5>
                <p>&nbsp;&nbsp;es6由于import、export模块化的能力，也推出了解构赋值这么一种能力，顾名思义，解析赋值，解析js代码然后进行赋值。这篇只是梳理并不设计代码例子。es6的解构赋值指的是在赋值表达式中解构右边部分的值然后将值赋给左边。
                </p>
                <h5 id="解构赋值的几种情况">
                  <a href="#解构赋值的几种情况" class="headerlink" title="解构赋值的几种情况"></a>解构赋值的几种情况</h5>
                <p>&nbsp;&nbsp;解构赋值在于根据赋值表达式左边的匹配模式，来解构右边的表达式并且完成赋值。根据右边的表达式的不同解构的结果不同。</p>
                <ul>
                  <li>对数组的解构</li>
                  <li>对对象的解构</li>
                  <li>对字符串的解构</li>
                  <li>对函数的解构</li>
                  <li>对boolean的解构</li>
                </ul>
                <p>&nbsp;&nbsp;解构虽然是根据被解构对象不同会有不同的差别，但是原理都是一致的：按照一定的模式，从对象中提取值，并完成赋值，只是有一些特殊的情况需要注意。
                </p>
                <ol>
                  <li>解构赋值是可以有默认值的。在没有默认值的情况，如果没有解析到值那么，值就是undefined，所以只有在值被解析完成以后为undefined才会触发默认值，解析为null或者false等都不算。</li>
                  <li>模式匹配必须和右边的解构完全一致，不一致则会因此导致错误。</li>
                  <li>对一个已经声明的变量进行解构赋值是很容易导致错误的一件事，没有变量声明var、let、const，解析器无法确定这是一个解构赋值语句还是一个代码块，因此需要使用（）来包裹整体，（）包裹住就不会被认为是一个代码块</li>
                  <li>在对字符串解构的时候，字符串被改为一个类似数组的对象，会解构出每一个字符</li>
                  <li>对数字和布尔值进行解构的时候，原始类型的值会被转化成引用类型的封装对象。</li>
                  <li>最复杂的是结合函数参数进行解构赋值，由于函数参数可以有默认值，解构赋值对象也可以有默认值，将函数参数的默认值设置为有默认值的解构赋值是最复杂和麻烦的事，需要根据原理细致的查看，编写相应代码时也要格外小心。</li>
                  <li>（）在解构赋值中的使用也需要小心，只有赋值语句的非模式部分可以使用圆括号，其他任何地方使用圆括号都会报错</li>
                </ol>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/02/解构赋值/" data-id="cjajctdqz000q04qtos9bu3sc"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-let const" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/07/01/let const/" class="article-date">
                <time datetime="2017-07-01T06:34:42.000Z" itemprop="datePublished">2017-07-01</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/es6知识梳理/">es6知识梳理</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/07/01/let const/">es6-let/const</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h5 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h5>
                <p>&nbsp;&nbsp;尝试在不查看文档的情况下写出es6知识点的相关内容，遇到没记清楚的再查阅才能加深记忆力，好记性不如烂笔头
                  </p>
                <h5 id="let-const几个重要特性">
                  <a href="#let-const几个重要特性" class="headerlink" title="let/const几个重要特性"></a>let/const几个重要特性</h5>
                <ul>
                  <li>没有变量提升</li>
                  <li>暂时性死区</li>
                  <li>不允许重复声明</li>
                  <li>全局声明的变量不再挂载到window上</li>
                </ul>
                <p>&nbsp;&nbsp;理解没有变量提升，要先回顾变量提升的概念。js作为词法作用域的语言，js的作用域是在代码执行的时候确认的，代码执行的环境会有一个对应的执行上下文，每次进入一个执行环境都会创建一个执行上下文，执行上下文在创建阶段会做三件事。
                </p>
                <ol>
                  <li>确认作用域</li>
                  <li>创建变量对象</li>
                  <li>确认this指向</li>
                </ol>
                <p>&nbsp;&nbsp;变量提升就发生在创建变量对象时，创建变量对象要做2件事。第一，查找var变量声明，不包括let和const声明，在变量对象里生成对应变量名称的属性，重名的声明会被覆盖。第二，查找函数声明，生成对应函数名的指针对象指向函数的堆内存空间存放位置，重名的函数不会生效。
                </p>
                <p>&nbsp;&nbsp;在代码开始执行的时候，执行上下文就会进入执行阶段，变量对象就会变成活动对象，并且根据执行进度对活动对象里的提前声明的对象赋值。
                  <br>&nbsp;&nbsp;由此可以知道为什么let、const没有变量提升，因为，在进行变量提升的时候没有对let、const的变量声明进行提升。
                </p>
                <p>&nbsp;&nbsp;暂时性死区的概念其实和没有变量提升是一个意思，在let、const变量还没有声明的时候，在对应的作用域内使用它会直接导致报错，对于let、const变量而言，{}就是它们在还没有被声明时的死区。所以我认为阮一峰的es6入门在这一块的讲述是重复且有误导性的，没有变量提升其实是暂时性死区的原理，而不应该把两者都作为特性来说明。
                </p>
                <p>&nbsp;&nbsp;关于不允许重复声明这一条特性，在原理上确实不好理解，目前我只能理解成语法糖，语法规定了就是这样，不过从这条语法糖的意义上倒是可以看出js视图纠正之前变量声明过于灵活的问题，我一直无法理解可以重复声明同名变量还不回报错到底有什么意义，除了不会报错以外，在使用上完全可能破坏代码，降低代码质量。
                  <br>&nbsp;&nbsp;let、const声明的变量不再挂载到Window上野同样是为了规范变量声明，js不再默认允许随意的创建全局变量。
                  </p>
                <p>&nbsp;&nbsp;声明let、const变量导致的块级作用域不难理解，只要在{}内声明了let、const变量，{}就会成为一个es5里不支持的块级作用域。
                </p>
                <p>&nbsp;&nbsp;难以理解的是es6规定了在{}里声明的函数也会导致会计作用域，不需要其他声明，函数就会被绑定到这个作用域里。其实这让人很难理解，es6并没有摒弃es5的内容，执行上下文依然会创建，那么块级作用域又是如何在原理上实现的呢，如何检测、创建、绑定一个块级作用域？</p>
                <h4 id="问题：如何检测、创建、绑定一个块级作用域？">
                  <a href="#问题：如何检测、创建、绑定一个块级作用域？" class="headerlink" title="问题：如何检测、创建、绑定一个块级作用域？"></a>问题：如何检测、创建、绑定一个块级作用域？</h4>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/07/01/let const/" data-id="cjajctdqv000i04qtwpmnyi20"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/es6/">es6</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-react入门级基础知识（干货）" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/06/15/react入门级基础知识（干货）/" class="article-date">
                <time datetime="2017-06-15T02:03:43.000Z" itemprop="datePublished">2017-06-15</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/react/">react</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/06/15/react入门级基础知识（干货）/">react入门级教程（一）</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="react入门级教程（一）">
                  <a href="#react入门级教程（一）" class="headerlink" title="react入门级教程（一）"></a>react入门级教程（一）</h3>
                <h4 id="1、前言">
                  <a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4>
                <p>react的官方文档的逻辑和语言方式真的是难看，就像看外语翻译来的文学小说，再真挚再伟大的感情波动读起来都像是在看戏，还不如自己做一个总结。
                  <br>react和vue我都系统学习过，两者对比起来，react的自由度会更高一些，react的开发更接近原生js代码，除了它基本的不多的几个语法，其他的都是es6来完成
                  <br>，而vue配置项要多很多，语法也相对多很多，这也是为什么我近期准备啃react的原因，对于es6的高度依赖对开发人员的成长更有好处，能学到更多东西。
                  <br>写这个教程，最大的目的是巩固自己的基础，其次是希望能帮助到一些和我一样的初学者。</p>
                <h4 id="2、create-react-app">
                  <a href="#2、create-react-app" class="headerlink" title="2、create-react-app"></a>2、create-react-app</h4>
                <p>一个工程化的兼容性强的前端开发环境自己配置对于初学者来说是非常艰难的，需要配置es6环境，配置基于node的服务器，配置打包工具，配置模块化，
                  <br>配置css3、html5支持，等等。对初学者，这会是一个很难受的过程，去年年初，我自己在不知道vue-cli的情况下研读了github上别人的项目，对着一堆
                  <br>代码研究了好几天才搞明白，究竟在干嘛，还是在知道了vue-cli以后才知道是自动生成的代码，而不是自己写的，很难受。
                  <br>因此，学习这些框架在不进行进一步webpack配置的情况下，完全可以直接用自动化工具来初始化一个项目，而不需要自己来搭建，vue项目使用vue-cli，
                  <br>react项目使用create-react-app。使用npm安装create-react-app：</p>
                <pre><code>npm install create-react-app -g   //建议全局安装
</code></pre>
                <p>create-react-app构建了一个完善的开发环境，包括热替换等。 </p>
                <pre><code>//创建一个项目
create-react-app 项目名称
//初始化项目
npm install
//运行项目
npm start
</code></pre>
                <p>执行上面代码就可以初始化并且运行项目，会得到一个demo页面，这里就不截图了。src下的index是react项目的入口文件，其他的是组件。</p>
                <h4 id="3、react基础语法">
                  <a href="#3、react基础语法" class="headerlink" title="3、react基础语法"></a>3、react基础语法</h4>
                <p>其实之前也做了好几次整理，但是还是容易变得模糊，不精准，只能说好记性不如烂笔头，这里主要对对react部分来说明语法，react-dom暂且放一放
                  <br>这里会提到以下几个类和方法：react、Component、jsx、render、props。
                  <br>下面是一个简单的react组件 </p>
                <pre><code>import React,{Component} from &apos;react&apos;; //从react导入React相关环境以及组件环境
var root = document.querySelector(&quot;app&quot;);//拿到页面的根元素。
render(&lt;div&gt;haha&lt;/div&gt;,root);// 组件的render渲染方法，把虚拟的div组件绑定到root上
</code></pre>
                <p>其实上面三行代码已经包含了react的精髓内容，react更多的是一种基于数据的新的开发思维模式。
                  <br>第一行代码，在单页应用spa里依赖react的环境，这个环境有很多内容，这里只依赖了Component，一个组件相关的类
                  <br>第二行代码，获取要挂载的根节点
                  <br>第三行代码，创建一个虚拟DOM，也就是
                  <div>haha</div>,然后把这个虚拟DOM挂载到根节点上,
                  <br>react的精髓就在于创建虚拟DOM，挂载以后生成真实的DOM，用数据驱动虚拟DOM进行变化，虚拟DOM的变化反映到挂载的真实DOM上。
                  <br>react的目的就是更小耦合度的划分功能模块成组件，一个功能或者几个功能划分成一个组件，组件的通信来完成复杂功能。</p>
                <h4 id="4、创建组件的两种方式">
                  <a href="#4、创建组件的两种方式" class="headerlink" title="4、创建组件的两种方式"></a>4、创建组件的两种方式</h4>
                <p>通过reactDOm来创建的方式并不被官方推介。</p>
                <h5 id="a、创建无状态组件">
                  <a href="#a、创建无状态组件" class="headerlink" title="a、创建无状态组件"></a>a、创建无状态组件</h5>
                <p>由react开创的组件化的模式在于转换操作DOM为操作数据，以前我们习惯于使用jquery操作DOM来做页面逻辑操作，react的思路是利用操作数据来改变虚拟DOM然后更新真实DOM，比如一个表单验证，使用jquery是操作DOM来获取表单元素的值，然后对值进行校验，然后再一次操作提示部分的DOM进行复制，使用react的思路是创建一个虚拟的DOM表单，直接进行表单数据验证，将验证结果反应到反应到数据上，然后根据数据重绘表单界面。jquery是一个工具，运用jquery是一个横向的单点的过程，只关心自己择器操作的DOM，而不关心使用场景。而使用react是一个纵向的连续的过程
                  <br>一个react组件本身就是可以持续改变，多个组件通过父子关系，兄弟关系，在横向和纵向上可以组合拉伸。一个用户操作在jquery里只是一个普通的操作DOM改变界面，在react里却是能看到一条线，一条由用户操作引起的数据流向的线。更重要的一点是，react组件是可以积累的，是可复用的。
                  <br>会到第一种创建组件的方式：无状态组件。一个组件的状态就是它的数据，数据变化，组件就会重新绘制，无状态组件就是没有自己状态的组件，这种组件不在少数，只展示信息的组件，它不需要有属于自己的数据，他只负责展示，用户操作的组件，一个button只代表一个用户点击操作，它于它的父组件不可分割，也不需要有自己的数据。我们通过函数式的写法来创建组件：
                </p>
                <pre><code>ShowMessage.jsx
import React from &apos;react&apos;;
const ShowMessage = () =&gt; {
    return(
        &lt;div&gt;nihao&lt;/div&gt;
    )
}
export default ShowMessage;
</code></pre>
                <p>() =&gt; {}箭头函数式es6的写法，用来固定this指向,简写function，它等于 function(){},
                  <br>import和export是es6模块化的东西。上面这个组件就是一个没有自己状态的组件，但是它没有意义，一个静态div的组件是没有意义的，使它有意义的是他的父组件，它没有自己的数据，但是可以有父组件的数据，父组件传递数据给子组件的方式是通过属性，然后在子组件里通过props来获取数据.
                </p>
                <pre><code>parent.jsx

import showMessage from &apos;showMessage.jsx&apos;;
import React,{Component} from &quot;react&quot;;

class Parent extends Component{
    state = {
        message：&quot;hello&quot;
    }
    render(){
        return(
            &lt;ShowMessage message={message}/&gt;
        )
    }
}
export default Parent;
</code></pre>
                <p>这里使用属性的方式把message赋值给ShowMessage子组件。 {message}是jsx的语法，jsx是一个
                  <br>js的扩充语言，它的写法于html一样，在读取编译的时候，会使用creatElement函数来根据标签创建js对象，{message}是在jsx里插入变量的写法。</p>
                <pre><code>ShowMessage.jsx
import React from &quot;react&quot;;
const ShowMessage = (props) =&gt; {
    return(
        &lt;div&gt;{props.message}&lt;/div&gt;
    )
}
export default ShowMessage;
</code></pre>
                <p>在子组件里通过props来接受父组件的数据,包括给子组件绑定事件，如下 </p>
                <pre><code>&lt;ShowMessage message={message} method={this.method}/&gt;

ShowMessage.jsx
import React from &quot;react&quot;;
const ShowMessage = (props) =&gt; {
    return(
        &lt;div onClick={props.method}&gt;{props.message}&lt;/div&gt;
    )
}
export default ShowMessage;
</code></pre>
                <h5 id="b、创建有状态的组件">
                  <a href="#b、创建有状态的组件" class="headerlink" title="b、创建有状态的组件"></a>b、创建有状态的组件</h5>
                <p>上面的Parent组件其实就是有状态的组件 </p>
                <pre><code>parent.jsx

import showMessage from &apos;showMessage.jsx&apos;;
import React,{Component} from &quot;react&quot;;

class Parent extends Component{
    state = {
        message：&quot;hello&quot;
    }
    render(){
        return(
            &lt;ShowMessage message={message}/&gt;
        )
    }
}
export default Parent;
</code></pre>
                <p>class是es6创建类的关键字，于创建一个函数其实差别不大；extends是es6进行继承的写法，es5必须通过原型链将圆形赋值给被继承对象的实例才能完成继承，es6简化了这个部分，现在只需要使用extends就可以完成继承，当然也可以使用supper函数。
                  <br>Component是react里的组件相关的类，render是Component提供的渲染函数，用来渲染组件。
                  <br>一个组件有了自己的状态就可以做很多事情了，要牢记的一点是：组件的数据发生改变就会调用render函数重新绘制组件，组件的数据包括自己状态state和来自父组件的数据props。
                  <br>比如做一个提交功能，包含提交按钮，一个提示信息，提交时还要禁止点击 </p>
                <pre><code>Button.jsx
import React from &quot;react&quot;;
const Button = (props) =&gt; {
    const {children, loading, submit} = props;
    return (
        &lt;button onClick={submit} disabled={loading?&apos;disabled&apos;:null&gt;
            {loading &amp;&amp; &lt;i className=&quot;loading&quot;&gt;&lt;/i&gt;}
            {children}
            }
        &lt;/button&gt;
    )
}
export default Button;
</code></pre>
                <p>这个提交按钮Button组件没有自己的状态，只有父组件传递的提交函数，子元素，是否loadind。
                  <br>className是为了和class关键字区分开，className表示css类名，const { … } = props是es
                  <br>6解析结构的写法</p>
                <pre><code>Dialog.jsx
import React from &quot;react&quot;;
const Dialog = () =&gt; {
    const {message, close} = props;
    return(
        &lt;div className=&quot;dialog-backdrop&quot;&gt;
        &lt;div className=&quot;dialog-container&quot;&gt;
            &lt;div className=&quot;dialog-header&quot;&gt;提示&lt;/div&gt;
            &lt;div className=&quot;dialog-body&quot;&gt;{ message }&lt;/div&gt;
            &lt;div className=&quot;dialog-footer&quot;&gt;
                &lt;button className=&quot;btn&quot; onClick={ close }&gt;确定&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    )
}
</code></pre>
                <p>这个弹出框组件接受父组件的消息和关闭函数 </p>
                <pre><code>App.jsx
import React, { Component} from &quot;react&quot;;
import Button from &quot;Button.jsx&quot;;
class App extends Component{
    state = {
        message: &quot;&quot;,
        loading: false,
        dialog: false
    }
    submit = () =&gt; {
        this.setState({
            loading: true
        })
        setTimeout( () =&gt; {
            const res = Math.random(1);
            if(res &lt; 0.5){
                this.setState({
                    message: &quot;提交成功&quot;,
                    dialog: true
                })
            }else{
                this.setState({
                    message: &quot;提交成功&quot;,
                    dialog: true
                })
            }
            this.setState({
                    loading: false
            })
        })
    }
    close = () =&gt; {
        this.setState({
            dialog: false,
        })
    }
    render(){
        const {loading, message, dialog} = this.state;
        return (
            &lt;div className=&quot;app-wrap&quot;&gt;
                &lt;Button submit={this.submit} loading={loading}&gt;提交&lt;/Button&gt;
                {dialog &amp;&amp; &lt;Dialog message={message} close={this.close}/&gt;}
            &lt;/div&gt;
        )
    }
}
</code></pre>
                <p>这个由三个组件组成的提交功能的组合组件中数据的流向从上到下，从用户点击开始，点击改变了父组件状态，组件状态改变了子组件的props。</p>
                <h4 id="5、react组件的声明周期钩子">
                  <a href="#5、react组件的声明周期钩子" class="headerlink" title="5、react组件的声明周期钩子"></a>5、react组件的声明周期钩子</h4>
                <p>任何流程和事物都有一个生命周期，react的声明周期有三种：挂载前后、更新前后、销毁前
                  <br>挂载前后：componentWillMount（）、componentDidMount（） </p>
                <p>更新前： </p>
                <ul>
                  <li>componentWillReceiveProps接收到一个新的props时，在重新render之前调用</li>
                  <li>shouldComponentUpdate 接收到一个新的state或者props时，在重新render之前调用</li>
                  <li>componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用</li>
                </ul>
                <p>更新后：</p>
                <ul>
                  <li>componentDidUpdate 组件完成更新之后调用</li>
                </ul>
                <p>销毁前： </p>
                <ul>
                  <li>componentWillUnmount</li>
                </ul>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/06/15/react入门级基础知识（干货）/" data-id="cjajctdqt000f04qtio7dsaef"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/react/">react</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-fetch相关概念" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/06/07/fetch相关概念/" class="article-date">
                <time datetime="2017-06-07T01:49:36.040Z" itemprop="datePublished">2017-06-07</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/js基础/">js基础</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/06/07/fetch相关概念/">DOM新API fetch</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h3>
                <p>&emsp;&emsp;之前刚刚总结了axios的用法，然后就突然发现了fetch这么一个东西，这个既然还是新的BOM标准之一，不得不感叹，前端技术推进真的是快，连ajax都要被取代了吗
                  <br>&emsp;&emsp;fetch是定义在BOM标准中window上得一个功能集，它的目的在于取代现有的XMLHttpRequest。w3c认为XMLHttpRequest比较杂乱、异步请求是基于事件模型的，相比Promise和asyns/await来说不够友好、不符合长期以爱w3c关注分离的原则。因此，w3c发布了fecth标准，用来取代旧有的ajax。
                  <br>&emsp;&emsp;其实浏览器请求天生就是异步操作，长久以来，一直都在致力于简化、规范化这个过程。jQuery的ajax方法，es6的Promise，es7的asyns/await、以及大量的前端框架，像angular-resource，axios等等。
                  <br>&emsp;&emsp;但是w3c这个行为像是在搞事呀，ECMA组织发布了es6、es7中都包含有异步操作的内容，也都很强大，它在promise的基础上封装一个fetch出来有些瞎操心。不过从另一个角度来说，ajax以前也是w3c负责发布的标准，做这个改进也合情合理，但是fech像替换掉ajax甚至jquery的ajax，我并不看好。</p>
                <h3 id="fetch-API">
                  <a href="#fetch-API" class="headerlink" title="fetch API"></a>fetch API</h3>
                <p>fetch的API主要体现在它的接口实现上，分为以下几个接口，GolbalFetch、Body、Request、Response、Headers，其他的接口暂时不准备学习。</p>
                <h5 id="GolbalFetch">
                  <a href="#GolbalFetch" class="headerlink" title="GolbalFetch"></a>GolbalFetch</h5>
                <p>这个接口提供了fetch（）方法，window实现了这个接口，因此可以直接使用window.fetch()来请求资源，fetch()接受一个Request接口对象，或者一个URL。
                </p>
                <pre><code>var URL = &apos;https://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=your_api_key&amp;format=json&amp;nojsoncallback=1&amp;tags=penguins&apos;;
function fetchDemo() {
    fetch(URL).then(function(response) {
        return response.json();
    }).then(function(json) {
        insertPhotos(json);
    });
} 
fetchDemo();
</code></pre>
                <h5 id="Request">
                  <a href="#Request" class="headerlink" title="Request"></a>Request</h5>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/06/07/fetch相关概念/" data-id="cjajctdqn000704qtf725eh2g"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/js基础/">js基础</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-javascript数据类型" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/06/05/javascript数据类型/" class="article-date">
                <time datetime="2017-06-05T09:07:30.999Z" itemprop="datePublished">2017-06-05</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/js基础/">js基础</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/06/05/javascript数据类型/">JS typeof总结---6种数据类型</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h3>
                <p>&emsp;为什么要写这个东西？因为typeof总是返回一些乱七八糟的词啊，各种基本数据类型莫名其妙的相等！不总结一下不行了？那么，typeof究竟会返回哪些值呢？
                  <br>js有5种基本类型Undefined、Null、Boolean、String、Number，一种复杂类型Object，函数本质是一个对象，但是函数由于它在js中的特殊性，也需要从其他对象中被区分出来function，因此，typeof会返回7种值。</p>
                <h3 id="js五种基本数据类型">
                  <a href="#js五种基本数据类型" class="headerlink" title="js五种基本数据类型"></a>js五种基本数据类型</h3>
                <p>js有5种基本数据类型undefined、null、boolean、string、number，下面一一说明: </p>
                <h4 id="1、Undefined">
                  <a href="#1、Undefined" class="headerlink" title="1、Undefined"></a>1、Undefined</h4>
                <p>Undefined作为基本类型的意义，意如其名，未定义,Undefined作为变量的基本类型，是针对变量来说的，因此默认变量已经存在。
                  </p>
                <h5 id="在ECMAScript里，Undefiend只有一个值，即特殊的undefiend">
                  <a href="#在ECMAScript里，Undefiend只有一个值，即特殊的undefiend" class="headerlink" title="在ECMAScript里，Undefiend只有一个值，即特殊的undefiend"></a>在ECMAScript里，Undefiend只有一个值，即特殊的undefiend</h5>
                <h5 id="在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量">
                  <a href="#在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量" class="headerlink" title="在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量"></a>在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量</h5>
                <pre><code>var a;
a == undefined// true
typeof a//&apos;undefined&apos;
</code></pre>
                <p>我们考虑的是：什么样的变量 typeof会返回‘undefined’
                  <br>按照上面的定义，未初始化的变量会返回undefined；还有一种特殊情况也会返回undefined，那就是未声明变量 </p>
                <pre><code>typeof b//&apos;undefined&apos;
b == &apos;undefined&apos; // 会报错
</code></pre>
                <p>这里我们要分清楚三个概念:</p>
                <ul>
                  <li>变量是否已定义</li>
                  <li>变量类型</li>
                  <li>变量的值 </li>
                </ul>
                <p>再结合typeof就不难理解为什么只有未初始化的变量值为undefined，而未定义和未初始化的变量数据类型都为Undefined。未定义的变量本来就不存在，把他归为Undefined变量只是为了更好的区分。</p>
                <h5 id="因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在">
                  <a href="#因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在" class="headerlink" title="因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在"></a>因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在</h5>
                <h4 id="2、Null">
                  <a href="#2、Null" class="headerlink" title="2、Null"></a>2、Null</h4>
                <p>&emsp;Null和Undefined类似，表示为空，但是在js里，为空是什么意思呢？ </p>
                <h5 id="在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针">
                  <a href="#在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针" class="headerlink"
                                                                                                  title="在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针"></a>在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针</h5>
                <pre><code>var a = null;
typeof a //&apos;object&apos;
typeof null // &apos;object&apos;
</code></pre>
                <p>也就是说null表示一个没有指向的对象指针，这样我们就可以理解了。</p>
                <p>这样看来，null和undefined其实并没有太大的区别，赋值一个空的对象指针null和赋值一个undefined，看起来没有区别，而且实际上
                  </p>
                <pre><code>null == undefined// true
undefined == null//true
</code></pre>
                <p>更过分的是： </p>
                <pre><code>var a = null;
a == undefined // true
var b;
b == undefined // true
//这个最过分
a == b //true，竟然是true，但是也引发出了一个大的猜想：在变量还没有被赋予实际值的时候，所有变量的值都是一样的，不一样的只有类型
</code></pre>
                <p>这两个值还真的是相等的，每次看到这里肯定就已经绕进去了。。。。这两个基本属性在搞什么呀，乱七八糟，莫名其妙。
                  <br>非要总结一下规则的话,可以说，这两种基本类型是一样的，一样的值；Undefined和Null就像两条线，两条一模一样的线，但是他们依然是不同的线。
                  <br>他们的不同就在于类型的不同，在于意义的不同，undefiend是未初始化的值，null是空的对象指针。
                  <br>ECMAScript引入这个undefined的最主要目的就是为了与空对象指针null做区分</p>
                <h4 id="3、Boolean">
                  <a href="#3、Boolean" class="headerlink" title="3、Boolean"></a>3、Boolean</h4>
                <p>&emsp;Boolean是ECMAScript中的布尔类型，有两个值：true和false，并且，这两个值区分大小写
                  <br>Boolean()可以转换其他类型为Boolean类型，在进行if（）判断时，就是默认调用了Boolean（）方法。 </p>
                <ul>
                  <li>数据类型 true false</li>
                  <li>Boolean true false</li>
                  <li>Strung 非空字符串 空字符串</li>
                  <li>Number 任何非0数字（包括无穷大） 0和NaN</li>
                  <li>Object 任何Object null、</li>
                  <li>Undefined 不试用 undefined</li>
                </ul>
                <h4 id="4、Number">
                  <a href="#4、Number" class="headerlink" title="4、Number"></a>4、Number</h4>
                <p>ECMAScript是基于IEEE754数值格式的，由于IEEE754的通病，浮点数会有四舍五入的毛病，0.1+0.2并不等于0.3，而是等于0.30000000000000004，所以不要确定浮点数的值。
                  <br>Number可以通过8进制、十进制、十六进制来表示，十进制和往常一样 </p>
                <ul>
                  <li>八进制，首位数字为0,078表示八进制的78,十进制的64，</li>
                  <li>十六进制，首尾字符为0x，0x9表示十六进制的9，A~E表示11~15。</li>
                </ul>
                <p>数值范围上来说，Number有一个上下线，一旦超过了上线就会变成Infinity，超过下线就会变成-Infinity。
                  <br>而一个本来应该返回数值的数结果却没有返回数值，这个时候就会返回NaN，比如0/0就会返回NaN。NaN与任何值都不相等，包括它自身，它只是一个代表意义，表示不是数字。可以用isNaN来判断是否不是数字
                </p>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/06/05/javascript数据类型/" data-id="cjajctdqj000304qtcr9lt2br"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/js/">js</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-axios笔记" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/06/02/axios笔记/" class="article-date">
                <time datetime="2017-06-02T07:59:59.841Z" itemprop="datePublished">2017-06-02</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/HTTP-axios/">-- HTTP -- axios</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/06/02/axios笔记/">axios随笔</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="简介">
                  <a href="#简介" class="headerlink" title="简介"></a>简介</h3>
                <p>&emsp;axios是一个基于es6 Promise的HTTP库，可以在浏览器和nodejs中使用。在vue2之后，官方不在推介vue-resource，然是推介使用axios，作为一个被很多人引用为项目依赖的模块，各方面的性能还是信得过的。在浏览器中发起XMLRequest，在node中发起http请求，在形式上支持Promise异步链式编程，也支持自动转化json，同样还可以做请求拦截和分发。是功能很强大的一个插件</p>
                <h3 id="安装">
                  <a href="#安装" class="headerlink" title="安装"></a>安装</h3>
                <p>&emsp;直接引入官方axios.js或者使用npm安装
                  <br>
                  <code>npm i axios</code>
                </p>
                <h3 id="示例">
                  <a href="#示例" class="headerlink" title="示例"></a>示例</h3>
                <pre><code>//发起一个user请求，参数为给定的ID
axios.get(&apos;/user?ID=1234&apos;)
.then(function(res){
    conole.log(res)
}).catch(function(error){
    console.log(error)
})
//上面的请求也可选择下面的方式来写
axios.get(&apos;/user&apos;,{
    params:{
        ID:12345
    }
})
.then(function(response){
    console.log(response);
})
.catch(function(error){
    console.log(error)
});
</code></pre>
                <h3 id="axios语法">
                  <a href="#axios语法" class="headerlink" title="axios语法"></a>axios语法</h3>
                <h4 id="1-基础用法–发起请求">
                  <a href="#1-基础用法–发起请求" class="headerlink" title="1.基础用法–发起请求"></a>1.基础用法–发起请求</h4>
                <pre><code>axios(config).then().catch();
</code></pre>
                <p>&emsp;config的配置如下 </p>
                <pre><code>config = {
    method: &apos;get/post/put/delete...&apos;,
    url: &apos;/api/dsdsd/dsd&apos;,
    data: {

    },
    responseType: &apos;strean/json/string/...&apos;
}
//发起一个post请求
axios({
    method:&apos;post&apos;,//方法
    url:&apos;/user/12345&apos;,//地址
    data:{//参数
        firstName:&apos;Fred&apos;,
        lastName:&apos;Flintstone&apos;
    }
});
</code></pre>
                <h4 id="2-请求方法的重命名">
                  <a href="#2-请求方法的重命名" class="headerlink" title="2.请求方法的重命名"></a>2.请求方法的重命名</h4>
                <p>&emsp;根据axios(config)，来重命名一批方法。</p>
                <pre><code>//请求配置外置化
axios.request(config)
axios.get(url[,config])
axios.delete(url[,config])
axios.head(url[,config])
axios.options(url[,config])
axios.post(url[,data[,config]])
axios.put(url[,data[,config]])
axios.patch(url[,data[,config]])
</code></pre>
                <p>config中的url、data、method会被重命名方法中的参数替换掉</p>
                <h4 id="3-创建axios实例">
                  <a href="#3-创建axios实例" class="headerlink" title="3.创建axios实例"></a>3.创建axios实例</h4>
                <pre><code>axios.create(config)
</code></pre>
                <p>创建实例的意义在于预定义一些参数值，那么采用这个实例来发起请求，这些参数就会默认载入。</p>
                <pre><code>//创建一个axios实例
var instance = axios.create({
    baseURL:&apos;http://some-domain.com/api/&apos;,
    timeout:1000,
    headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;}
});
//使用实例来发起请求
instance.get(&apos;/api/user/123&apos;);
</code></pre>
                <p>同axios本身一样，实例也有方法重命名 </p>
                <pre><code>instance.request(config)
instance.get(url[,config])
instance.delete(url[,config])
instance.head(url[,config])
instance.options(url[,config])
instance.post(url[,data[,config]])
instance.put(url[,data[,config]])
instance.patch(url[,data[,config]])
</code></pre>
                <h4 id="4-请求参数配置全局信息">
                  <a href="#4-请求参数配置全局信息" class="headerlink" title="4.请求参数配置全局信息"></a>4.请求参数配置全局信息</h4>
                <div style="height: 500px;overflow-y: scroll;">
                  <br>
                  <br> {
                  <br> //
                  <code>url</code>是服务器链接，用来请求
                  <br> url:’/user’,
                  <br>
                  <br> //
                  <code>method</code>是发起请求时的请求方法
                  <br> method:
                  <code>get</code>,
                  <br>
                  <br> //
                  <code>baseURL</code>如果
                  <code>url</code>不是绝对地址，那么将会加在其前面。
                  <br> //当axios使用相对地址时这个设置非常方便
                  <br> //在其实例中的方法
                  <br> baseURL:’
                  <a href="http://some-domain.com/api/" target="_blank" rel="external">http://some-domain.com/api/</a>‘,
                  <br>
                  <br> //
                  <code>transformRequest</code>允许请求的数据在传到服务器之前进行转化。
                  <br> //这个只适用于
                  <code>PUT</code>,
                  <code>GET</code>,
                  <code>PATCH</code>方法。
                  <br> //数组中的最后一个函数必须返回一个字符串或者一个
                  <code>ArrayBuffer</code>,或者
                  <code>Stream</code>,
                  <code>Buffer</code>实例,
                  <code>ArrayBuffer</code>,
                  <code>FormData</code>
                  <br> transformRequest:[function(data){
                  <br> //依自己的需求对请求数据进行处理
                  <br> return data;
                  <br> }],
                  <br>
                  <br> //
                  <code>transformResponse</code>允许返回的数据传入then/catch之前进行处理
                  <br> transformResponse:[function(data){
                  <br> //依需要对数据进行处理
                  <br> return data;
                  <br> }],
                  <br>
                  <br> //
                  <code>headers</code>是自定义的要被发送的头信息
                  <br> headers:{‘X-Requested-with’:’XMLHttpRequest’},
                  <br>
                  <br> //
                  <code>params</code>是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象
                  <br> params:{
                  <br> ID:12345
                  <br> },
                  <br>
                  <br> //
                  <code>paramsSerializer</code>是一个可选的函数，是用来序列化参数
                  <br> //例如：（
                  <a href="https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/" target="_blank"
                                                                                                  rel="external">https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/</a>)
                  <br> paramsSerializer: function(params){
                  <br> return Qs.stringify(params,{arrayFormat:’brackets’})
                  <br> },
                  <br>
                  <br> //
                  <code>data</code>是请求提需要设置的数据
                  <br> //只适用于应用的’PUT’,’POST’,’PATCH’，请求方法
                  <br> //当没有设置
                  <code>transformRequest</code>时，必须是以下其中之一的类型（不可重复？）：
                  <br> //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams
                  <br> //-仅浏览器：FormData,File,Blob
                  <br> //-仅Node：Stream
                  <br> data:{
                  <br> firstName:’fred’
                  <br> },
                  <br> //
                  <code>timeout</code>定义请求的时间，单位是毫秒。
                  <br> //如果请求的时间超过这个设定时间，请求将会停止。
                  <br> timeout:1000,
                  <br>
                  <br> //
                  <code>withCredentials</code>表明是否跨网站访问协议，
                  <br> //应该使用证书
                  <br> withCredentials:false //默认值
                  <br>
                  <br> //
                  <code>adapter</code>适配器，允许自定义处理请求，这会使测试更简单。
                  <br> //返回一个promise，并且提供验证返回（查看
                  <a href="#response-api">response docs</a>）
                  <br> adapter:function(config){
                  <br> /
                  <em>…</em>/
                  <br> },
                  <br>
                  <br> //
                  <code>auth</code>表明HTTP基础的认证应该被使用，并且提供证书。
                  <br> //这个会设置一个
                  <code>authorization</code> 头（header），并且覆盖你在header设置的Authorization头信息。
                  <br> auth:{
                  <br> username:’janedoe’,
                  <br> password:’s00pers3cret’
                  <br> },
                  <br>
                  <br> //
                  <code>responsetype</code>表明服务器返回的数据类型，这些类型的设置应该是
                  <br> //‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’
                  <br> responsetype:’json’,
                  <br>
                  <br> //
                  <code>xsrfHeaderName</code> 是http头（header）的名字，并且该头携带xsrf的值
                  <br> xrsfHeadername:’X-XSRF-TOKEN’，//默认值
                  <br>
                  <br> //
                  <code>onUploadProgress</code>允许处理上传过程的事件
                  <br> onUploadProgress: function(progressEvent){
                  <br> //本地过程事件发生时想做的事
                  <br> },
                  <br>
                  <br> //
                  <code>onDownloadProgress</code>允许处理下载过程的事件
                  <br> onDownloadProgress: function(progressEvent){
                  <br> //下载过程中想做的事
                  <br> },
                  <br>
                  <br> //
                  <code>maxContentLength</code> 定义http返回内容的最大容量
                  <br> maxContentLength: 2000,
                  <br>
                  <br> //
                  <code>validateStatus</code> 定义promise的resolve和reject。
                  <br> //http返回状态码，如果
                  <code>validateStatus</code>返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。
                  <br> validateStatus: function(status){
                  <br> return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认
                  <br> },
                  <br>
                  <br> //
                  <code>httpAgent</code> 和
                  <code>httpsAgent</code>当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。
                  <br> //这个允许设置一些选选个，像是
                  <code>keepAlive</code>–这个在默认中是没有开启的。
                  <br> httpAgent: new http.Agent({keepAlive:treu}),
                  <br> httpsAgent: new https.Agent({keepAlive:true}),
                  <br>
                  <br> //
                  <code>proxy</code>定义服务器的主机名字和端口号。
                  <br> //
                  <code>auth</code>表明HTTP基本认证应该跟
                  <code>proxy</code>相连接，并且提供证书。
                  <br> //这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。
                  <br> proxy:{
                  <br> host:127.0.0.1,
                  <br> port:9000,
                  <br> auth:{
                  <br> username:’cdd’,
                  <br> password:’123456’
                  <br> }
                  <br> },
                  <br>
                  <br> //
                  <code>cancelTaken</code> 定义一个取消，能够用来取消请求
                  <br> //（查看 下面的Cancellation 的详细部分）
                  <br> cancelToken: new CancelToken(function(cancel){
                  <br> })
                  <br> }
                  <br>
                </div>

                <h4 id="5-返回对象response包含对象">
                  <a href="#5-返回对象response包含对象" class="headerlink" title="5.返回对象response包含对象"></a>5.返回对象response包含对象</h4>
                <p>response包含以下5个对象： </p>
                <ol>
                  <li>data：{}：服务器返回的数据</li>
                  <li>status: 200 服务器返回的http状态码</li>
                  <li>statusText： ‘ok’ 服务器返回的状态信息</li>
                  <li>header:{} : 服务器返回头信息</li>
                  <li>config：{} axiox的请求配置信息</li>
                </ol>
                <h4 id="6-默认配置">
                  <a href="#6-默认配置" class="headerlink" title="6.默认配置"></a>6.默认配置</h4>
                <p>可以给axios或者axios的实例设置默认配置，axios中有三种配置信息：</p>
                <ol>
                  <li>默认配置，在模块的lib/defaults.js中的默认配置</li>
                  <li>其次是自定义的默认属性</li>
                  <li>最后是请求中的config配置</li>
                </ol>
                <p>在定义实例的时候会在默认配置文件中创建一份临时数据，实例被销毁的时候，也销毁临时配置数据。</p>
                <p>自定义默认数据的方式如下： </p>
                <pre><code>instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;
</code></pre>
                <h4 id="7-配置拦截器">
                  <a href="#7-配置拦截器" class="headerlink" title="7.配置拦截器"></a>7.配置拦截器</h4>
                <p>axios支持配置两种拦截器：拦截请求、拦截响应
                  <br>拦截请求：</p>
                <pre><code>axios.interceptors.request.use(function(config){
    //在请求之前做的一些事
},function(error){
    //在请求错误之前做的一些事
    return Promise.reject(error)
})
</code></pre>
                <p>拦截响应： </p>
                <pre><code>//添加一个返回拦截器
axios.interceptors.response.use(function(response){
    //对返回的数据进行一些处理
    return response;
},function(error){
    //对返回的错误进行一些处理
    return Promise.reject(error);
});
</code></pre>
                <p>取消拦截器需要使用eject函数</p>
                <pre><code>axios.interceptors.request.eject(&apos;拦截器名称&apos;)
</code></pre>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/06/02/axios笔记/" data-id="cjajctdqf000104qtp0hs1xk6"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/axios/">axios</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <article id="post-无标题Markdown" class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-meta">
              <a href="/2017/06/01/无标题Markdown/" class="article-date">
                <time datetime="2017-06-01T08:45:42.000Z" itemprop="datePublished">2017-06-01</time>
              </a>

              <div class="article-category">
                <a class="article-category-link" href="/categories/个人总结/">个人总结</a>
              </div>

            </div>
            <div class="article-inner">

              <header class="article-header">
                <h1 itemprop="name">
                  <a class="article-title" href="/2017/06/01/无标题Markdown/">个人总结</a>
                </h1>

              </header>

              <div class="article-entry" itemprop="articleBody">

                <h3 id="前言">
                  <a href="#前言" class="headerlink" title="前言"></a>前言</h3>
                <p>最近领导和我聊了很多关于个人发展，关于职业规划方面的东西，对我确实有一些触动，也实实在在的点醒了我.</p>
                <h3 id="个人问题">
                  <a href="#个人问题" class="headerlink" title="个人问题"></a>个人问题</h3>
                <p>长久以来，我深航都存在基础不稳的问题，大学阶段的浑浑噩噩，工作以后填填补补。靠着java找到的工作，但是自己却基本还是停留在对简单的框架使用，java基础没有好好总结过，spring也没有完全的好好看一遍，数据库sql更是不行，在后台开发这一块水得一塔糊涂.</p>
                <p>这或许就是我谋求前端的原因之一吧，在前端技术的学习上我确实下了功夫，但是缺点也很明显，重心太多偏向js。</p>
                <p>或许也是因为js是我技术的启蒙吧，大学阶段那么多的实习，从第一次读写文件MFC展示实习失败开始就一直没正真入门，但是js接纳了我，我第一次聚精会神写一份代码，站在图书馆一呆一天也是因为js。工作以后第一次的任务也是一份js编程的工作，DAP4，借助esayui我使用js完成了一个项目，当时的代码我都保留了起来，虽然现在看起来已经难以入目了，但是这引领了我进入了编程的世界。</p>
                <p>后端java的缺点在于基础不扎实，代码都写过了，但是却不明白代码的运行规则。</p>
                <p>前端的问题有两部分，基础上，对于js的编程自己还算满意，但是对于css和html标签的掌握不够。框架上，我只熟悉常用的框架，vue，react，webpack，scss，node，express，我只具备基础架构能力，自己也不能判断我是否具有框架的全局把控力。缺乏经验，大量缺乏经验，其实我也算是参与了三个成熟软件产品的研发，但是没有做到业务积累，没有培养自己的建模能力。很失败的一件事情，大学出来以后全部重心都放置在填补以前的空缺上了，没有对参与的项目进行非技术总结，没有细分业务需求的形成。</p>
                <h3 id="想法">
                  <a href="#想法" class="headerlink" title="想法"></a>想法</h3>
                <p>面对基础的缺失，依然只能通过技术积累，通过看学习来积累，面对眼界，思维方式的缺失，却要自己多想多钻研。</p>
                <ol>
                  <li>多看文档博客，一点点补充缺失，特别是新特性，java8，css3，es6.</li>
                  <li>全方面理解web应用开发架构，明白每个模块，每个阶段用到了哪些技术，选取其中最流行最优秀的一个进行研究学习。</li>
                  <li>
                    <p>在真正理解了系统架构的基础上理解业务需求，加强建模能力。</p>
                    <p>路漫漫其修远兮，吾将上下而求索。</p>
                  </li>
                </ol>

              </div>
              <footer class="article-footer">
                <a data-url="https://peacecup.github.io/2017/06/01/无标题Markdown/" data-id="cjajctdqy000o04qtlauhpp53"
                                                                                                class="article-share-link">Delen</a>

                <ul class="article-tag-list">
                  <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/总结/">总结</a>
                  </li>
                </ul>

              </footer>
            </div>

          </article>

          <nav id="page-nav">
            <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a>
            <a class="page-number" href="/">1</a>
            <a class="page-number" href="/page/2/">2</a>
            <span class="page-number current">3</span>
            <a class="page-number" href="/page/4/">4</a>
            <a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
          </nav>
        </section>

        <aside id="sidebar">

          <div class="widget-wrap">
            <h3 class="widget-title">Categorieën</h3>
            <div class="widget">
              <ul class="category-list">
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/HTTP-axios/">-- HTTP -- axios</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/es6总结/">es6总结</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/es6知识梳理/">es6知识梳理</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/github/">github</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/javascript/">javascript</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/js基础/">js基础</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/markDown/">markDown</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/react/">react</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/个人总结/">个人总结</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/前端问题梳理/">前端问题梳理</a>
                </li>
                <li class="category-list-item">
                  <a class="category-list-link" href="/categories/框架整理/">框架整理</a>
                </li>
              </ul>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Labels</h3>
            <div class="widget">
              <ul class="tag-list">
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/axios/">axios</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/es6/">es6</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/express/">express</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/github/">github</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/javascript/">javascript</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/js/">js</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/js基础/">js基础</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/lowdb/">lowdb</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/markDown/">markDown</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/moment/">moment</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/react/">react</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/vue/">vue</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/webpack/">webpack</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/前端/">前端</a>
                </li>
                <li class="tag-list-item">
                  <a class="tag-list-link" href="/tags/总结/">总结</a>
                </li>
              </ul>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Tag Cloud</h3>
            <div class="widget tagcloud">
              <a href="/tags/axios/" style="font-size: 10px;">axios</a>
              <a href="/tags/es6/" style="font-size: 16.67px;">es6</a>
              <a href="/tags/express/" style="font-size: 10px;">express</a>
              <a href="/tags/github/" style="font-size: 10px;">github</a>
              <a href="/tags/javascript/" style="font-size: 13.33px;">javascript</a>
              <a href="/tags/js/" style="font-size: 10px;">js</a>
              <a href="/tags/js基础/" style="font-size: 10px;">js基础</a>
              <a href="/tags/lowdb/" style="font-size: 10px;">lowdb</a>
              <a href="/tags/markDown/" style="font-size: 10px;">markDown</a>
              <a href="/tags/moment/" style="font-size: 10px;">moment</a>
              <a href="/tags/react/" style="font-size: 10px;">react</a>
              <a href="/tags/vue/" style="font-size: 10px;">vue</a>
              <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
              <a href="/tags/前端/" style="font-size: 20px;">前端</a>
              <a href="/tags/总结/" style="font-size: 10px;">总结</a>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Archieven</h3>
            <div class="widget">
              <ul class="archive-list">
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/11/">November 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/08/">August 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/07/">July 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/06/">June 2017</a>
                </li>
                <li class="archive-list-item">
                  <a class="archive-list-link" href="/archives/2017/05/">May 2017</a>
                </li>
              </ul>
            </div>
          </div>

          <div class="widget-wrap">
            <h3 class="widget-title">Recente berichten</h3>
            <div class="widget">
              <ul>

                <li>
                  <a href="/2017/11/28/框架整理/框架整理（三）--mian入口文件/">万达监控预警项目前端框架整理（三）----项目入口文件</a>
                </li>

                <li>
                  <a href="/2017/11/28/框架整理/万达预警监控项目前端框架整理（二）/">前端框架（二）</a>
                </li>

                <li>
                  <a href="/2017/11/27/框架整理/万达预警监控项目前端框架整理（-）/">前端框架（一）</a>
                </li>

                <li>
                  <a href="/2017/11/27/vue源码学习/数据监控/">(no title)</a>
                </li>

                <li>
                  <a href="/2017/08/11/problems/事件委托、jq事件委托/">(no title)</a>
                </li>

              </ul>
            </div>
          </div>

        </aside>

      </div>
      <footer id="footer">

        <div class="outer">
          <div id="footer-info" class="inner">
            &copy; 2017 陈宁
            <br> Powered by
            <a href="http://hexo.io/" target="_blank">Hexo</a>
          </div>
        </div>
      </footer>

    </div>
    <nav id="mobile-nav">

      <a href="/" class="mobile-nav-link">Home</a>

      <a href="/archives" class="mobile-nav-link">Archives</a>

    </nav>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js">


    </script>

    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
    <script src="/fancybox/jquery.fancybox.pack.js"></script>

    <script src="/js/script.js"></script>

  </div>
</body>

</html>
