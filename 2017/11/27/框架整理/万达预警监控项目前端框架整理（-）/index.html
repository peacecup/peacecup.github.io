<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="X-UA-Compatible" content="IE=edge">
  <meta name="author" content="陈宁">
  <title>前端框架（一）“ · 长夜</title>
  <meta name="description" content="万达监控预警项目前端框架整理">
  <meta name="keywords">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
                                                                                  name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="renderer" content="webkit">
  <link rel="short icon" href="/images/favicon.png" type="image/x-icon">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/blog_basic.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml">
</head>

<body>
  <div class="sidebar animated fadeInDown">
    <div class="logo-title">
      <div class="title">
        <img src="/images/logo@2x.png" style="width:127px;">
        <h3 title="">
          <a href="/">长夜</a>
        </h3>
        <div class="description">
          <p>打开新世界的大门</p>
        </div>
      </div>
    </div>
    <ul class="social-links"></ul>
    <div class="footer">
      <a target="_blank" href="/">
        <span>Theme by </span>
      </a>
      <a href="https://www.caicai.me"> CaiCai </a>
      <span>&</span>
      <a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a>
      <div class="by_farbox">
        <a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a>
      </div>
    </div>
  </div>
  <div class="main">
    <div class="page-top animated fadeInDown">
      <div class="nav">
        <li>
          <a href="/">首页</a>
        </li>
        <li>
          <a href="/about">关于</a>
        </li>
        <li>
          <a href="/categories">分类</a>
        </li>
        <li>
          <a href="/archives" class="current">归档</a>
        </li>
        <li>
          <a href="/tags">标签</a>
        </li>
        <li>
          <a href="/links">友链</a>
        </li>
      </div>
      <div class="information">
        <div class="back_btn">
          <li>
            <a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a>
          </li>
        </div>
        <div class="avatar">
          <img>
        </div>
      </div>
    </div>
    <div class="autopagerize_page_element">
      <div class="content">
        <div class="post-page">
          <div class="post animated fadeInDown">
            <div class="post-title">
              <h3>
                <a>前端框架（一）“</a>
              </h3>
            </div>
            <div class="post-content">
              <h3 id="項目介紹">
                <a href="#項目介紹" class="headerlink" title="項目介紹"></a>項目介紹</h3>
              <p>这个项目由美国一监控公司的产品pagerduty定制而来，原版的pagerduty已经不能很好的兼容万达金融内部的所有系统，因此选择开发这一套新的pagerduty来满足内需。</p>
              <p>项目架构采用传统的中途岛模式，前后端分离，前端采用webpack+vue为核心技术栈，后端采用springboot+微服务+feiclient来实现，数据库使用Mysql5.6。</p>
              <h3 id="前端架构">
                <a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3>
              <p>第一版架构使用react完成，采用react+webpack+redux+soga完成，由于万达要求，技术栈改为以vue为主，下面就vue为主的前端架构做总结：</p>
              <h4 id="webpack基础配置">
                <a href="#webpack基础配置" class="headerlink" title="webpack基础配置"></a>webpack基础配置</h4>
              <pre><code>/* webpack.base.config.js    基础配置*/

const path = require(&apos;path&apos;);
const webpack = require(&apos;webpack&apos;);
const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

module.exports = {
    entry: {
        main: &apos;./src/main&apos;,
        vendors: &apos;./src/vendors&apos;
    },
    output: {
        path: path.join(__dirname, &apos;../dist&apos;)
    },
    module: {
        rules: [{
                test: /\.vue$/,
                loader: &apos;vue-loader&apos;,
                options: {
                    loaders: {
                        less: .ExtractTextPluginextract({
                            use: [&apos;css-loader?minimize&apos;,    &apos;autoprefixer-loader&apos;, &apos;less-loader&apos;],
                            fallback: &apos;vue-style-loader&apos;
                        }),
                        css: ExtractTextPlugin.extract({
                            use: [&apos;css-loader&apos;, &apos;autoprefixer-loader&apos;],
                            fallback: &apos;vue-style-loader&apos;
                        })
                    }
                }
            },
            {
                test: /iview\/.*?js$/,
                loader: &apos;babel-loader&apos;
            },
            {
                test: /\.js$/,
                loader: &apos;babel-loader&apos;,
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                use: ExtractTextPlugin.extract({
                    use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;],
                    fallback: &apos;style-loader&apos;
                })
            },
            {
                test: /\.less/,
                use: ExtractTextPlugin.extract({
                    use: [&apos;autoprefixer-loader&apos;, &apos;less-loader&apos;],
                    fallback: &apos;style-loader&apos;
                })
            },
            {
                test: /\.(gif|jpg|png)\??.*$/,
                loader: &apos;file-loader&apos;,
                options: {
                    name: &apos;/assets/img/[hash].[ext]&apos;,
                }
            },
            {
                test: /\.(html|tpl)$/,
                loader: &apos;html-loader&apos;
            }
        ]
    },
    resolve: {
        extensions: [&apos;.js&apos;, &apos;.vue&apos;],
        alias: {
            &apos;vue&apos;: &apos;vue/dist/vue.esm.js&apos;,
            &apos;@pages&apos;: path.join(__dirname, &apos;../src/components/pages&apos;),
            &apos;@common&apos;: path.join(__dirname, &apos;../src/components/common&apos;),
            &apos;@util&apos;: path.join(__dirname, &apos;../src/libs&apos;),
        }
    }
};
</code></pre>
              <p>本地环境配置：</p>
              <pre><code>/*webpack.dev.config.js*/

const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);
const merge = require(&apos;webpack-merge&apos;);
const webpackBaseConfig = require(&apos;./webpack.base.config.js&apos;);
const fs = require(&apos;fs&apos;);
const autoMergeJs = require(&apos;../scripts/autoMergeJs&apos;);
const path = require(&apos;path&apos;);   
// fs.open(&apos;../src/config/env.js&apos;, &apos;w&apos;, function(err, fd) {
//     const buf = &apos;export default &quot;development&quot;;&apos;;
//     fs.write(fd, buf, 0, buf.length, 0, function(err, written, buffer) {});
// });
module.exports = merge(webpackBaseConfig, {
    devtool: &apos;#source-map&apos;,
    output: {
        publicPath: &apos;/dist/&apos;,
        filename: &apos;[name].js&apos;,
        chunkFilename: &apos;[name].chunk.js&apos;
    },
    module: {
        rules: [
            {
                test: /\.(woff|svg|eot|ttf)\??.*$/,
                loader: &apos;url-loader?limit=2048&apos;
            },
        ]
    },
    plugins: [
        new autoMergeJs(),
        new ExtractTextPlugin({
            filename: &apos;[name].css&apos;,
            allChunks: true
        }),
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;vendors&apos;,
            filename: &apos;vendors.js&apos;
        }),
        new HtmlWebpackPlugin({
            title:&apos;Hedwig&apos;,
            filename: &apos;./index.html&apos;,
            template: &apos;./src/template/index.ejs&apos;,
            favicon: path.resolve(&apos;/assets/favicon.ico&apos;),
            inject: false
        })
    ]
});
</code></pre>
              <p>在基础配置里采用了重复第三方模块的统一打包：多入口vendors、ExtractTextPluging插件、HtmlWebpackPlugin、自定义webpack插件</p>
              <h5 id="多入口">
                <a href="#多入口" class="headerlink" title="多入口"></a>多入口</h5>
              <p>由于将所有模块打包到一起之后文件的大小会以M记，对于一次文件请求来说太大，一般来说，会将同一功能模块的文件打包在一起，以多入口的方式利用CommonChunkPulgin来处理成单独的“&lt;
                script&gt;”标签进行插入。
                <br>进行多入口打包的规则总结如下： </p>
              <ol>
                <li>打包粒度要合适，每一个模块的大小最好不要超过500kb</li>
                <li>打包数目不要超过浏览器并发请求资源数，ie一般为4个，chrome一般为6个，多了就会导致请求
                  <br>卡顿</li>
                <li>利用留浏览器304缓存，公共部分代码应该都为静态资源</li>
                <li>在打包上应该避免将层次较深的资源打包到入口中，应该做懒加载。</li>
              </ol>
              <p>具体项目中表现如下： </p>
              <ol>
                <li>第三方共用的库打一个包，比如vue全家桶</li>
                <li>公共组件打一个包，比如弹窗组件、loading组件</li>
                <li>项目通用的工具类打一个包</li>
                <li>一个大的功能模块打一个包，一般而言，项目不会大到这种地步</li>
                <li>每个功能模块的子页面进行异步加载。</li>
              </ol>
              <p>本项目中，由于项目体积不大，所以只多出了一个第三方公共模块vendors，入口文件中配置了vendors入口： </p>
              <pre><code>import Vue from &apos;vue&apos;;
import iView from &apos;iview&apos;;
import VueRouter from &apos;vue-router&apos;;
import axios from &apos;axios&apos;;
import Vuex from &apos;vuex&apos;;
import echarts from &apos;echarts&apos;;
import Cookies from &apos;js-cookie&apos;;
import clipboard from &apos;clipboard&apos;;
import html2canvas from &apos;html2canvas&apos;;
import rasterizehtml from &apos;rasterizehtml&apos;;
import store from &apos;store&apos;;
</code></pre>
              <p>上面这些第三方模块被打包成vendor，利用CommonsChunkPlugin来处理，代码中有说明。</p>
              <p>CommonsChunkPlugin是webpack插件，用来提取出公共模块进行打包，只在首页加载一次便缓存起来，不会再重复抓取。</p>
              <h5 id="ExtractTextPluging">
                <a href="#ExtractTextPluging" class="headerlink" title="ExtractTextPluging"></a>ExtractTextPluging</h5>
              <p>extract-text-webpack-plugin插件用来从bundle中提取出css作为一个公共的css文件。在webpack的配置文件中引用，在loader中设置额外的提取。
              </p>
              <pre><code>{
            test: /\.vue$/,
            loader: &apos;vue-loader&apos;,
            options: {
                loaders: {
                    less: ExtractTextPlugin.extract({
                        use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;, &apos;less-loader&apos;],
                        fallback: &apos;vue-style-loader&apos;
                    }),
                    css: ExtractTextPlugin.extract({
                        use: [&apos;css-loader&apos;, &apos;autoprefixer-loader&apos;],
                        fallback: &apos;vue-style-loader&apos;
                    })
                }
            }
        }
</code></pre>
              <p>定义use来确实使用什么来解析提取的内容，使用fallback来定义从什么中抽取文件。 </p>
              <h5 id="HtmlWebpackPlugin">
                <a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h5>
              <p>html-webpack-plugin是用来生成HTML文件并且自动引用打包的文件。可以指定模板的位置，可以指定引用文件的位置，可以增加title，增加favicon等等，是一个服务于首页的插件。</p>
              <h5 id="自定义webpack插件">
                <a href="#自定义webpack插件" class="headerlink" title="自定义webpack插件"></a>自定义webpack插件</h5>
              <h6 id="cpmpile和compilation">
                <a href="#cpmpile和compilation" class="headerlink" title="cpmpile和compilation"></a>cpmpile和compilation</h6>
              <p>自定义webpack通常通过重写插件的apply方法，并且将webpack的compile作为参数传递进入方法。compile对象时webpack在编译启动时，将配置文件数据注入后生成的编译对象。
                <br>compilation是在文件发生变动时，webpack的一个代表发生变化的对象，他包含了各种变化的回调</p>
              <pre><code>function HelloWorldPlugin(){
}
HelloWorldPlugin.prototype.apply = function(compile){
    compile.plugin(&quot;emit&quot;,function(compilation,callback){
        //这里做想要的操作，做完以后调用callback（）完成
        callback();
    })
}
</code></pre>
              <h5 id="AutoMerage插件">
                <a href="#AutoMerage插件" class="headerlink" title="AutoMerage插件"></a>AutoMerage插件</h5>
              <p>本项目使用了自定义插件AutoMerage，功能是读取文件目录，自动生成对外导出文件。 </p>
              <pre><code>/**
 * AutoMerage.js
 */

let fs = require(&apos;fs&apos;);
let Handlebars = require(&apos;handlebars&apos;);
let _ = require(&apos;lodash&apos;);
let util = require(&apos;./util&apos;);

function AutoMergeJs(options) {
}
AutoMergeJs.prototype.apply = function (compiler) {
    compiler.plugin(&apos;emit&apos;, function (compilation, callback) {
        function createIndex(src, targetFile) {
            //获取所有目录文件的名建明，除模板相关文件
            let files = util.readFilesInDir(src, {
                prefix: &apos;.&apos;,
                excludeFiles: [&apos;index.vue&apos;, &apos;index.js&apos;, &apos;index.tpl&apos;],
                format: (f) =&gt; f.substring(0, _.lastIndexOf(f, &apos;.&apos;))
            });
            targetFile.forEach(f =&gt; {
                //获取模板文件
                let data = fs.readFileSync(src + &apos;/&apos; + f.template, &apos;utf-8&apos;);
                const template = Handlebars.compile(data);
                //利用目录文件遍历模板生成文件
                let result = template({
                    list: files
                });
                try{
                    //获取原编译结束后的文件
                    let old = fs.readFileSync(src + &apos;/&apos; + f.target, &apos;utf-8&apos;);
                    //如果和源文件不同，则将新的结果写入到文件中
                    if (old !== result)
                        fs.writeFileSync(src + &apos;/&apos; + f.target, result);
                }catch(e){
                    fs.writeFileSync(src + &apos;/&apos; + f.target, result);
                }
            });
        }
        let _targetFile = [{
            template: &apos;index.tpl&apos;,
            target: &apos;index.js&apos;,
        }];
        createIndex(&apos;./src/actions&apos;, _targetFile);
        createIndex(&apos;./src/components/pages&apos;, _targetFile);
        createIndex(&apos;./src/components/common&apos;, _targetFile);
        callback();
    });
};
module.exports = AutoMergeJs;
</code></pre>
              <p>进行模板文本操作的工具类</p>
              <pre><code>/**
 * util.js
 */
var fs = require(&quot;fs&quot;);

//path模块，可以生产相对和绝对路径
var path = require(&quot;path&quot;);
var _ = require(&quot;lodash&quot;);

//读取文件存储数组
function readFilesInDir(dirUrl, option) {
    var fileArr = [];

    var {excludeFiles = []} = option;
    var {format = null} = option;
    var {prefix = &apos;&apos;} = option;

    //excludeFiles中包含file时返回false；
    function exclude(file) {
        return !_.includes(excludeFiles, file);
    }

//获取文件数组
    function readFile(readurl, name) {
        var name = name;
        //同步读取文件目录
        let files = fs.readdirSync(readurl);

        files.forEach(function (filename) {
            //获取文件状态
            let stats = fs.statSync(path.join(readurl, filename));
            //如果是文件且不是index.vue/index.js/index.tpl，这三种文件要过滤掉
            if (stats.isFile() &amp;&amp; exclude(filename)) {
                //options。format存在且是一个函数
                if (!!option.format &amp;&amp; _.isFunction(option.format))
                    //获取文件名
                    filename = option.format(filename);
                var newUrl = name + &apos;/&apos; + filename;  // ./filename
                fileArr.push({name: filename, fullName: newUrl});
                //是子目录则递归处理
            } else if (stats.isDirectory()) {
                var dirName = filename;
                readFile(path.join(readurl, filename), name + &apos;/&apos; + dirName);
            }
        });
    }

    readFile(dirUrl, prefix);
    return _.chain(fileArr).filter(file =&gt; file.name &amp;&amp; file.name !==   &apos;&apos;).sortBy((f) =&gt; f.fullName).value();
}

module.exports = {readFilesInDir: readFilesInDir};
</code></pre>
              <p>这里的几个关键技术是Handlebars、fs、lodash。
                <br>Handlebars是一种模板技术，通过将数据和模板结合，在编译之后就可以自动生成文件。
                <br>index.tpl </p>
              <pre><code>//Do not modify this file, it will be auto generated
import vuexDecorator from &apos;../libs/vuexDecorator&apos;;
{{#list}}
import  {{this.name}} from &apos;{{this.fullName}}&apos;;
{{/list}}

export default {
{{#list}}
    {{this.name}}: vuexDecorator(&apos;{{this.name}}&apos;,{{this.name}}),
{{/list}}
}
</code></pre>
              <p>编译模板： </p>
              <pre><code>//获取模板文件
let data = fs.readFileSync(src + &apos;/&apos; + f.template, &apos;utf-8&apos;);
const template = Handlebars.compile(data);
//利用目录文件遍历模板生成文件
let result = template({
    list: files
});
</code></pre>
              <p>写回文件：</p>
              <pre><code>fs.writeFileSync(src + &apos;/&apos; + f.target, result);
</code></pre>
              <p>在对js使用按照这种方法就可以实现动态配置，减少代码量。</p>
              <p>fs是nodejs内置的模块，可以做文件读写，这里有几个关键的函数：</p>
              <ol>
                <li>fs.readFileSync() 读取文件内容</li>
                <li>fs.writeFileSync() 写入文件</li>
                <li>fs.statSync() 获取文件状态，返回Stats类</li>
                <li>stats.isFile() 是否是文件</li>
                <li>stats.isDirectory() 是否是目录</li>
                <li>fs.readdirSync() 读取文档目录结构</li>
              </ol>
              <p>lodash是和underscore类似的函数式变成的库，提供了大量的实用的方法。</p>
            </div>
            <div class="post-footer">
              <div class="meta">
                <div class="info">
                  <i class="fa fa-sun-o"></i>
                  <span class="date">2017-11-27</span>
                  <i class="fa fa-tag"></i>
                  <a href="/categories/框架整理/" title="框架整理" class="tag">框架整理 </a>
                  <a href="/tags/webpack/" title="webpack" class="tag">webpack </a>
                </div>
              </div>
            </div>
          </div>
          <div class="share">
            <div class="evernote">
              <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();"
                                                                                              ref="nofollow" target="_blank" class="fa fa-bookmark"></a>
            </div>
            <div class="weibo">
              <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"
                                                                                              class="fa fa-weibo"></a>
            </div>
            <div class="twitter">
              <a href="http://twitter.com/home?status=,https://peacecup.github.io/2017/11/27/框架整理/万达预警监控项目前端框架整理（-）/,长夜,前端框架（一）“,;"
                                                                                              class="fa fa-twitter"></a>
            </div>
          </div>
          <div class="pagination">
            <ul class="clearfix">
              <li class="pre pagbuttons">
                <a role="navigation" href="/2017/11/28/框架整理/万达预警监控项目前端框架整理（二）/" title="前端框架（二）"
                                                                                                class="btn">上一篇</a>
              </li>
              <li class="next pagbuttons">
                <a role="navigation" href="/2017/11/27/vue源码学习/数据监控/" title="" class="btn">下一篇</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script src="/js/jquery.js"></script>
  <script src="/js/jquery-migrate-1.2.1.min.js"></script>
  <script src="/js/jquery.appear.js"></script>
</body>

</html>
