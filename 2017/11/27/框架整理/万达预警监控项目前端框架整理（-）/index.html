<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->

<head>
  <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=https://peacecup.github.io/warn.html">
<![endif]-->
  <meta charset="utf-8">

  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
  <meta http-equiv="mobile-agent" content="format=html5; url=https://peacecup.github.io">
  <meta name="author" content="陈宁">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/SimpleStyle.min.css">

  <link rel="shortcut icon" href="/images/favicon.png">

  <title>归档集 - 长夜</title>

  <meta name="keywords" content="undefined">

  <meta name="description " content="打开新世界的大门">

</head>

<body>
  <div id="nav">
    <nav class="nav-menu">
      <a class="site-name current" href="/" title="说">说</a>
      <a class="site-index current" href="/">
        <i class="fa fa-home"></i>
        <span>首页</span>
      </a>
      <a href="/archives" title="归档">
        <i class="fa fa-archives"></i>
        <span>归档</span>
      </a>
      <a href="/tags" title="标签">
        <i class="fa fa-tags"></i>
        <span>标签</span>
      </a>
      <!-- custom single page of menus -->

      <a href="/cross_fire" title="穿越火线">
        <i class="fa fa-wifi"></i>
        <span>穿越火线</span>
      </a>

      <a href="/help" title="急救中心">
        <i class="fa fa-question-circle"></i>
        <span>急救中心</span>
      </a>

    </nav>
  </div>

  <div class="nav-user">
    <a class="btn-search" href="#">
      <i class="fa fa-search"></i>
    </a>
    <a class="btn-read-mode" href="#">
      <i class="fa fa-sun-o"></i>
    </a>
    <a class="btn-weixin-mp" href="javascript:">
      <i class="fa fa-weixin"></i>
    </a>
  </div>

  <div id="wrapper" class="clearfix">
    <div id="body">
      <div class="main" id="main">
        <div id="cover">
          <div class="cover-img"></div>
          <div class="cover-info">

            <h1 class="cover-siteName">说IT</h1>
            <h3 class="cover-siteTitle">聊技术，谈情怀</h3>
            <p class="cover-siteDesc">一个关注技术与人文的IT博客</p>
            <div class="cover-sns">

              <div class="btn btn-telegram">
                <a href="http://t.me/codeist" target="_blank" title="telegram" ref="friend">
                  <i class="fa fa-telegram"></i>
                </a>
              </div>

              <div class="btn btn-instagram">
                <a href="https://www.instagram.com/coder.thomas/" target="_blank" title="instagram"
                                                                                                ref="friend">
                  <i class="fa fa-instagram"></i>
                </a>
              </div>

              <div class="btn btn-twitter">
                <a href="https://twitter.com/tangkunyin" target="_blank" title="twitter" ref="friend">
                  <i class="fa fa-twitter"></i>
                </a>
              </div>

              <div class="btn btn-github">
                <a href="https://github.com/tangkunyin" target="_blank" title="github" ref="friend">
                  <i class="fa fa-github"></i>
                </a>
              </div>

            </div>
          </div>
        </div>

        <div class="page-title">
          <ul>
            <li>
              <a href="/">最新</a>
            </li>

            <li class="">
              <a href="/categories/big-front-end" data-name="前端">前端</a>
            </li>

            <li class="">
              <a href="/categories/server-side" data-name="后台">后台</a>
            </li>

            <li class="">
              <a href="/categories/design" data-name="设计">设计</a>
            </li>

            <li class="">
              <a href="/categories/resource" data-name="资源">资源</a>
            </li>

            <li class="page-search">
              <form id="search" class="search-form">
                <label for="s" class="sr-only">请输入关键字</label>
                <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字"
                />
                <button type="submit" class="search-form-submit" title="搜索">
                  <i class="fa fa-search"></i>
                </button>
              </form>
              <div class="ins-search">
                <div class="ins-search-mask"></div>
                <div class="ins-search-container">
                  <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
                    <span class="ins-close ins-selectable">
                      <i class="fa fa-times-circle"></i>
                    </span>
                  </div>
                  <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                  </div>
                </div>
              </div>
              <script>
                (function(window) {
                  var INSIGHT_CONFIG = {
                    TRANSLATION: {
                      POSTS: '文章',
                      PAGES: '页面',
                      CATEGORIES: '分类',
                      TAGS: '标签',
                      UNTITLED: '(无标题)',
                    },
                    ROOT_URL: '/',
                    CONTENT_URL: '/content.json',
                  };
                  window.INSIGHT_CONFIG = INSIGHT_CONFIG;
                })(window);

              </script>

            </li>

          </ul>
        </div>
        <div class="main-inner">
          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
            <div class="post-header">
              <div class="post-author clearfix">
                <a class="avatar fleft" href="undefined" target="_blank">
                  <img width="48" src="undefined" alt="avatar" />
                </a>
                <p>
                  <span class="label">作者</span>
                  <a href="undefined" target="_blank">undefined</a>
                  <span title="最后编辑于2017-11-27">2017-11-27</span>
                </p>
                <p>undefined</p>
              </div>
              <h2 class="post-title">前端框架（一）</h2>
              <div class="post-meta">
                本文总共11891个字 | 您是第
                <span id="busuanzi_value_page_pv">
                  <i class="fa fa-spinner fa-spin"></i>
                </span>位看到它们的小伙伴
              </div>
            </div>
            <div class="post-content markdown-body">
              <h3 id="項目介紹">
                <a href="#項目介紹" class="headerlink" title="項目介紹"></a>項目介紹</h3>
              <p>这个项目由美国一监控公司的产品pagerduty定制而来，原版的pagerduty已经不能很好的兼容万达金融内部的所有系统，因此选择开发这一套新的pagerduty来满足内需。</p>
              <p>项目架构采用传统的中途岛模式，前后端分离，前端采用webpack+vue为核心技术栈，后端采用springboot+微服务+feiclient来实现，数据库使用Mysql5.6。</p>
              <h3 id="前端架构">
                <a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3>
              <p>第一版架构使用react完成，采用react+webpack+redux+soga完成，由于万达要求，技术栈改为以vue为主，下面就vue为主的前端架构做总结：</p>
              <h4 id="webpack基础配置">
                <a href="#webpack基础配置" class="headerlink" title="webpack基础配置"></a>webpack基础配置</h4>
              <pre><code>/* webpack.base.config.js    基础配置*/

const path = require(&apos;path&apos;);
const webpack = require(&apos;webpack&apos;);
const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);

module.exports = {
    entry: {
        main: &apos;./src/main&apos;,
        vendors: &apos;./src/vendors&apos;
    },
    output: {
        path: path.join(__dirname, &apos;../dist&apos;)
    },
    module: {
        rules: [{
                test: /\.vue$/,
                loader: &apos;vue-loader&apos;,
                options: {
                    loaders: {
                        less: .ExtractTextPluginextract({
                            use: [&apos;css-loader?minimize&apos;,    &apos;autoprefixer-loader&apos;, &apos;less-loader&apos;],
                            fallback: &apos;vue-style-loader&apos;
                        }),
                        css: ExtractTextPlugin.extract({
                            use: [&apos;css-loader&apos;, &apos;autoprefixer-loader&apos;],
                            fallback: &apos;vue-style-loader&apos;
                        })
                    }
                }
            },
            {
                test: /iview\/.*?js$/,
                loader: &apos;babel-loader&apos;
            },
            {
                test: /\.js$/,
                loader: &apos;babel-loader&apos;,
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                use: ExtractTextPlugin.extract({
                    use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;],
                    fallback: &apos;style-loader&apos;
                })
            },
            {
                test: /\.less/,
                use: ExtractTextPlugin.extract({
                    use: [&apos;autoprefixer-loader&apos;, &apos;less-loader&apos;],
                    fallback: &apos;style-loader&apos;
                })
            },
            {
                test: /\.(gif|jpg|png)\??.*$/,
                loader: &apos;file-loader&apos;,
                options: {
                    name: &apos;/assets/img/[hash].[ext]&apos;,
                }
            },
            {
                test: /\.(html|tpl)$/,
                loader: &apos;html-loader&apos;
            }
        ]
    },
    resolve: {
        extensions: [&apos;.js&apos;, &apos;.vue&apos;],
        alias: {
            &apos;vue&apos;: &apos;vue/dist/vue.esm.js&apos;,
            &apos;@pages&apos;: path.join(__dirname, &apos;../src/components/pages&apos;),
            &apos;@common&apos;: path.join(__dirname, &apos;../src/components/common&apos;),
            &apos;@util&apos;: path.join(__dirname, &apos;../src/libs&apos;),
        }
    }
};
</code></pre>
              <p>本地环境配置：</p>
              <pre><code>/*webpack.dev.config.js*/

const webpack = require(&apos;webpack&apos;);
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);
const merge = require(&apos;webpack-merge&apos;);
const webpackBaseConfig = require(&apos;./webpack.base.config.js&apos;);
const fs = require(&apos;fs&apos;);
const autoMergeJs = require(&apos;../scripts/autoMergeJs&apos;);
const path = require(&apos;path&apos;);   
// fs.open(&apos;../src/config/env.js&apos;, &apos;w&apos;, function(err, fd) {
//     const buf = &apos;export default &quot;development&quot;;&apos;;
//     fs.write(fd, buf, 0, buf.length, 0, function(err, written, buffer) {});
// });
module.exports = merge(webpackBaseConfig, {
    devtool: &apos;#source-map&apos;,
    output: {
        publicPath: &apos;/dist/&apos;,
        filename: &apos;[name].js&apos;,
        chunkFilename: &apos;[name].chunk.js&apos;
    },
    module: {
        rules: [
            {
                test: /\.(woff|svg|eot|ttf)\??.*$/,
                loader: &apos;url-loader?limit=2048&apos;
            },
        ]
    },
    plugins: [
        new autoMergeJs(),
        new ExtractTextPlugin({
            filename: &apos;[name].css&apos;,
            allChunks: true
        }),
        new webpack.optimize.CommonsChunkPlugin({
            name: &apos;vendors&apos;,
            filename: &apos;vendors.js&apos;
        }),
        new HtmlWebpackPlugin({
            title:&apos;Hedwig&apos;,
            filename: &apos;./index.html&apos;,
            template: &apos;./src/template/index.ejs&apos;,
            favicon: path.resolve(&apos;/assets/favicon.ico&apos;),
            inject: false
        })
    ]
});
</code></pre>
              <p>在基础配置里采用了重复第三方模块的统一打包：多入口vendors、ExtractTextPluging插件、HtmlWebpackPlugin、自定义webpack插件</p>
              <h5 id="多入口">
                <a href="#多入口" class="headerlink" title="多入口"></a>多入口</h5>
              <p>由于将所有模块打包到一起之后文件的大小会以M记，对于一次文件请求来说太大，一般来说，会将同一功能模块的文件打包在一起，以多入口的方式利用CommonChunkPulgin来处理成单独的“&lt;
                script&gt;”标签进行插入。
                <br>进行多入口打包的规则总结如下： </p>
              <ol>
                <li>打包粒度要合适，每一个模块的大小最好不要超过500kb</li>
                <li>打包数目不要超过浏览器并发请求资源数，ie一般为4个，chrome一般为6个，多了就会导致请求
                  <br>卡顿</li>
                <li>利用留浏览器304缓存，公共部分代码应该都为静态资源</li>
                <li>在打包上应该避免将层次较深的资源打包到入口中，应该做懒加载。</li>
              </ol>
              <p>具体项目中表现如下： </p>
              <ol>
                <li>第三方共用的库打一个包，比如vue全家桶</li>
                <li>公共组件打一个包，比如弹窗组件、loading组件</li>
                <li>项目通用的工具类打一个包</li>
                <li>一个大的功能模块打一个包，一般而言，项目不会大到这种地步</li>
                <li>每个功能模块的子页面进行异步加载。</li>
              </ol>
              <p>本项目中，由于项目体积不大，所以只多出了一个第三方公共模块vendors，入口文件中配置了vendors入口： </p>
              <pre><code>import Vue from &apos;vue&apos;;
import iView from &apos;iview&apos;;
import VueRouter from &apos;vue-router&apos;;
import axios from &apos;axios&apos;;
import Vuex from &apos;vuex&apos;;
import echarts from &apos;echarts&apos;;
import Cookies from &apos;js-cookie&apos;;
import clipboard from &apos;clipboard&apos;;
import html2canvas from &apos;html2canvas&apos;;
import rasterizehtml from &apos;rasterizehtml&apos;;
import store from &apos;store&apos;;
</code></pre>
              <p>上面这些第三方模块被打包成vendor，利用CommonsChunkPlugin来处理，代码中有说明。</p>
              <p>CommonsChunkPlugin是webpack插件，用来提取出公共模块进行打包，只在首页加载一次便缓存起来，不会再重复抓取。</p>
              <h5 id="ExtractTextPluging">
                <a href="#ExtractTextPluging" class="headerlink" title="ExtractTextPluging"></a>ExtractTextPluging</h5>
              <p>extract-text-webpack-plugin插件用来从bundle中提取出css作为一个公共的css文件。在webpack的配置文件中引用，在loader中设置额外的提取。
              </p>
              <pre><code>{
            test: /\.vue$/,
            loader: &apos;vue-loader&apos;,
            options: {
                loaders: {
                    less: ExtractTextPlugin.extract({
                        use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;, &apos;less-loader&apos;],
                        fallback: &apos;vue-style-loader&apos;
                    }),
                    css: ExtractTextPlugin.extract({
                        use: [&apos;css-loader&apos;, &apos;autoprefixer-loader&apos;],
                        fallback: &apos;vue-style-loader&apos;
                    })
                }
            }
        }
</code></pre>
              <p>定义use来确实使用什么来解析提取的内容，使用fallback来定义从什么中抽取文件。 </p>
              <h5 id="HtmlWebpackPlugin">
                <a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h5>
              <p>html-webpack-plugin是用来生成HTML文件并且自动引用打包的文件。可以指定模板的位置，可以指定引用文件的位置，可以增加title，增加favicon等等，是一个服务于首页的插件。</p>
              <h5 id="自定义webpack插件">
                <a href="#自定义webpack插件" class="headerlink" title="自定义webpack插件"></a>自定义webpack插件</h5>
              <h6 id="cpmpile和compilation">
                <a href="#cpmpile和compilation" class="headerlink" title="cpmpile和compilation"></a>cpmpile和compilation</h6>
              <p>自定义webpack通常通过重写插件的apply方法，并且将webpack的compile作为参数传递进入方法。compile对象时webpack在编译启动时，将配置文件数据注入后生成的编译对象。
                <br>compilation是在文件发生变动时，webpack的一个代表发生变化的对象，他包含了各种变化的回调</p>
              <pre><code>function HelloWorldPlugin(){
}
HelloWorldPlugin.prototype.apply = function(compile){
    compile.plugin(&quot;emit&quot;,function(compilation,callback){
        //这里做想要的操作，做完以后调用callback（）完成
        callback();
    })
}
</code></pre>
              <h5 id="AutoMerage插件">
                <a href="#AutoMerage插件" class="headerlink" title="AutoMerage插件"></a>AutoMerage插件</h5>
              <p>本项目使用了自定义插件AutoMerage，功能是读取文件目录，自动生成对外导出文件。 </p>
              <pre><code>/**
 * AutoMerage.js
 */

let fs = require(&apos;fs&apos;);
let Handlebars = require(&apos;handlebars&apos;);
let _ = require(&apos;lodash&apos;);
let util = require(&apos;./util&apos;);

function AutoMergeJs(options) {
}
AutoMergeJs.prototype.apply = function (compiler) {
    compiler.plugin(&apos;emit&apos;, function (compilation, callback) {
        function createIndex(src, targetFile) {
            //获取所有目录文件的名建明，除模板相关文件
            let files = util.readFilesInDir(src, {
                prefix: &apos;.&apos;,
                excludeFiles: [&apos;index.vue&apos;, &apos;index.js&apos;, &apos;index.tpl&apos;],
                format: (f) =&gt; f.substring(0, _.lastIndexOf(f, &apos;.&apos;))
            });
            targetFile.forEach(f =&gt; {
                //获取模板文件
                let data = fs.readFileSync(src + &apos;/&apos; + f.template, &apos;utf-8&apos;);
                const template = Handlebars.compile(data);
                //利用目录文件遍历模板生成文件
                let result = template({
                    list: files
                });
                try{
                    //获取原编译结束后的文件
                    let old = fs.readFileSync(src + &apos;/&apos; + f.target, &apos;utf-8&apos;);
                    //如果和源文件不同，则将新的结果写入到文件中
                    if (old !== result)
                        fs.writeFileSync(src + &apos;/&apos; + f.target, result);
                }catch(e){
                    fs.writeFileSync(src + &apos;/&apos; + f.target, result);
                }
            });
        }
        let _targetFile = [{
            template: &apos;index.tpl&apos;,
            target: &apos;index.js&apos;,
        }];
        createIndex(&apos;./src/actions&apos;, _targetFile);
        createIndex(&apos;./src/components/pages&apos;, _targetFile);
        createIndex(&apos;./src/components/common&apos;, _targetFile);
        callback();
    });
};
module.exports = AutoMergeJs;
</code></pre>
              <p>进行模板文本操作的工具类</p>
              <pre><code>/**
 * util.js
 */
var fs = require(&quot;fs&quot;);

//path模块，可以生产相对和绝对路径
var path = require(&quot;path&quot;);
var _ = require(&quot;lodash&quot;);

//读取文件存储数组
function readFilesInDir(dirUrl, option) {
    var fileArr = [];

    var {excludeFiles = []} = option;
    var {format = null} = option;
    var {prefix = &apos;&apos;} = option;

    //excludeFiles中包含file时返回false；
    function exclude(file) {
        return !_.includes(excludeFiles, file);
    }

//获取文件数组
    function readFile(readurl, name) {
        var name = name;
        //同步读取文件目录
        let files = fs.readdirSync(readurl);

        files.forEach(function (filename) {
            //获取文件状态
            let stats = fs.statSync(path.join(readurl, filename));
            //如果是文件且不是index.vue/index.js/index.tpl，这三种文件要过滤掉
            if (stats.isFile() &amp;&amp; exclude(filename)) {
                //options。format存在且是一个函数
                if (!!option.format &amp;&amp; _.isFunction(option.format))
                    //获取文件名
                    filename = option.format(filename);
                var newUrl = name + &apos;/&apos; + filename;  // ./filename
                fileArr.push({name: filename, fullName: newUrl});
                //是子目录则递归处理
            } else if (stats.isDirectory()) {
                var dirName = filename;
                readFile(path.join(readurl, filename), name + &apos;/&apos; + dirName);
            }
        });
    }

    readFile(dirUrl, prefix);
    return _.chain(fileArr).filter(file =&gt; file.name &amp;&amp; file.name !==   &apos;&apos;).sortBy((f) =&gt; f.fullName).value();
}

module.exports = {readFilesInDir: readFilesInDir};
</code></pre>
              <p>这里的几个关键技术是Handlebars、fs、lodash。
                <br>Handlebars是一种模板技术，通过将数据和模板结合，在编译之后就可以自动生成文件。
                <br>index.tpl </p>
              <pre><code>//Do not modify this file, it will be auto generated
import vuexDecorator from &apos;../libs/vuexDecorator&apos;;
{{#list}}
import  {{this.name}} from &apos;{{this.fullName}}&apos;;
{{/list}}

export default {
{{#list}}
    {{this.name}}: vuexDecorator(&apos;{{this.name}}&apos;,{{this.name}}),
{{/list}}
}
</code></pre>
              <p>编译模板： </p>
              <pre><code>//获取模板文件
let data = fs.readFileSync(src + &apos;/&apos; + f.template, &apos;utf-8&apos;);
const template = Handlebars.compile(data);
//利用目录文件遍历模板生成文件
let result = template({
    list: files
});
</code></pre>
              <p>写回文件：</p>
              <pre><code>fs.writeFileSync(src + &apos;/&apos; + f.target, result);
</code></pre>
              <p>在对js使用按照这种方法就可以实现动态配置，减少代码量。</p>
              <p>fs是nodejs内置的模块，可以做文件读写，这里有几个关键的函数：</p>
              <ol>
                <li>fs.readFileSync() 读取文件内容</li>
                <li>fs.writeFileSync() 写入文件</li>
                <li>fs.statSync() 获取文件状态，返回Stats类</li>
                <li>stats.isFile() 是否是文件</li>
                <li>stats.isDirectory() 是否是目录</li>
                <li>fs.readdirSync() 读取文档目录结构</li>
              </ol>
              <p>lodash是和underscore类似的函数式变成的库，提供了大量的实用的方法。</p>

            </div>
            <div class="post-tool">
              <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
              </a>
            </div>

            <div class="post-tags">标签：

              <a href="/tags/webpack/">webpack</a>

            </div>

          </article>

          <p>本文内容仅作为作者个人兴趣与观点，不代表所在公司及团队的观点和决策。若有不恰当之处，望不吝赐教</p>

        </div>
        <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

      </div>
      <!-- end #main-->
    </div>
    <!-- end #body -->
    <footer class="footer">
      <div class="footer-inner">
        <p>
          <a href="/about" title="关于本站">关于本站</a>&nbsp;&nbsp
          <em>·</em>&nbsp;&nbsp
          <!-- 自定义链接 -->
          <a href="/help" title="help">急救中心</a>&nbsp;&nbsp
          <em>·</em>&nbsp;&nbsp
          <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp
          <em>·</em>&nbsp;&nbsp
          <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
          本站点采用
          <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立
          <a href="/timeline" id="siteBuildingTime"></a>天
          <br/> ©2017 基于
          <a href="http://hexo.io" target="_blank">Hexo</a>搭建 ，主题&nbsp
          <a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
          ，作者
          <a href="https://www.tangkunyin.com" target="_blank">唐先森</a>
          ，Hosted by
          <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>

      </div>
    </footer>
    <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
    <script src="/js/InsightSearch.js"></script>
    <script src="/js/SimpleCore.js"></script>

  </div>
  <div class="fixed-btn">
    <a class="btn-gotop" href="javascript:">
      <i class="fa fa-angle-up"></i>
    </a>
  </div>
  <script>
    $(function() {
      SimpleCore.init({
        buildingTime: '08/20/2014',
        current: $('.post-tags').length > 0 ? 'post' : 'archive',
        wxMpImg: '/images/weixin-mp.png',
        donateImg: '/images/donate-qr.png',
      });
    });

  </script>
</body>

</html>
