<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[let/const]]></title>
    <url>%2F2017%2F07%2F27%2Flet%20const%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;尝试在不查看文档的情况下写出es6知识点的相关内容，遇到没记清楚的再查阅才能加深记忆力，好记性不如烂笔头 let/const几个重要特性 没有变量提升 暂时性死区 不允许重复声明 全局声明的变量不再挂载到window上 &nbsp;&nbsp;理解没有变量提升，要先回顾变量提升的概念。js作为词法作用域的语言，js的作用域是在代码执行的时候确认的，代码执行的环境会有一个对应的执行上下文，每次进入一个执行环境都会创建一个执行上下文，执行上下文在创建阶段会做三件事。 确认作用域 创建变量对象 确认this指向 &nbsp;&nbsp;变量提升就发生在创建变量对象时，创建变量对象要做2件事。第一，查找var变量声明，不包括let和const声明，在变量对象里生成对应变量名称的属性，重名的声明会被覆盖。第二，查找函数声明，生成对应函数名的指针对象指向函数的堆内存空间存放位置，重名的函数不会生效。 &nbsp;&nbsp;在代码开始执行的时候，执行上下文就会进入执行阶段，变量对象就会变成活动对象，并且根据执行进度对活动对象里的提前声明的对象赋值。&nbsp;&nbsp;由此可以知道为什么let、const没有变量提升，因为，在进行变量提升的时候没有对let、const的变量声明进行提升。 &nbsp;&nbsp;暂时性死区的概念其实和没有变量提升是一个意思，在let、const变量还没有声明的时候，在对应的作用域内使用它会直接导致报错，对于let、const变量而言，{}就是它们在还没有被声明时的死区。所以我认为阮一峰的es6入门在这一块的讲述是重复且有误导性的，没有变量提升其实是暂时性死区的原理，而不应该把两者都作为特性来说明。 &nbsp;&nbsp;关于不允许重复声明这一条特性，在原理上确实不好理解，目前我只能理解成语法糖，语法规定了就是这样，不过从这条语法糖的意义上倒是可以看出js视图纠正之前变量声明过于灵活的问题，我一直无法理解可以重复声明同名变量还不回报错到底有什么意义，除了不会报错以外，在使用上完全可能破坏代码，降低代码质量。&nbsp;&nbsp;let、const声明的变量不再挂载到Window上野同样是为了规范变量声明，js不再默认允许随意的创建全局变量。 &nbsp;&nbsp;声明let、const变量导致的块级作用域不难理解，只要在{}内声明了let、const变量，{}就会成为一个es5里不支持的块级作用域。 &nbsp;&nbsp;难以理解的是es6规定了在{}里声明的函数也会导致会计作用域，不需要其他声明，函数就会被绑定到这个作用域里。其实这让人很难理解，es6并没有摒弃es5的内容，执行上下文依然会创建，那么块级作用域又是如何在原理上实现的呢，如何检测、创建、绑定一个块级作用域？ 问题：如何检测、创建、绑定一个块级作用域？]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react入门级教程（一）]]></title>
    <url>%2F2017%2F07%2F03%2Freact%E5%85%A5%E9%97%A8%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%B9%B2%E8%B4%A7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[react入门级教程（一）1、前言react的官方文档的逻辑和语言方式真的是难看，就像看外语翻译来的文学小说，再真挚再伟大的感情波动读起来都像是在看戏，还不如自己做一个总结。react和vue我都系统学习过，两者对比起来，react的自由度会更高一些，react的开发更接近原生js代码，除了它基本的不多的几个语法，其他的都是es6来完成，而vue配置项要多很多，语法也相对多很多，这也是为什么我近期准备啃react的原因，对于es6的高度依赖对开发人员的成长更有好处，能学到更多东西。写这个教程，最大的目的是巩固自己的基础，其次是希望能帮助到一些和我一样的初学者。 2、create-react-app一个工程化的兼容性强的前端开发环境自己配置对于初学者来说是非常艰难的，需要配置es6环境，配置基于node的服务器，配置打包工具，配置模块化，配置css3、html5支持，等等。对初学者，这会是一个很难受的过程，去年年初，我自己在不知道vue-cli的情况下研读了github上别人的项目，对着一堆代码研究了好几天才搞明白，究竟在干嘛，还是在知道了vue-cli以后才知道是自动生成的代码，而不是自己写的，很难受。因此，学习这些框架在不进行进一步webpack配置的情况下，完全可以直接用自动化工具来初始化一个项目，而不需要自己来搭建，vue项目使用vue-cli，react项目使用create-react-app。使用npm安装create-react-app： npm install create-react-app -g //建议全局安装 create-react-app构建了一个完善的开发环境，包括热替换等。 //创建一个项目 create-react-app 项目名称 //初始化项目 npm install //运行项目 npm start 执行上面代码就可以初始化并且运行项目，会得到一个demo页面，这里就不截图了。src下的index是react项目的入口文件，其他的是组件。 3、react基础语法其实之前也做了好几次整理，但是还是容易变得模糊，不精准，只能说好记性不如烂笔头，这里主要对对react部分来说明语法，react-dom暂且放一放这里会提到以下几个类和方法：react、Component、jsx、render、props。下面是一个简单的react组件 import React,{Component} from &apos;react&apos;; //从react导入React相关环境以及组件环境 var root = document.querySelector(&quot;app&quot;);//拿到页面的根元素。 render(&lt;div&gt;haha&lt;/div&gt;,root);// 组件的render渲染方法，把虚拟的div组件绑定到root上 其实上面三行代码已经包含了react的精髓内容，react更多的是一种基于数据的新的开发思维模式。第一行代码，在单页应用spa里依赖react的环境，这个环境有很多内容，这里只依赖了Component，一个组件相关的类第二行代码，获取要挂载的根节点第三行代码，创建一个虚拟DOM，也就是haha,然后把这个虚拟DOM挂载到根节点上,react的精髓就在于创建虚拟DOM，挂载以后生成真实的DOM，用数据驱动虚拟DOM进行变化，虚拟DOM的变化反映到挂载的真实DOM上。react的目的就是更小耦合度的划分功能模块成组件，一个功能或者几个功能划分成一个组件，组件的通信来完成复杂功能。 4、创建组件的两种方式通过reactDOm来创建的方式并不被官方推介。 a、创建无状态组件由react开创的组件化的模式在于转换操作DOM为操作数据，以前我们习惯于使用jquery操作DOM来做页面逻辑操作，react的思路是利用操作数据来改变虚拟DOM然后更新真实DOM，比如一个表单验证，使用jquery是操作DOM来获取表单元素的值，然后对值进行校验，然后再一次操作提示部分的DOM进行复制，使用react的思路是创建一个虚拟的DOM表单，直接进行表单数据验证，将验证结果反应到反应到数据上，然后根据数据重绘表单界面。jquery是一个工具，运用jquery是一个横向的单点的过程，只关心自己择器操作的DOM，而不关心使用场景。而使用react是一个纵向的连续的过程一个react组件本身就是可以持续改变，多个组件通过父子关系，兄弟关系，在横向和纵向上可以组合拉伸。一个用户操作在jquery里只是一个普通的操作DOM改变界面，在react里却是能看到一条线，一条由用户操作引起的数据流向的线。更重要的一点是，react组件是可以积累的，是可复用的。会到第一种创建组件的方式：无状态组件。一个组件的状态就是它的数据，数据变化，组件就会重新绘制，无状态组件就是没有自己状态的组件，这种组件不在少数，只展示信息的组件，它不需要有属于自己的数据，他只负责展示，用户操作的组件，一个button只代表一个用户点击操作，它于它的父组件不可分割，也不需要有自己的数据。我们通过函数式的写法来创建组件： ShowMessage.jsx import React from &apos;react&apos;; const ShowMessage = () =&gt; { return( &lt;div&gt;nihao&lt;/div&gt; ) } export default ShowMessage; () =&gt; {}箭头函数式es6的写法，用来固定this指向,简写function，它等于 function(){},import和export是es6模块化的东西。上面这个组件就是一个没有自己状态的组件，但是它没有意义，一个静态div的组件是没有意义的，使它有意义的是他的父组件，它没有自己的数据，但是可以有父组件的数据，父组件传递数据给子组件的方式是通过属性，然后在子组件里通过props来获取数据. parent.jsx import showMessage from &apos;showMessage.jsx&apos;; import React,{Component} from &quot;react&quot;; class Parent extends Component{ state = { message：&quot;hello&quot; } render(){ return( &lt;ShowMessage message={message}/&gt; ) } } export default Parent; 这里使用属性的方式把message赋值给ShowMessage子组件。 {message}是jsx的语法，jsx是一个js的扩充语言，它的写法于html一样，在读取编译的时候，会使用creatElement函数来根据标签创建js对象，{message}是在jsx里插入变量的写法。 ShowMessage.jsx import React from &quot;react&quot;; const ShowMessage = (props) =&gt; { return( &lt;div&gt;{props.message}&lt;/div&gt; ) } export default ShowMessage; 在子组件里通过props来接受父组件的数据,包括给子组件绑定事件，如下 &lt;ShowMessage message={message} method={this.method}/&gt; ShowMessage.jsx import React from &quot;react&quot;; const ShowMessage = (props) =&gt; { return( &lt;div onClick={props.method}&gt;{props.message}&lt;/div&gt; ) } export default ShowMessage; b、创建有状态的组件上面的Parent组件其实就是有状态的组件 parent.jsx import showMessage from &apos;showMessage.jsx&apos;; import React,{Component} from &quot;react&quot;; class Parent extends Component{ state = { message：&quot;hello&quot; } render(){ return( &lt;ShowMessage message={message}/&gt; ) } } export default Parent; class是es6创建类的关键字，于创建一个函数其实差别不大；extends是es6进行继承的写法，es5必须通过原型链将圆形赋值给被继承对象的实例才能完成继承，es6简化了这个部分，现在只需要使用extends就可以完成继承，当然也可以使用supper函数。Component是react里的组件相关的类，render是Component提供的渲染函数，用来渲染组件。一个组件有了自己的状态就可以做很多事情了，要牢记的一点是：组件的数据发生改变就会调用render函数重新绘制组件，组件的数据包括自己状态state和来自父组件的数据props。比如做一个提交功能，包含提交按钮，一个提示信息，提交时还要禁止点击 Button.jsx import React from &quot;react&quot;; const Button = (props) =&gt; { const {children, loading, submit} = props; return ( &lt;button onClick={submit} disabled={loading?&apos;disabled&apos;:null&gt; {loading &amp;&amp; &lt;i className=&quot;loading&quot;&gt;&lt;/i&gt;} {children} } &lt;/button&gt; ) } export default Button; 这个提交按钮Button组件没有自己的状态，只有父组件传递的提交函数，子元素，是否loadind。className是为了和class关键字区分开，className表示css类名，const { … } = props是es6解析结构的写法 Dialog.jsx import React from &quot;react&quot;; const Dialog = () =&gt; { const {message, close} = props; return( &lt;div className=&quot;dialog-backdrop&quot;&gt; &lt;div className=&quot;dialog-container&quot;&gt; &lt;div className=&quot;dialog-header&quot;&gt;提示&lt;/div&gt; &lt;div className=&quot;dialog-body&quot;&gt;{ message }&lt;/div&gt; &lt;div className=&quot;dialog-footer&quot;&gt; &lt;button className=&quot;btn&quot; onClick={ close }&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) } 这个弹出框组件接受父组件的消息和关闭函数 App.jsx import React, { Component} from &quot;react&quot;; import Button from &quot;Button.jsx&quot;; class App extends Component{ state = { message: &quot;&quot;, loading: false, dialog: false } submit = () =&gt; { this.setState({ loading: true }) setTimeout( () =&gt; { const res = Math.random(1); if(res &lt; 0.5){ this.setState({ message: &quot;提交成功&quot;, dialog: true }) }else{ this.setState({ message: &quot;提交成功&quot;, dialog: true }) } this.setState({ loading: false }) }) } close = () =&gt; { this.setState({ dialog: false, }) } render(){ const {loading, message, dialog} = this.state; return ( &lt;div className=&quot;app-wrap&quot;&gt; &lt;Button submit={this.submit} loading={loading}&gt;提交&lt;/Button&gt; {dialog &amp;&amp; &lt;Dialog message={message} close={this.close}/&gt;} &lt;/div&gt; ) } } 这个由三个组件组成的提交功能的组合组件中数据的流向从上到下，从用户点击开始，点击改变了父组件状态，组件状态改变了子组件的props。 5、react组件的声明周期钩子任何流程和事物都有一个生命周期，react的声明周期有三种：挂载前后、更新前后、销毁前挂载前后：componentWillMount（）、componentDidMount（） 更新前： componentWillReceiveProps接收到一个新的props时，在重新render之前调用 shouldComponentUpdate 接收到一个新的state或者props时，在重新render之前调用 componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用 更新后： componentDidUpdate 组件完成更新之后调用 销毁前： componentWillUnmount]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值]]></title>
    <url>%2F2017%2F07%2F02%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;es6由于import、export模块化的能力，也推出了解构赋值这么一种能力，顾名思义，解析赋值，解析js代码然后进行赋值。这篇只是梳理并不设计代码例子。es6的解构赋值指的是在赋值表达式中解构右边部分的值然后将值赋给左边。 解构赋值的几种情况&nbsp;&nbsp;解构赋值在于根据赋值表达式左边的匹配模式，来解构右边的表达式并且完成赋值。根据右边的表达式的不同解构的结果不同。 对数组的解构 对对象的解构 对字符串的解构 对函数的解构 对boolean的解构 &nbsp;&nbsp;解构虽然是根据被解构对象不同会有不同的差别，但是原理都是一致的：按照一定的模式，从对象中提取值，并完成赋值，只是有一些特殊的情况需要注意。 解构赋值是可以有默认值的。在没有默认值的情况，如果没有解析到值那么，值就是undefined，所以只有在值被解析完成以后为undefined才会触发默认值，解析为null或者false等都不算。 模式匹配必须和右边的解构完全一致，不一致则会因此导致错误。 对一个已经声明的变量进行解构赋值是很容易导致错误的一件事，没有变量声明var、let、const，解析器无法确定这是一个解构赋值语句还是一个代码块，因此需要使用（）来包裹整体，（）包裹住就不会被认为是一个代码块 在对字符串解构的时候，字符串被改为一个类似数组的对象，会解构出每一个字符 对数字和布尔值进行解构的时候，原始类型的值会被转化成引用类型的封装对象。 最复杂的是结合函数参数进行解构赋值，由于函数参数可以有默认值，解构赋值对象也可以有默认值，将函数参数的默认值设置为有默认值的解构赋值是最复杂和麻烦的事，需要根据原理细致的查看，编写相应代码时也要格外小心。 （）在解构赋值中的使用也需要小心，只有赋值语句的非模式部分可以使用圆括号，其他任何地方使用圆括号都会报错]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM新API fetch]]></title>
    <url>%2F2017%2F06%2F07%2Ffetch%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;之前刚刚总结了axios的用法，然后就突然发现了fetch这么一个东西，这个既然还是新的BOM标准之一，不得不感叹，前端技术推进真的是快，连ajax都要被取代了吗&emsp;&emsp;fetch是定义在BOM标准中window上得一个功能集，它的目的在于取代现有的XMLHttpRequest。w3c认为XMLHttpRequest比较杂乱、异步请求是基于事件模型的，相比Promise和asyns/await来说不够友好、不符合长期以爱w3c关注分离的原则。因此，w3c发布了fecth标准，用来取代旧有的ajax。&emsp;&emsp;其实浏览器请求天生就是异步操作，长久以来，一直都在致力于简化、规范化这个过程。jQuery的ajax方法，es6的Promise，es7的asyns/await、以及大量的前端框架，像angular-resource，axios等等。&emsp;&emsp;但是w3c这个行为像是在搞事呀，ECMA组织发布了es6、es7中都包含有异步操作的内容，也都很强大，它在promise的基础上封装一个fetch出来有些瞎操心。不过从另一个角度来说，ajax以前也是w3c负责发布的标准，做这个改进也合情合理，但是fech像替换掉ajax甚至jquery的ajax，我并不看好。 fetch APIfetch的API主要体现在它的接口实现上，分为以下几个接口，GolbalFetch、Body、Request、Response、Headers，其他的接口暂时不准备学习。 GolbalFetch这个接口提供了fetch（）方法，window实现了这个接口，因此可以直接使用window.fetch()来请求资源，fetch()接受一个Request接口对象，或者一个URL。 var URL = &apos;https://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=your_api_key&amp;format=json&amp;nojsoncallback=1&amp;tags=penguins&apos;; function fetchDemo() { fetch(URL).then(function(response) { return response.json(); }).then(function(json) { insertPhotos(json); }); } fetchDemo(); Request]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS typeof总结---6种数据类型]]></title>
    <url>%2F2017%2F06%2F05%2Fjavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;为什么要写这个东西？因为typeof总是返回一些乱七八糟的词啊，各种基本数据类型莫名其妙的相等！不总结一下不行了？那么，typeof究竟会返回哪些值呢？js有5种基本类型Undefined、Null、Boolean、String、Number，一种复杂类型Object，函数本质是一个对象，但是函数由于它在js中的特殊性，也需要从其他对象中被区分出来function，因此，typeof会返回7种值。 js五种基本数据类型js有5种基本数据类型undefined、null、boolean、string、number，下面一一说明: 1、UndefinedUndefined作为基本类型的意义，意如其名，未定义,Undefined作为变量的基本类型，是针对变量来说的，因此默认变量已经存在。 在ECMAScript里，Undefiend只有一个值，即特殊的undefiend在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量var a; a == undefined// true typeof a//&apos;undefined&apos; 我们考虑的是：什么样的变量 typeof会返回‘undefined’按照上面的定义，未初始化的变量会返回undefined；还有一种特殊情况也会返回undefined，那就是未声明变量 typeof b//&apos;undefined&apos; b == &apos;undefined&apos; // 会报错 这里我们要分清楚三个概念: 变量是否已定义 变量类型 变量的值 再结合typeof就不难理解为什么只有未初始化的变量值为undefined，而未定义和未初始化的变量数据类型都为Undefined。未定义的变量本来就不存在，把他归为Undefined变量只是为了更好的区分。 因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在2、Null&emsp;Null和Undefined类似，表示为空，但是在js里，为空是什么意思呢？ 在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针var a = null; typeof a //&apos;object&apos; typeof null // &apos;object&apos; 也就是说null表示一个没有指向的对象指针，这样我们就可以理解了。 这样看来，null和undefined其实并没有太大的区别，赋值一个空的对象指针null和赋值一个undefined，看起来没有区别，而且实际上 null == undefined// true undefined == null//true 更过分的是： var a = null; a == undefined // true var b; b == undefined // true //这个最过分 a == b //true，竟然是true，但是也引发出了一个大的猜想：在变量还没有被赋予实际值的时候，所有变量的值都是一样的，不一样的只有类型 这两个值还真的是相等的，每次看到这里肯定就已经绕进去了。。。。这两个基本属性在搞什么呀，乱七八糟，莫名其妙。非要总结一下规则的话,可以说，这两种基本类型是一样的，一样的值；Undefined和Null就像两条线，两条一模一样的线，但是他们依然是不同的线。他们的不同就在于类型的不同，在于意义的不同，undefiend是未初始化的值，null是空的对象指针。ECMAScript引入这个undefined的最主要目的就是为了与空对象指针null做区分 3、Boolean&emsp;Boolean是ECMAScript中的布尔类型，有两个值：true和false，并且，这两个值区分大小写Boolean()可以转换其他类型为Boolean类型，在进行if（）判断时，就是默认调用了Boolean（）方法。 数据类型 true false Boolean true false Strung 非空字符串 空字符串 Number 任何非0数字（包括无穷大） 0和NaN Object 任何Object null、 Undefined 不试用 undefined 4、NumberECMAScript是基于IEEE754数值格式的，由于IEEE754的通病，浮点数会有四舍五入的毛病，0.1+0.2并不等于0.3，而是等于0.30000000000000004，所以不要确定浮点数的值。Number可以通过8进制、十进制、十六进制来表示，十进制和往常一样 八进制，首位数字为0,078表示八进制的78,十进制的64， 十六进制，首尾字符为0x，0x9表示十六进制的9，A~E表示11~15。 数值范围上来说，Number有一个上下线，一旦超过了上线就会变成Infinity，超过下线就会变成-Infinity。而一个本来应该返回数值的数结果却没有返回数值，这个时候就会返回NaN，比如0/0就会返回NaN。NaN与任何值都不相等，包括它自身，它只是一个代表意义，表示不是数字。可以用isNaN来判断是否不是数字]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios随笔]]></title>
    <url>%2F2017%2F06%2F02%2Faxios%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介&emsp;axios是一个基于es6 Promise的HTTP库，可以在浏览器和nodejs中使用。在vue2之后，官方不在推介vue-resource，然是推介使用axios，作为一个被很多人引用为项目依赖的模块，各方面的性能还是信得过的。在浏览器中发起XMLRequest，在node中发起http请求，在形式上支持Promise异步链式编程，也支持自动转化json，同样还可以做请求拦截和分发。是功能很强大的一个插件 安装&emsp;直接引入官方axios.js或者使用npm安装npm i axios 示例//发起一个user请求，参数为给定的ID axios.get(&apos;/user?ID=1234&apos;) .then(function(res){ conole.log(res) }).catch(function(error){ console.log(error) }) //上面的请求也可选择下面的方式来写 axios.get(&apos;/user&apos;,{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error) }); axios语法1.基础用法–发起请求axios(config).then().catch(); &emsp;config的配置如下 config = { method: &apos;get/post/put/delete...&apos;, url: &apos;/api/dsdsd/dsd&apos;, data: { }, responseType: &apos;strean/json/string/...&apos; } //发起一个post请求 axios({ method:&apos;post&apos;,//方法 url:&apos;/user/12345&apos;,//地址 data:{//参数 firstName:&apos;Fred&apos;, lastName:&apos;Flintstone&apos; } }); 2.请求方法的重命名&emsp;根据axios(config)，来重命名一批方法。 //请求配置外置化 axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,config]) axios.options(url[,config]) axios.post(url[,data[,config]]) axios.put(url[,data[,config]]) axios.patch(url[,data[,config]]) config中的url、data、method会被重命名方法中的参数替换掉 3.创建axios实例axios.create(config) 创建实例的意义在于预定义一些参数值，那么采用这个实例来发起请求，这些参数就会默认载入。 //创建一个axios实例 var instance = axios.create({ baseURL:&apos;http://some-domain.com/api/&apos;, timeout:1000, headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;} }); //使用实例来发起请求 instance.get(&apos;/api/user/123&apos;); 同axios本身一样，实例也有方法重命名 instance.request(config) instance.get(url[,config]) instance.delete(url[,config]) instance.head(url[,config]) instance.options(url[,config]) instance.post(url[,data[,config]]) instance.put(url[,data[,config]]) instance.patch(url[,data[,config]]) 4.请求参数配置全局信息 { //url是服务器链接，用来请求 url:’/user’, //method是发起请求时的请求方法 method:get, //baseURL如果url不是绝对地址，那么将会加在其前面。 //当axios使用相对地址时这个设置非常方便 //在其实例中的方法 baseURL:’http://some-domain.com/api/‘, //transformRequest允许请求的数据在传到服务器之前进行转化。 //这个只适用于PUT,GET,PATCH方法。 //数组中的最后一个函数必须返回一个字符串或者一个ArrayBuffer,或者Stream,Buffer实例,ArrayBuffer,FormData transformRequest:[function(data){ //依自己的需求对请求数据进行处理 return data; }], //transformResponse允许返回的数据传入then/catch之前进行处理 transformResponse:[function(data){ //依需要对数据进行处理 return data; }], //headers是自定义的要被发送的头信息 headers:{‘X-Requested-with’:’XMLHttpRequest’}, //params是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象 params:{ ID:12345 }, //paramsSerializer是一个可选的函数，是用来序列化参数 //例如：（https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/) paramsSerializer: function(params){ return Qs.stringify(params,{arrayFormat:’brackets’}) }, //data是请求提需要设置的数据 //只适用于应用的’PUT’,’POST’,’PATCH’，请求方法 //当没有设置transformRequest时，必须是以下其中之一的类型（不可重复？）： //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams //-仅浏览器：FormData,File,Blob //-仅Node：Stream data:{ firstName:’fred’ }, //timeout定义请求的时间，单位是毫秒。 //如果请求的时间超过这个设定时间，请求将会停止。 timeout:1000, //withCredentials表明是否跨网站访问协议， //应该使用证书 withCredentials:false //默认值 //adapter适配器，允许自定义处理请求，这会使测试更简单。 //返回一个promise，并且提供验证返回（查看response docs） adapter:function(config){ /…/ }, //auth表明HTTP基础的认证应该被使用，并且提供证书。 //这个会设置一个authorization 头（header），并且覆盖你在header设置的Authorization头信息。 auth:{ username:’janedoe’, password:’s00pers3cret’ }, //responsetype表明服务器返回的数据类型，这些类型的设置应该是 //‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’ responsetype:’json’, //xsrfHeaderName 是http头（header）的名字，并且该头携带xsrf的值 xrsfHeadername:’X-XSRF-TOKEN’，//默认值 //onUploadProgress允许处理上传过程的事件 onUploadProgress: function(progressEvent){ //本地过程事件发生时想做的事 }, //onDownloadProgress允许处理下载过程的事件 onDownloadProgress: function(progressEvent){ //下载过程中想做的事 }, //maxContentLength 定义http返回内容的最大容量 maxContentLength: 2000, //validateStatus 定义promise的resolve和reject。 //http返回状态码，如果validateStatus返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。 validateStatus: function(status){ return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认 }, //httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 //这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 httpAgent: new http.Agent({keepAlive:treu}), httpsAgent: new https.Agent({keepAlive:true}), //proxy定义服务器的主机名字和端口号。 //auth表明HTTP基本认证应该跟proxy相连接，并且提供证书。 //这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。 proxy:{ host:127.0.0.1, port:9000, auth:{ username:’cdd’, password:’123456’ } }, //cancelTaken 定义一个取消，能够用来取消请求 //（查看 下面的Cancellation 的详细部分） cancelToken: new CancelToken(function(cancel){ }) } 5.返回对象response包含对象response包含以下5个对象： data：{}：服务器返回的数据 status: 200 服务器返回的http状态码 statusText： ‘ok’ 服务器返回的状态信息 header:{} : 服务器返回头信息 config：{} axiox的请求配置信息 6.默认配置可以给axios或者axios的实例设置默认配置，axios中有三种配置信息： 默认配置，在模块的lib/defaults.js中的默认配置 其次是自定义的默认属性 最后是请求中的config配置 在定义实例的时候会在默认配置文件中创建一份临时数据，实例被销毁的时候，也销毁临时配置数据。 自定义默认数据的方式如下： instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 7.配置拦截器axios支持配置两种拦截器：拦截请求、拦截响应拦截请求： axios.interceptors.request.use(function(config){ //在请求之前做的一些事 },function(error){ //在请求错误之前做的一些事 return Promise.reject(error) }) 拦截响应： //添加一个返回拦截器 axios.interceptors.response.use(function(response){ //对返回的数据进行一些处理 return response; },function(error){ //对返回的错误进行一些处理 return Promise.reject(error); }); 取消拦截器需要使用eject函数 axios.interceptors.request.eject(&apos;拦截器名称&apos;)]]></content>
      <categories>
        <category>-- HTTP -- axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%97%A0%E6%A0%87%E9%A2%98Markdown%2F</url>
    <content type="text"><![CDATA[前言最近领导和我聊了很多关于个人发展，关于职业规划方面的东西，对我确实有一些触动，也实实在在的点醒了我. 个人问题长久以来，我深航都存在基础不稳的问题，大学阶段的浑浑噩噩，工作以后填填补补。靠着java找到的工作，但是自己却基本还是停留在对简单的框架使用，java基础没有好好总结过，spring也没有完全的好好看一遍，数据库sql更是不行，在后台开发这一块水得一塔糊涂. 这或许就是我谋求前端的原因之一吧，在前端技术的学习上我确实下了功夫，但是缺点也很明显，重心太多偏向js。 或许也是因为js是我技术的启蒙吧，大学阶段那么多的实习，从第一次读写文件MFC展示实习失败开始就一直没正真入门，但是js接纳了我，我第一次聚精会神写一份代码，站在图书馆一呆一天也是因为js。工作以后第一次的任务也是一份js编程的工作，DAP4，借助esayui我使用js完成了一个项目，当时的代码我都保留了起来，虽然现在看起来已经难以入目了，但是这引领了我进入了编程的世界。 后端java的缺点在于基础不扎实，代码都写过了，但是却不明白代码的运行规则。 前端的问题有两部分，基础上，对于js的编程自己还算满意，但是对于css和html标签的掌握不够。框架上，我只熟悉常用的框架，vue，react，webpack，scss，node，express，我只具备基础架构能力，自己也不能判断我是否具有框架的全局把控力。缺乏经验，大量缺乏经验，其实我也算是参与了三个成熟软件产品的研发，但是没有做到业务积累，没有培养自己的建模能力。很失败的一件事情，大学出来以后全部重心都放置在填补以前的空缺上了，没有对参与的项目进行非技术总结，没有细分业务需求的形成。 想法面对基础的缺失，依然只能通过技术积累，通过看学习来积累，面对眼界，思维方式的缺失，却要自己多想多钻研。 多看文档博客，一点点补充缺失，特别是新特性，java8，css3，es6. 全方面理解web应用开发架构，明白每个模块，每个阶段用到了哪些技术，选取其中最流行最优秀的一个进行研究学习。 在真正理解了系统架构的基础上理解业务需求，加强建模能力。 路漫漫其修远兮，吾将上下而求索。]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown写法]]></title>
    <url>%2F2017%2F05%2F26%2FmarkDown%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown写法1、定义标题文本写法直接写和按一下tab’写是有区别的、#的个数指定字体大小 按tab,然后直接写就是正文文本 2、有序列表和无序列表有序列表1. DASDASD 2. DASDASD 3. DASDASFD 无序列表 1 2 3 3、使用”&gt;”来进行引用 你好，引用的字体会是灰白色 4、图片链接博客中添加图片我们可以使用图床获取图片的URL， 可以去这个网址http://jiantuku.com/#/ 图片的写法是![]() ![nihao](http://dadasd/adasd/sdasd,jpg) 5、粗体斜体使用 就是粗体，使用一个 就是一斜体你好 你好 6、生成表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 使用这样的语法 “| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |” 7、代码块使用”`“来包裹var a = &quot;name&quot;; var b = &quot;cv&quot;;]]></content>
      <categories>
        <category>markDown</category>
      </categories>
      <tags>
        <tag>markDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传项目到github“]]></title>
    <url>%2F2017%2F05%2F26%2F%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[要上传项目到github需要以下几个步骤1、有或者新建一个github账户 2、创建一个和本地对应的仓库 3、本地安装git一路默认即可4、生成ssh key cd ~/.ssh 进入目录–》ls查看是否已有ssh key–》没有则新建 ssh-keygen -t rsa -C “754416804@qq.com”—&gt;不使用密码创建–》id_rsa.pub里面就是ssh key 5、到github网站关联自己的ssh key 到setting里进入ssh KEys–》增加ssh key–》填入自己的ssh key 保存 6、执行git命令，初始化空间，绑定远程仓库、添加提交代码、推送代码到远程仓库 git init –》git add . –》 git commit -m “” –》git remote add orign “你的git项目地址”–》git push -u orgin master 7、ok可以看到已经添加成功]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>