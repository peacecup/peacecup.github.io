<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[万达监控预警项目前端框架整理（三）----项目入口文件]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%2F%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89--mian%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[入口文件 单页SPA项目一般只有一个有用的入口文件，在入口文件里会根据使用的UI框架进行集成，将路由、状态管理器、国际化、时间规范等集成到项目中。 import Vue from &apos;vue&apos;; import iView from &apos;iview&apos;; import VueRouter from &apos;vue-router&apos;; import _ from &apos;lodash&apos;; import moment from &apos;moment&apos;; import Routers from &apos;./router&apos;; import Vuex from &apos;vuex&apos;; import Util from &apos;./libs/util&apos;; import App from &apos;./app.vue&apos;; //拖拽用组件 import VueDND from &apos;awe-dnd&apos;; import Store from &apos;store&apos;; import &apos;iview/dist/styles/iview.css&apos;; import &apos;!style-loader!css-loader!less-loader!./themes/index.less&apos;; import VueI18n from &apos;vue-i18n&apos;; import Locales from &apos;./locales&apos;; import zhLocale from &apos;iview/src/locale/lang/zh-CN&apos;; import enLocale from &apos;iview/src/locale/lang/en-US&apos;; import modules from &apos;./actions&apos;; import commonComponents from &apos;./components/common&apos;; // timezone from &apos;moment-timezone&apos;; import &apos;@util/directive.js&apos;; const defaultTimezone = &quot;Asia/Shanghai&quot;; //timezone.tz.setDefault(defaultTimezone); Vue.config.timezone = defaultTimezone; Vue.config.sys_error_show = true; Vue.prototype._ = _; Vue.prototype.moment = moment; if(process.env.NODE_ENV === &apos;production&apos;) { Vue.config.permissionSwitch = false; }else Vue.config.permissionSwitch = true; Vue.use(VueRouter); Vue.use(Vuex); Vue.use(VueI18n); Vue.use(iView); Vue.use(VueDND); _.keys(commonComponents).map(k =&gt; { Vue.use(commonComponents[k]); }); // 自动设置语言，获取浏览器语言 const navLang = navigator.language; // const localLang = &apos;en-US&apos;; const localLang = (navLang === &apos;zh-CN&apos; || navLang === &apos;en-US&apos;) ? navLang : false; const lang = Store.get(&apos;language&apos;) || localLang || &apos;zh-CN&apos;; Vue.config.lang = lang; // 多语言配置 const locales = Locales; const mergeZH = Object.assign(zhLocale, locales[&apos;zh-CN&apos;]); const mergeEN = Object.assign(enLocale, locales[&apos;en-US&apos;]); Vue.locale(&apos;zh-CN&apos;, mergeZH); Vue.locale(&apos;en-US&apos;, mergeEN); // 路由配置 const RouterConfig = { mode: &apos;history&apos;, routes: Routers }; const router = new VueRouter(RouterConfig); const myPluginWithSnapshot = store =&gt; { let prevState = _.cloneDeep(store.state) store.subscribe((mutation, state) =&gt; { let nextState = _.cloneDeep(state) // console.log(&quot;%c prevState&quot;, &quot;color:green&quot;) // console.log(prevState); // console.log(&quot;%c nextState&quot;, &quot;color:red&quot;) // console.log(nextState); // 比较 prevState 和 nextState... // 保存状态，用于下一次 mutation prevState = nextState }) } router.beforeEach((to, from, next) =&gt; { iView.LoadingBar.start(); Util.title(to.meta.title); next(); }); router.afterEach(() =&gt; { iView.LoadingBar.finish(); window.scrollTo(0, 0); }); const store = new Vuex.Store({ modules: modules, plugins: process.env.NODE_ENV !== &apos;production&apos; ? [myPluginWithSnapshot] : [] }); new Vue({ el: &apos;#app&apos;, router: router, store: store, render: h =&gt; h(App) }); 这个入口文件里包括了下面的内容： 注册全局组件 vue-router路由插件 国际化 vuex+插件 时间模块moment.js 注册全局组件 vue在集成使用外来插件的时候一般会使用Vue.use()来加入，那么use是个什么原理呢，看源码： Vue.use Vue.use = function (plugin: Function | Object) { const installedPlugins = (this._installedPlugins || (this._installedPlugins = [])) if (installedPlugins.indexOf(plugin) &gt; -1) { return this } // additional parameters const args = toArray(arguments, 1) args.unshift(this) if (typeof plugin.install === &apos;function&apos;) { plugin.install.apply(plugin, args) } else if (typeof plugin === &apos;function&apos;) { plugin.apply(null, args) } installedPlugins.push(plugin) return this } 可以看到，在执行Vue.use()函数的时候，如果参数是函数则与运行参数，如果参数是个对象，有一个属性install是函数，则运行install函数。所以我们可以通过这个特性利用插件的形式注册全局组件。 在全局组件的目录下将所有组件利用install函数调用Vue.component()注册，在入口中使用vue.use()来执行。 本项目源码如下： main.js import commonComponents from &apos;./components/common&apos;; _.keys(commonComponents).map(k =&gt; { Vue.use(commonComponents[k]); }); 插件化： const commonComponents = { DropMenuDecorator : { install : (Vue) =&gt;{ Vue.component(&apos;DropMenuDecorator&apos;,DropMenuDecorator ); } }, DynamicForm : { install : (Vue) =&gt;{ Vue.component(&apos;DynamicForm&apos;,DynamicForm ); } }, .... } 利用Vue.use在入口文件注册全局组件，减少了代码量。 vue-router]]></content>
      <categories>
        <category>框架整理</category>
      </categories>
      <tags>
        <tag>-- vue -- moment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架（二）]]></title>
    <url>%2F2017%2F11%2F28%2F%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%2F%E4%B8%87%E8%BE%BE%E9%A2%84%E8%AD%A6%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MOCK mock的字面意思就叫模拟，mock技术就是用来模拟前端请求的后端返回。之前有使用过mock.js这个模块，但是在涉及list数据的情况下不是很好用。 本项目里使用了lowdb技术，Low-DB技术是一个基于Lo-Dash中间件的技术，他不依赖于nosql数据库。是一种纯json文本的数据库技术。 LowDB lowdb技术是一个基于lodash的小型数据库技术，在熟悉lodash用法的基础上，使用lowdb将毫无压力。 具体的用法忘记了可以去npm查找这个模块看一看，用法大致想下面的代码一样： const low = require(&apos;lowdb&apos;); const FileSync = require(&quot;lowdb/adapters/FileSync&quot;); const adapters = FileSync(&quot;mock.json&quot;); ;+ const db = low(adapters); /------到这里，lowdb已经被搭建起来了---------/ //写入基础数据 db.defaults({persons:[],master:{}}).write()； //写入数组 db.get(&apos;persons&apos;).push({name:&apos;clg&apos;}).write(); db.set(&apos;master.title&apos;,&apos;sb&apos;).write(); //这里的get、push、set都是lodash的函数，使用lodash函数最后接一个write就可以改写数据库 结合express使用 lowdb结合express使用可以完美模拟后端，通过遍历所有可能的接口，利用express构建中间件拦截对应的请求，在请求中使用lowdb进行数据操作，然后返回数据结果。只要写好了sql格式，任何请求都可以模拟。 本项目也采用了express+lowdb来实现模拟后台。代码如下 function mockData() { const tables = [ &apos;Entitymanager&apos;, &apos;Entityfield&apos;, &apos;Menu&apos;, &apos;ModuleEditor&apos;, &apos;I18n&apos;, &apos;App&apos;, ]; //init db var dbs = {}; //初始化db中数据种类 _.forEach(tables, (t) =&gt; _.assign(dbs, {[t]: []})) db.defaults(dbs).write(); db.defaults().forEach((m, v) =&gt; { tables.push(v); }).value(); //init uri try { tables.map(t =&gt; { log(`init ${t}`); //封装get方法 app.use(&apos;/mock/&apos; + t.toLowerCase() + &apos;/:id&apos;, function (req, res) { log(&quot;req.params.id=&quot; + req.params.id); if (req.method === &apos;GET&apos;) { const post = db.get(t) .find({id: _.parseInt(req.params.id)}) .value() res.send(success(post)) } }); //封装list方法 app.use(&apos;/mock/&apos; + t.toLowerCase(), function (req, res) { if (req.method === &apos;GET&apos;) { //从请求参数中解构出参数 let {sortOrder, limit, offset, sortField} = req.query; //除了这些参数以外的其他参数 let condition = _.omit(req.query, [&apos;sortOrder&apos;, &apos;limit&apos;, &apos;offset&apos;, &apos;sortField&apos;]) //获取数据集--包含数据的lodash对象 let value = db.get(t); let total = 0; //condition有内容 if (_.keys(condition).length != 0) { log(&apos;condition:&apos;, JSON.stringify(condition)) condition = _.mapValues(condition, function (m) { var reg = /^[0-9]*$/; if (reg.test(m)) return m * 1; else return m; }); condition = _.omit(condition,&apos;lang&apos;) value = value.filter(condition) } total = value.size(); //排序 if (sortField) { log(&apos;sortBy:&apos;, sortField) value = value.sortBy(sortField) } if (sortOrder &amp;&amp; (sortOrder === &apos;ascend&apos; || sortOrder === &apos;asc&apos;)) { log(&apos;sortOrder:&apos;, sortOrder); value = value.reverse() } if (limit &amp;&amp; offset) { log(&apos;limit:&apos;, limit) value = value.slice((offset - 1) * limit, offset * limit); res.send(success({ offset: _.parseInt(offset), total: total, list: value.value() })) } else { res.send(success(value.value())) } //封装 post方法 } else if (req.method === &apos;POST&apos;) { db.get(t) .push(req.body) .last() .assign({id: Date.now()}) .write() .then(post =&gt; res.send(success(post)))&apos;&apos; } else if (req.method === &apos;PUT&apos;) { db.get(t) .find({id: req.body.id}) .assign(req.body) .write() .then(post =&gt; res.send(success(post))) } else if (req.method === &apos;DELETE&apos;) { if (!req.body.id) { res.send(fail(&apos;not find id!&apos;)) } else if (_.isNumber(req.body.id)) { db.get(t) .remove({id: req.body.id}) .write() .then(post =&gt; res.send(success(post))) } else if (req.body.id === &apos;all&apos;) { db.get(t).remove(() =&gt; 1 === 1).write().then(post =&gt; res.send(success(post))) } else { let ids = req.body.id.split(&quot;,&quot;); db.get(t).remove((m) =&gt; { return ids.indexOf(m.id + &quot;&quot;) &gt; -1; }).write().then(post =&gt; res.send(success(post))) } } }); }); } catch (e) { console.error(e); } } 使用express+lowdb几乎可以完美模拟任何需要，而且开发迅速，可以前后端开发并行进行，是很有意义的技术。而且使用lowdb学习成本并不高，文档很全面。]]></content>
      <categories>
        <category>框架整理</category>
      </categories>
      <tags>
        <tag>-- lowdb -- express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架（一）“]]></title>
    <url>%2F2017%2F11%2F27%2F%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%2F%E4%B8%87%E8%BE%BE%E9%A2%84%E8%AD%A6%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86%EF%BC%88-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[項目介紹 这个项目由美国一监控公司的产品pagerduty定制而来，原版的pagerduty已经不能很好的兼容万达金融内部的所有系统，因此选择开发这一套新的pagerduty来满足内需。 项目架构采用传统的中途岛模式，前后端分离，前端采用webpack+vue为核心技术栈，后端采用springboot+微服务+feiclient来实现，数据库使用Mysql5.6。 前端架构 第一版架构使用react完成，采用react+webpack+redux+soga完成，由于万达要求，技术栈改为以vue为主，下面就vue为主的前端架构做总结： webpack基础配置 /* webpack.base.config.js 基础配置*/ const path = require(&apos;path&apos;); const webpack = require(&apos;webpack&apos;); const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;); module.exports = { entry: { main: &apos;./src/main&apos;, vendors: &apos;./src/vendors&apos; }, output: { path: path.join(__dirname, &apos;../dist&apos;) }, module: { rules: [{ test: /\.vue$/, loader: &apos;vue-loader&apos;, options: { loaders: { less: .ExtractTextPluginextract({ use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;, &apos;less-loader&apos;], fallback: &apos;vue-style-loader&apos; }), css: ExtractTextPlugin.extract({ use: [&apos;css-loader&apos;, &apos;autoprefixer-loader&apos;], fallback: &apos;vue-style-loader&apos; }) } } }, { test: /iview\/.*?js$/, loader: &apos;babel-loader&apos; }, { test: /\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/ }, { test: /\.css$/, use: ExtractTextPlugin.extract({ use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;], fallback: &apos;style-loader&apos; }) }, { test: /\.less/, use: ExtractTextPlugin.extract({ use: [&apos;autoprefixer-loader&apos;, &apos;less-loader&apos;], fallback: &apos;style-loader&apos; }) }, { test: /\.(gif|jpg|png)\??.*$/, loader: &apos;file-loader&apos;, options: { name: &apos;/assets/img/[hash].[ext]&apos;, } }, { test: /\.(html|tpl)$/, loader: &apos;html-loader&apos; } ] }, resolve: { extensions: [&apos;.js&apos;, &apos;.vue&apos;], alias: { &apos;vue&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@pages&apos;: path.join(__dirname, &apos;../src/components/pages&apos;), &apos;@common&apos;: path.join(__dirname, &apos;../src/components/common&apos;), &apos;@util&apos;: path.join(__dirname, &apos;../src/libs&apos;), } } }; 本地环境配置： /*webpack.dev.config.js*/ const webpack = require(&apos;webpack&apos;); const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;); const merge = require(&apos;webpack-merge&apos;); const webpackBaseConfig = require(&apos;./webpack.base.config.js&apos;); const fs = require(&apos;fs&apos;); const autoMergeJs = require(&apos;../scripts/autoMergeJs&apos;); const path = require(&apos;path&apos;); // fs.open(&apos;../src/config/env.js&apos;, &apos;w&apos;, function(err, fd) { // const buf = &apos;export default &quot;development&quot;;&apos;; // fs.write(fd, buf, 0, buf.length, 0, function(err, written, buffer) {}); // }); module.exports = merge(webpackBaseConfig, { devtool: &apos;#source-map&apos;, output: { publicPath: &apos;/dist/&apos;, filename: &apos;[name].js&apos;, chunkFilename: &apos;[name].chunk.js&apos; }, module: { rules: [ { test: /\.(woff|svg|eot|ttf)\??.*$/, loader: &apos;url-loader?limit=2048&apos; }, ] }, plugins: [ new autoMergeJs(), new ExtractTextPlugin({ filename: &apos;[name].css&apos;, allChunks: true }), new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendors&apos;, filename: &apos;vendors.js&apos; }), new HtmlWebpackPlugin({ title:&apos;Hedwig&apos;, filename: &apos;./index.html&apos;, template: &apos;./src/template/index.ejs&apos;, favicon: path.resolve(&apos;/assets/favicon.ico&apos;), inject: false }) ] }); 在基础配置里采用了重复第三方模块的统一打包：多入口vendors、ExtractTextPluging插件、HtmlWebpackPlugin、自定义webpack插件 多入口 由于将所有模块打包到一起之后文件的大小会以M记，对于一次文件请求来说太大，一般来说，会将同一功能模块的文件打包在一起，以多入口的方式利用CommonChunkPulgin来处理成单独的“&lt; script&gt;”标签进行插入。 进行多入口打包的规则总结如下： 打包粒度要合适，每一个模块的大小最好不要超过500kb 打包数目不要超过浏览器并发请求资源数，ie一般为4个，chrome一般为6个，多了就会导致请求 卡顿 利用留浏览器304缓存，公共部分代码应该都为静态资源 在打包上应该避免将层次较深的资源打包到入口中，应该做懒加载。 具体项目中表现如下： 第三方共用的库打一个包，比如vue全家桶 公共组件打一个包，比如弹窗组件、loading组件 项目通用的工具类打一个包 一个大的功能模块打一个包，一般而言，项目不会大到这种地步 每个功能模块的子页面进行异步加载。 本项目中，由于项目体积不大，所以只多出了一个第三方公共模块vendors，入口文件中配置了vendors入口： import Vue from &apos;vue&apos;; import iView from &apos;iview&apos;; import VueRouter from &apos;vue-router&apos;; import axios from &apos;axios&apos;; import Vuex from &apos;vuex&apos;; import echarts from &apos;echarts&apos;; import Cookies from &apos;js-cookie&apos;; import clipboard from &apos;clipboard&apos;; import html2canvas from &apos;html2canvas&apos;; import rasterizehtml from &apos;rasterizehtml&apos;; import store from &apos;store&apos;; 上面这些第三方模块被打包成vendor，利用CommonsChunkPlugin来处理，代码中有说明。 CommonsChunkPlugin是webpack插件，用来提取出公共模块进行打包，只在首页加载一次便缓存起来，不会再重复抓取。 ExtractTextPluging extract-text-webpack-plugin插件用来从bundle中提取出css作为一个公共的css文件。在webpack的配置文件中引用，在loader中设置额外的提取。 { test: /\.vue$/, loader: &apos;vue-loader&apos;, options: { loaders: { less: ExtractTextPlugin.extract({ use: [&apos;css-loader?minimize&apos;, &apos;autoprefixer-loader&apos;, &apos;less-loader&apos;], fallback: &apos;vue-style-loader&apos; }), css: ExtractTextPlugin.extract({ use: [&apos;css-loader&apos;, &apos;autoprefixer-loader&apos;], fallback: &apos;vue-style-loader&apos; }) } } } 定义use来确实使用什么来解析提取的内容，使用fallback来定义从什么中抽取文件。 HtmlWebpackPlugin html-webpack-plugin是用来生成HTML文件并且自动引用打包的文件。可以指定模板的位置，可以指定引用文件的位置，可以增加title，增加favicon等等，是一个服务于首页的插件。 自定义webpack插件 cpmpile和compilation 自定义webpack通常通过重写插件的apply方法，并且将webpack的compile作为参数传递进入方法。compile对象时webpack在编译启动时，将配置文件数据注入后生成的编译对象。 compilation是在文件发生变动时，webpack的一个代表发生变化的对象，他包含了各种变化的回调 function HelloWorldPlugin(){ } HelloWorldPlugin.prototype.apply = function(compile){ compile.plugin(&quot;emit&quot;,function(compilation,callback){ //这里做想要的操作，做完以后调用callback（）完成 callback(); }) } AutoMerage插件 本项目使用了自定义插件AutoMerage，功能是读取文件目录，自动生成对外导出文件。 /** * AutoMerage.js */ let fs = require(&apos;fs&apos;); let Handlebars = require(&apos;handlebars&apos;); let _ = require(&apos;lodash&apos;); let util = require(&apos;./util&apos;); function AutoMergeJs(options) { } AutoMergeJs.prototype.apply = function (compiler) { compiler.plugin(&apos;emit&apos;, function (compilation, callback) { function createIndex(src, targetFile) { //获取所有目录文件的名建明，除模板相关文件 let files = util.readFilesInDir(src, { prefix: &apos;.&apos;, excludeFiles: [&apos;index.vue&apos;, &apos;index.js&apos;, &apos;index.tpl&apos;], format: (f) =&gt; f.substring(0, _.lastIndexOf(f, &apos;.&apos;)) }); targetFile.forEach(f =&gt; { //获取模板文件 let data = fs.readFileSync(src + &apos;/&apos; + f.template, &apos;utf-8&apos;); const template = Handlebars.compile(data); //利用目录文件遍历模板生成文件 let result = template({ list: files }); try{ //获取原编译结束后的文件 let old = fs.readFileSync(src + &apos;/&apos; + f.target, &apos;utf-8&apos;); //如果和源文件不同，则将新的结果写入到文件中 if (old !== result) fs.writeFileSync(src + &apos;/&apos; + f.target, result); }catch(e){ fs.writeFileSync(src + &apos;/&apos; + f.target, result); } }); } let _targetFile = [{ template: &apos;index.tpl&apos;, target: &apos;index.js&apos;, }]; createIndex(&apos;./src/actions&apos;, _targetFile); createIndex(&apos;./src/components/pages&apos;, _targetFile); createIndex(&apos;./src/components/common&apos;, _targetFile); callback(); }); }; module.exports = AutoMergeJs; 进行模板文本操作的工具类 /** * util.js */ var fs = require(&quot;fs&quot;); //path模块，可以生产相对和绝对路径 var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); //读取文件存储数组 function readFilesInDir(dirUrl, option) { var fileArr = []; var {excludeFiles = []} = option; var {format = null} = option; var {prefix = &apos;&apos;} = option; //excludeFiles中包含file时返回false； function exclude(file) { return !_.includes(excludeFiles, file); } //获取文件数组 function readFile(readurl, name) { var name = name; //同步读取文件目录 let files = fs.readdirSync(readurl); files.forEach(function (filename) { //获取文件状态 let stats = fs.statSync(path.join(readurl, filename)); //如果是文件且不是index.vue/index.js/index.tpl，这三种文件要过滤掉 if (stats.isFile() &amp;&amp; exclude(filename)) { //options。format存在且是一个函数 if (!!option.format &amp;&amp; _.isFunction(option.format)) //获取文件名 filename = option.format(filename); var newUrl = name + &apos;/&apos; + filename; // ./filename fileArr.push({name: filename, fullName: newUrl}); //是子目录则递归处理 } else if (stats.isDirectory()) { var dirName = filename; readFile(path.join(readurl, filename), name + &apos;/&apos; + dirName); } }); } readFile(dirUrl, prefix); return _.chain(fileArr).filter(file =&gt; file.name &amp;&amp; file.name !== &apos;&apos;).sortBy((f) =&gt; f.fullName).value(); } module.exports = {readFilesInDir: readFilesInDir}; 这里的几个关键技术是Handlebars、fs、lodash。 Handlebars是一种模板技术，通过将数据和模板结合，在编译之后就可以自动生成文件。 index.tpl //Do not modify this file, it will be auto generated import vuexDecorator from &apos;../libs/vuexDecorator&apos;; {{#list}} import {{this.name}} from &apos;{{this.fullName}}&apos;; {{/list}} export default { {{#list}} {{this.name}}: vuexDecorator(&apos;{{this.name}}&apos;,{{this.name}}), {{/list}} } 编译模板： //获取模板文件 let data = fs.readFileSync(src + &apos;/&apos; + f.template, &apos;utf-8&apos;); const template = Handlebars.compile(data); //利用目录文件遍历模板生成文件 let result = template({ list: files }); 写回文件： fs.writeFileSync(src + &apos;/&apos; + f.target, result); 在对js使用按照这种方法就可以实现动态配置，减少代码量。 fs是nodejs内置的模块，可以做文件读写，这里有几个关键的函数： fs.readFileSync() 读取文件内容 fs.writeFileSync() 写入文件 fs.statSync() 获取文件状态，返回Stats类 stats.isFile() 是否是文件 stats.isDirectory() 是否是目录 fs.readdirSync() 读取文档目录结构 lodash是和underscore类似的函数式变成的库，提供了大量的实用的方法。]]></content>
      <categories>
        <category>框架整理</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F11%2F27%2Fvue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2F%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E3%80%81jq%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[title: 事件委托和jq事件委托 date: 2017-8-11 14:34:42 categories: 前端问题梳理 tags: 前端 事件委托 事件委托的概念要从js事件模型说起，js事件模型现代主流浏览器实现的都是DOM2级的时间模型，分为三个阶段： 事件捕获 处于事件 事件冒泡 事件委托的原理就是基于此。 由于事件捕获和冒泡的机制，点击在子元素上的事件，先在父元素进行捕获，然后到达子元素然后进行冒泡，冒泡到父元素。 这样，父元素就可以代理子元素的事件，通过event.target（子元素目标）和event.currentTraget（父元素目标）可以区分和获取父子元素进行DOM操作。这么写可以很好的优化事件。 jq事件委托 jq1.7以下使用live、delagate方法来绑定事件委托，jQuery1.7以上的同一采用on方法来绑定事件委托。 jqueryObject.on(&apos;click&apos;,&quot;p&quot;,handle) //将所有p元素的点击事件委托到jqueryObject上。 $(&quot;#div&quot;).on(&apos;click&apos;,&quot;span&quot;,function(){}); //将id为div的元素中的span的click事件委托到div上。 需要注意的是，focus和blur等少数事件不支持冒泡，不通过冒泡传递，因此不能使用事件委托。 使用相同形式的off函数来移除绑定的事件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[js Error详解]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2Fjs%20Error%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[不重要 JS的报错信息在某种程度上来说在代码里并不重要，js不像其他高级语言一样对于错误信息有强烈的规范化要求，一般而言，报错是为了业务需求而报错，浏览器端的js代码几乎不会有需要业务需求报错的时候，而更多的是在node中，可能有相关问题。 Error js错误类的基础是Error对象。构造函数里没有定义任何内容，Error实例被抛出以后，就只会有一个报错，事实上一旦报错就会直接从函数调用栈中被弹出，事件循环不会继续运行这个任务。 Error.prototype原型上定义了三个属性： constructor：构造函数 message：错误信息 name：错误名 当然不同的浏览器厂商也为此做了不同的额外属性： 对于 Microsoft，微软为IE扩充了： discription：错误描述 ，和message差不多 number：错误码 Mozilla这个为了终身对抗IE的组织也为fireFox扩充了一大堆内容 filename：错误文件名 lineNumber：行号 columnNumber：列号 stact：错误的堆栈 toSource()和toString() 其他错误类 在Error类的基础上，通过继承又封装了6个其他的错误构造函数。 EvalError eval执行环境产生的错误。与eval（）有关。 InternalError 这是个不标准的API，用来返回JS引擎内部的一些错误，比如递归太多等。 RangeError 数值或者变量超出了它的范围。 ReferenceError 引用错误，无效引用等 SyntaxError 在解析代码的过程中发生的语法错误。 其实就是语法错误。eval代码的解析执行也会导致语法错误。 TypeError 变量的类型不是预期类型时就会发生这个错误。 URIError 在调用encodeURI或者decodeURI时发生的错误，URI处理错误 错误类的继承方式 6大错误类是按照原型链继承的方式来实现继承的。]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深复制和浅复制]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2F%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[基础类型的值没有浅复制 基础类型的值不存在浅复制问题，基础类型的值都是按值访问的。 只有引用类型的值有浅复制，Object、function、Array都存在。 浅复制的几种情况 对引用类型直接采用赋值表达式赋给另一个对象。 var a = {name: &apos;cn&apos;} var b = a； b == a // true 引用类型的对象按引用访问，a和b指向同一个对象的引用。 Object.assign()等函数也是浅复制 深复制的办法 jquery.extend()方法。 JSON序列化，有缺陷，不能复制到原型值以及继承的值，不能复制函数。 通过for…in循环进行遍历，然后新建一个空对象进行赋值，for…in可以遍历出所有可枚举的属性以及集成的属性。]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的attributes和property的异同]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2Fjavascript%E7%9A%84attributes%E5%92%8Cproperty%E7%9A%84%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[javascript中attributes和property的异同? property用来保存DOM的特性，在javascript的DOM对象里其实是没有这个对象的。特性表示一个表单元素可能具有的一些特定属性，比如说id、class、name、value等，这些东西在创建DOM Element元素的时候就会自动创建在元素上，这些就是property。 attributes是用来保存元素的属性的，任何属性包括自定义属性都会在attributes中存储，attributes本质上是一个NodeNamedMap，一个类似于数组的解构，里面的属性元素为Attr结构，是一个次一级的节点对象。 两者只是在概念上有一些重叠，但是实际上，两者没有任何关系，改变任意一方都不会对对方有什么影响。 对应在jquery上，有attr和prop两个方法，这两者对应于attributes和property。老版本的DOM，可能是DOM2或者DOM3，把property设定为了attributes的一个子集，但是现在，经过测试，完全没有这回事，应该是已经修改过。]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 流体特性和BFC]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2FCSS%20%20BFC%2F</url>
    <content type="text"><![CDATA[块状元素的流体特性 html元素分为块级元素和内联元素，而块状元素在展示上具有流体特性，会像水一样自动流动填满整个空间，而内联元素则不会。 流体特性会被margin padding border等特性影响，也就是说流体特性 是针对于盒模型的content部分进行的。 BFC–块级格式化上下文 BFC元素的特点是：不管内部元素怎么翻江倒海，外部的相邻元素纹丝未动，不会影响到外部元素。 一个普通块级元素要变成BFC元素需要满足下面的某一个条件： overflow属性设定为 auto、scroll、hidden。 float属性不为none。 display属性为table-cell、 table-caption、inline-block中的一个。 position属性不是relative或者static。 一旦满足了任意一个情况，就会具有BFC属性。]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js无阻塞加载]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2Fjs%E6%97%A0%E9%98%BB%E5%A1%9E%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[js异步加载问题？ js无阻赛加载包括js下载和js编译执行两个部分。 解决方案： 使用defer或者async关键字来标明异步执行，这种情况下，脚本下载异步，脚本执行异步，在最早加载完界面的时候执行，onLoaded之前。defer和async的异同？ 使用动态创建Script标签的方式，同步加载，同步执行。具体依赖webkit，Geaco等支持的load函数，以及IE支持的onreadystate状态。异步下载：被当成DOM进行处理，直接开始下载，不阻塞后续执行；异步执行：本质上，下载脚本以后会形成一个下载完成的异步任务，在下载完成以后会立刻被推入宏任务队列，然后根据进入队列的先后顺序进行执行，是先下载完的先执行。 使用ajax动态获取填充，缺点在于被同源策略限制。 使用其他的基于上面方法的库，别人已经封装好了，可以直接拿来用]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[浏览器内核 浏览器内核是浏览器处理问题的中心，包括渲染引擎和js引擎，js引擎中就又我们熟悉的V8。 由于不同公司的市场份额利益，每个公司都自己开发1浏览器就有了不同的内核，主流浏览器包括IE、chrome、firefox等。 五大浏览器内核 Trident,也就是IE内核，捆绑在微软的windows中，腾讯的QQ浏览器、360浏览器等也是采用的IE内核，trident。 Gecko，代表作是火狐浏览器，Gecko是开源的。 Webkit，开源项目。chrome以前采用过chrome，以及Opera。 Presto，曾经是Opero浏览器的内核，但是opero在13年加入了谷歌阵营，所以弃用了。 Blink，谷歌和opera开发的浏览器，现在谷歌仍在使用。]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现继承的方式]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2Fjs%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[js实现继承的方式 js实现继承的方式目前我知道的大体可以分为两类： es5通过原型链来实现继承，具体有构造函数继承、原型继承、组合构造函数和原型继承、寄生继承。寄生组合继承。 es6使用class extend supper来实现继承 es5的继承方式 原型链 原型链是实现继承的主要手段，首先是解释几个概念： 构造函数：构造函数用来生成对象。 原型：每个构造函数都有一个原型，原型的constructor属性指向构造函数。 prototype：构造函数的prototype指针指向原型。 实例：通过new关键字生成的构造函数的实例。 proto：实例的 proto指针指向原型。 那么，什么是原型链呢？ 实现原型的方法是使用 proto来串联对象与被继承对象：将对象的原型赋值为被继承对象的实例。 这样，new 出来的对象的实例的 proto就会指向它对应的原型也就是被继承对象的实例，而被继承对象的实例的 proto又指向了被继承对象的原型，这样就可以把被继承对象构造函数里的属性和原型里的属性都继承过来。 一直重复这个过程形成的链就是原型链。 借用构造函数 原型链存在一个很致命的问题，继承的属性是共享的，一旦某一个实例修改了继承属性值，另一个实例中中的值也会被修改。 因此衍生了借用构造函数实现继承。 借用构造函数就是在构造函数中使用call来调用被继承对象构造函数，这样，每一个构造函数实例都会拥有唯一的一份数据，互不影响。 但是这样又导致了属性方法不能共用的问题。 组合继承 解决借用构造函数问题的方式是组合继承，和创建对象中的集合模式一样，这可以说是可以很好投入使用的一种成熟的模式。 组合继承，组合使用原型链和构造函数。 function A(property){ this.property = property } A.prototype.method = function(){ } function B(property){ A.call(this,property) } B.prototype = new A(); var C = new B(&quot;hello&quot;); C.property // hello var D = new B(&quot;world&quot;); D.property // world C.property = &quot;1&quot;; D.property // world; 组合继承使用构造函数模式来继承不应共享的数据和方法，使用原型链来继承共用的属性和方法。 原型继承 原型继承也就是es5引入的函数Object.create(Object，options)。 Object.create()函数的原理是在函数内部创建一个函数，并且将该函数的原型赋值为传入对象，然后返回这个函数的实例，这种原型继承的方式依然存在每个实例都共享属性的问题。 寄生式继承 寄生式继承是在原型继承的基础上展开的，在原型继承的基础上，在函数内部继续扩充要被返回的实例。 缺点一样是每个实例共享属性。不能复用 组合寄生式继承 组合继承虽然已经比较完善，但是依然有不够精简的问题，它调用了两次构造函数，组合继承式寄生就是为了解决这个问题出现的。 代码原理在于，使用寄生函数来替代原型赋值那一步，寄生函数实现了对原型的赋值以及对构造函数的重写。 es6的继承方式 使用class、extends、supper来实现继承。 class A extends B{ constructor(x,y){ supper(); this.x = x; this.y = y; } }]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD和CMD的区别]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2FAMD%E5%92%8CCMD%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[AMD 和CMD 和 CommonJS的不同？ 前端模块化经过了刀耕火种一步步前进，最后形成了利用函数自执行的闭包的方式来创建模块，基于这个原理，nodeJS中形成了第一套模块化的方案CommonJS。 commonJS简单的定义了module.export 和require的封装和加载方式 ，并且由于是服务器所以不需要要考虑异步加载的问题，只需要一直同步加载就可以完成任务。 这一套模块化规范在浏览器是行不通的，浏览器是需要异步加载的，在浏览器端的，，模块化方案规范分为两种，一种是AMD，一种是CMD。 AMD规范对应于RequireJS。 requireJS使用define(id,[dependency],callback())定义模块，在callback()中实现具体的模块功能。 使用require([module],callback())来加载模块。 requireJs是异步加载模块的。 CMD规范则对应于SeaJS。 seaJS使用define(id,[dep],factory())来生成，和AMD的define区别在于，seaJS推崇一个模块一个文件的写法，在factory工厂函数里进行加载模块。 使用require(id)函数来获取模块 使用seajs.use(id,calback())来使用模块 兼容AMD的写法。 区别在于： AMD是前置依赖，在定义模块的时候就要声明依赖 CMD是就近依赖，只有在用到了某个模块的时候才去加载模块。 两者都是异步下载模块，但两者的脚本执行时间是不同的，requireJS会提前执行脚本会在加载完成以后立刻push到任务队列进行执行，而SeaJS在下载完成以后没有执行代码，而是保留不发，在调用require的时候才会真正执行，相当于把下载的代码直接切在require的位置，进行同步执行，一个是下载完成后把代码作为异步任务放到script宏任务队列中，一个时下载完成以后不push，而是在执行的时候同步执行代码，可能用js的事件循环机制来理解有些不同，但是道理是这个道理。]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js DOM事件模型]]></title>
    <url>%2F2017%2F08%2F11%2Fproblems%2Fjs%20%20DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[IE这个傻叉 像IE这么垃圾的浏览器总有一天会拖垮微软的windows系统，仗着自己和windows绑定的大市场份额，强行搞事，什么都有它一腿，什么标准碰到它都要搞另一套。 好好的事件模型，大家都按这个做不就好了，非要搞特殊，结果就是我非要花时间来总结一下这些用法的不同。 DOM事件 浏览器事件模型是按照赵观察者模式来执行的，为DOM节点元素创建事件监听器，监听浏览器事件，相应执行。 浏览器事件在js事件循环中处于微任务队列micro-tasks的末尾，回顾一下事件循环任务队列相关知识点。 一个js线程有一个函数执行栈站、一个事件循环、多个任务队列 任务队列分为宏任务队列mxcro-tasks和微任务队列micro-tasks 宏任务的先后顺序：script（栈运行代码）&gt;setTimeout/setInteval &gt;setImmediate(nodejs)&gt;I/O&gt;UI Rendering。 微任务的先后顺序：process.nextTrick&gt;promise&gt;DOM事件。 事件循环从script开始运行，之后运行所有微任务，第一次循环结束，第二次循环按照宏任务队列的顺序执行，执行完一条宏任务队列，就去执行所有微任务，然后又回头按照顺序执行宏任务队列，然后执行微任务，这个过程持续进行直到清空宏任务和微任务队列，第二次循环结束。 结合实践循环，DOM事件在微任务队列中的DOM实践队列中。具体执行顺序应该是： 事件被触发 浏览器监听器监听到事件 将相应事件放置到DOM任务队列中 事件循环执行到DOM微任务队列的时候执行这个相应事件。 事件捕获和事件冒泡 在DOM0级事件的年代，由于标准的不同意，浏览器厂商有了两种不同的DOM事件标准，一个叫事件捕获，就是从最外层元素开始捕获事件，然后执行，然后向下捕获然后执行，然后向下捕获然后执行。IE采用了事件冒泡，从最下层开始先执行，然后向上冒泡，然后执行，然后冒泡。 两种思路没有谁是谁非。但是IE最后赢了，因为DOM0级事件的依然以事件冒泡的方式存在于浏览器中，而其他浏览器选择了支持DOM2.0的标准。 DOM0级规定使用on+’type’的方式来绑定事件，注意，此时IE9以下是不支持这一套的，它使用的另一套实现事件冒泡的机制。 DOM2.0划分由ie9开始，IE8以上的浏览器以及其他浏览器都支持DOM2.0的事件模型标准。 DOM2.0规定，同时使用事件捕获和事件冒泡，一个DOM2.0事件分为三个阶段： 事件捕获 处于事件 事件冒泡 DOM2规定使用addEventListener和removeEventListener来绑定和删除事件，使用第三个参数来规定在哪一个阶段进行时间执行。 IE9以前的事件机制 IE9以前采用attachEvent()和detachEvent()来绑定和注销事件。和DOM0级一样，都是默认在冒泡阶段进行事件执行。现在也支持 IE9以后的事件机制 IE9以后按照DOM2.0的规范进行事件模型，前面有说明 IE中的event对象 IE中的event对象和在DOM中不一样，在DOM中event是作为参数传递进事件执行函数，但是在IE中，event同时还作为window的对象存在，并且会在每次事件响应的时候刷新window.event。 在DOM中使用stopPropagation来阻止冒泡，使用preventDefault来阻止默认事件，使用event.target来获取事件目标。 在IE中使用event.returnValue = false来阻止默认事件，使用event.SrcElement来获取目标事件]]></content>
      <categories>
        <category>前端问题梳理</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件循环机制（二）]]></title>
    <url>%2F2017%2F08%2F02%2Fs%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88v8%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件循环的另一种解释 jsvascript是单线程高级脚本语言，每个线程拥有唯一的一个事件循环。 jsvascript代码在执行过程中，除了通过函数调用栈来解决函数执行顺序外，还依靠任务队列来搞定另外一些代码的执行顺序。 一个线程中，函数调用栈是唯一的，事件循环是唯一的，任务队列可以有多个。 任务队列又分为mocro-tasks（宏任务）和（micro-tasks）微任务，在最新的标准中也被称为tasks和jobs 宏任务mocro-tasks包括srcipt（整体代码）、setTimeout、 setInterval、 setImmediate、I/O、UI renering（页面渲染）。 微任务micro-tasks包括process.nextTrick、Promise、Mutation Observer（HTML5新特性）以及其他DOM事件 setTimeout、Promise、DOM事件等被称为任务源，而进入任务队列的是他们指定的具体执行的任务。 setTimeout作为一个任务分发器，这个函数是会立即执行的，而他所要分发的任务是它的第一个参数，才会延迟执行。 来自不同任务源的任务会进入不同的任务队列，setTimeout和setInterval是同一个任务源。 不同任务源的执行有先后顺序。 宏任务：script &gt; setTimeout/setInterval &gt; setImmediate &gt;I/O &gt; UI rendering. 微任务：process.nextTrick() &gt; Promise &gt;DOM事件 事件循环的顺序决定了javascript代码的执行顺序，事件循环从宏任务script开始执行，执行过程中遇到任务源就会分发对应的任务到任务队列，script全局代码运行完毕并退出函数调用栈，然后执行所有的微任务micro-tasks，第一次循环结束。第二次循环从宏任务开始，根据宏任务队列的先后顺序，执行完一条任务队列后执行，执行所有的微任务micro-tasks，然后回到宏任务执行下一个宏任务队列，之后执行所有的微任务队列事件，循环直到所有任务队列都为空，此时第二次事件循环结束。 这里不准备结合例子展开了。 setTimeout定时函数的原理依然摸不清楚 但是有一点可以肯定：定时器函数是在定时时间结束后才将定时器函数放入宏队列。 所以就当是运行setTimeout函数的时候先休眠延迟时间，然后把回调事件发送到事件队列。 补充（17-08-02） 之前一直忽略了一个细节，那就是setTimeout函数是DOM API的东西，属于浏览器定时器，想到这里就瞬间想通了这个问题。 浏览器本身是多线程的。 浏览器线程有4种： javascript引擎 GUI页面渲染 浏览器事件触发线程 http请求线程 其中，前三个线程是常驻线程，http线程请求完成以后就会close。 这四个线程这怎么互相协作的呢？ &nbsp;&nbsp;&nbsp;浏览器最重要的线程就是javascript引擎线程，其他的线程都是借助javascript引擎线程的事件循环机制来执行的。 GUI页面渲染线程，在需要渲染页面的时候就会给javascript宏任务中队列中添加一个事件，利用事件循环来执行。 http请求线程，在完成http请求以后将请求完成的回调事件添加到任务列表中。 浏览器事件触发线程，在触发浏览器事件，比如点击、界面缩放、滚动等事件时，就会将对应的回调函数事件添加在宏任务队列中，利用事件循环来进行， javascript引擎线程是所有线程的核心中枢，是师执行者，其他的几个线程都是消息捕获的执行者和消息分发的分配者。 &nbsp;&nbsp;&nbsp;理解了这些就不难理解setTimeout的时间循环机制。javascript的任务队列中的任务并不是全部由它自己分发的，更多的是浏览器的其他线程分发的。setTimeout事件就是由浏览器事件触发线程分发。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件循环机制（一）]]></title>
    <url>%2F2017%2F07%2F09%2Fjs%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88v8%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题 &nbsp;&nbsp;对于js事件循环机自会的理解不清楚，经常导致一些代码执行顺序上的混乱，js事件循环机制决定了代码的执行顺序，下面将对事件循环机制的规则进行总结。 &nbsp;&nbsp;自己写的博客不是为了写教程，更多的个人总结，我总喜欢带入第三人的角度去写这些东西 事件循环 &nbsp;&nbsp; 什么是js事件循环呢 我在网上看到的博文，我也不知道是否是完全正确的，阮一峰的博文在解释事件循环机制的时候只讲到时间循环的概念，简书签约作者波同学的博文更深一层的讲解了事件循环的执行规则，我暂时也不能确认哪些是正确的，哪些是错误的，后面的工作学习，我自己再慢慢总结吧。 阮一峰的博文解释 实际上，我对阮一峰的博文还是有些怀疑的，写得很混乱也不清晰。反而波同学的相对写得清楚一些。 为什么js是单线程？ &nbsp;&nbsp;js作为单线程的设计是事出有因的，其他语言大多都有设计多线程来满足并发需求。但是js没有，究其根本也正是因为js某种程度上不需要多线程。js语言本质上是浏览器的脚本语言，js固然可以进行逻辑业务运算，但是最后的目的还是为了控制界面展示，操作DOM。而操作DOM是不能兼容多线程的，比如一个线程修改了DOM节点，一个线程删除了DOM节点，这种矛盾逻辑作为页面体现是不可取的，因此js只能是单线程语言，现在是，以后也是。 &nbsp;&nbsp;HTML5的新特性web Worker是js在多线程的尝试，但是也有主线程和子线程的区别，浏览器js线程是主线程，能完全控制web Worker线程，web worker线程也不能操作DOM，只能进行业务逻辑运算。 什么是任务队列？ &nbsp;&nbsp;js作为单线程语言，就意味着任务的执行必须排队，和java等语言一样，单一线程的执行任务只能排队进行。而这个队列就是j任务队列。 &nbsp;&nbsp;js的任务队列于qianww语言不通，java由于支持多线程，所以并不支持异步操作，异步操作完全由多线程完成。js则不行，单线程同步运行会导致线程阻塞，比如在进行IO操作的时候，一个ajax请求，已经请求到了数据，但是由于要进行io操作需要延迟执行，这就会导致阻塞。 &nbsp;&nbsp;因此js有了异步任务这个概念，将同步任务和异步任务分开来处理，同步任务在主线程中处理，js主线程使用函数调用栈来处理任务运行，同步任务被直接分配到函数调用栈也就是主线程里运行，异步任务则被分配到异步任务队列，而异步任务队列里的任务通知主线程：“我可以执行了”，此时才会进入函数调用栈执行。 &nbsp;&nbsp;这个异步任务的任务队列就是js的任务队列。 什么是事件循环？ &nbsp;&nbsp;任务队列就是一个事件队列，或者说消息队列，这个事件指的是异步操作已经完成的事件，异步操作已经完成时就会在异步任务队列里新增一条事件完成的回调事件。IO操作完成以后就会在任务队列里增加一天IO操作已经完成的回调事件。 &nbsp;&nbsp;任务队列的事件包括：IO、DOM事件、setTimeout等指定了回调函数的任务。 &nbsp;&nbsp;主线程在同步任务执行完毕后会读取异步任务队列，事件队列是一个先进先出的队列。先进入的异步事件会优先执行。 &nbsp;&nbsp;对于setTimeout和setInterval定时函数是怎么分配分配任务到任务队列的呢，阮一峰的博客里说定时器事件会在主线程最早空闲的时候执行，在读取定时器事件时会检查执行延迟时间，时间到了才能进入主线程，这里还是没有解释清楚，延迟时间是怎么处理的。 这是个死循环 &nbsp;&nbsp;我去查了MDN，MDN上关于定时器是这么说的： 调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间。 MDN的意思是会延迟给定时间后将讲事件放入队列。MDN该市不会有错的，也可以想到肯定有一个东西把异步事件分配到异步队列，这个东西还具有定时延迟的问题，但是这是个死循环，一个已经具备延迟执行能力的东西把异步事件分配到异步队列，那这个东西又是怎么实现延迟执行能力的呢？ 晕]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Symbol]]></title>
    <url>%2F2017%2F07%2F09%2Fes6%E6%80%BB%E7%BB%93%2Fes6-Symbol%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;现代前端编写js代码ed时候，经常要使用来自其他源的对象，有时候我们要给对象扩充属性方法，但是es5按照名称来区分属性的方式会很容易导致属性名冲突，es6引入了Symbol基础类型来解决这个问题，使用Symbol创建的属性名是唯一的，永远不会和其他属性名冲突 Symbol是es新的基础类型之一 &nbsp;&nbsp;以前es有5种基本类型，Undefined、Null、String、Number、Boolean，一种复杂类型Object。 &nbsp;&nbsp;现在引入了新的基础类型Symbol。 var a = Symbol(); typeof(a) // symbol &nbsp;&nbsp;typeof也有了新的返回值。这里有另一个知识点，以前typeof不管面对什么对象都会有返回值，不会报错，未定义的变量会返回undefined。但是在es6里，typeof在面对未声明的let对象的时候，会直接报错。 Symbol的使用 创建Symbol对象 &nbsp;&nbsp;Symbol是用来创建对象的唯一属性的，由于Symbol是基础类型的不是复杂类型，因此不能使用new关键字来创建，而是直接使用构造函数创建。 var s = { size: 0 }; var name = Symbol(&apos;cn&apos;); s[name] = 1; console.log(s) //[ size: 0, Symbol(cn): 1 ] console.log(s.size) // 0 console.log(s.notExist) // undefined console.log(s[name]) // 1 console.log(s.name)// undefined for(var ele in s){ console.log(ele) } // size var a = Object.getOwnPropertySymbols(s); console.log(a); // [Symbol(cn)] var des = Object.getOwnProperyDescriptor(s,name) console.log(des) // {value: 1, writable: true, enumerable: true, configurable: true} &nbsp;&nbsp;上面的代码说明了Symbol的用法。 Symbol是基本类型，创建对象的时候使用Symbol()，而不是new Symbol() Symbol(“test”)构造函数的参数是Symbol的key，可以填入任意值，但是一般也要求填入有意义的，如果填入一个对象就会变成Symbol([object Object]),key其实是调用了toString()方法。 使用[]将Symbol值作为属性添加给对象，也是用[]来访问，不能使用“.”,点号是普通访问方法。 普通的遍历方法遍历不到Symbol属性，需要使用特殊的函数Object.getOwnPropertyDescriptor()来获取。 通过查看Symbol属性的特性，发现枚举属性enumerable为true，这证明，不可被遍历的实现机制并不是利用了属性的枚举特性。 Symbol的登记 &nbsp;&nbsp;Symbol其实是一个登记策略，在当前环境中登记一个值，每次调用构造函数就会登记一个值。 &nbsp;&nbsp;但是有时候并不需要每次都登记同一个值，因此有了两个相关的函数。 Symbol.for() &nbsp;&nbsp;Symbol.for(key)函数会查找当前环境是否登记了给定key的Symbol值，没有则会登记并且调用构造函数创建一个新的Symbol值，有则返回这个Symbol值。 Symbol.keyFor() Symbol.for(key)函数会查找当前环境是否登记了给定key的Symbol值，没有则会返回undefined，有则返回这个Symbol值。 &nbsp;&nbsp;symbol值是否登记和是否有Simbol值是两个不冲突的概念。 Symbol内置了一堆Symbol值， &nbsp;&nbsp;es6在某些功能的实现中，使用了这些内置的值。这些值用到了再去记忆吧。]]></content>
      <categories>
        <category>es6总结</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-对象扩展]]></title>
    <url>%2F2017%2F07%2F08%2Fes6%E6%80%BB%E7%BB%93%2Fes6%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[基础回顾 &nbsp;&nbsp;在js高级程序设计中已经知道了关于对象的一些定义和特性，对象是无序的属性的集合。 对象的属性和分为数据属性和访问器属性。 数据特性有value、configurable（能否被配置除）、writable（是否只读）、enumerable（是否可以被枚举遍历出来） 访问器特性有get、set、configurable、enumerable 获取特性的函数Object.getOwnPropertyDescriptor()、定义属性特性的函数Object.defineProperty()和Object.defineProperties() 一旦一个属性已经修改了configurable特性，被设定为false不可配置以后，就不能再次被修改除value外的其他属性了。 创建对象的发展历史：工厂模式-》构造函数模式-》原型模式-》组合使用构造函数和原型模式-》动态圆形模式-》计生/稳妥构造函数模式 原型、prototype属性、对象实例实例、构造函数、 proto属性之间的关系：对象的prototype指向对象的原型，对象的实例的 proto属性指向对象的原型，原型的constructor属性指向对象的构造函数。 函数的继承就是利用了原型链的原理，将对象的实例的原型赋值为被继承函数。 这些对象的知识点看起来不多，但是每一条都展开确实还是要花费好一些时间。只是，原型相关的知识现在越来越用不到了，不论是继承还是封装对象，es6里都进行了扩展。有时候真觉得花的这么些时间来理解吃透原型究竟有多少用。 属性的简写 &nbsp;&nbsp;es6支持对属性名进行简写，就像解构里的模式一样，可以使用模式简写的方式来简写对象属性，对于属性方法，也可以省略掉function关键字。确实是很好用的简写方式，节省了大量冗余代码。 Object.is()函数 &nbsp;&nbsp;传统的判断上是否相等函数有一定的漏洞，比如-0不等于+0，NaN等于NaN，但是其实正确结果是相反的，es6使用了新的算法来进行全等判断，比===更加有效。 Object.assign()函数 &nbsp;&nbsp;Object.assign(target,source)函数会将source对象中的所有可枚举属性复制到target对象中，并且会覆盖同名的对象。 &nbsp;&nbsp;这个对象复制的方法并不是深复制，在面对可枚举属性是对象的时候，只是进行了浅复制，复制了引用地址。对于这一点要格外小心 属性的遍历 &nbsp;&nbsp;属性石头可被遍历和它的enumerable属性有关，若是enumerable属性为false不可被枚举，此时使用for in就不能遍历该对象，这里在总结列举一下遍历对象的方式： for in：会遍历出自身的可枚举属性以及继承的可枚举属性 for of：会遍历出所有自身的可枚举属性 Object.keys()/values()/entries()：自身的可枚举属性 JSON.stringify()：只会串行化自身的可枚举属性 Object.assign()：可枚举的自身属性 Reflect.enumerate()：和for in 一样 对象扩展运算符 &nbsp;&nbsp;也可以对对象使用扩展运算符 … 。有下面两种用法。 解构赋值的时候使用…进行扩展 复制对象]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js递归的一个问题]]></title>
    <url>%2F2017%2F07%2F07%2Fes6%E6%80%BB%E7%BB%93%2F%E5%85%B3%E4%BA%8Ejs%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发现的两个递归问题 之前学习了es6递归的尾调用优化了，刚好在codewars刷题的时候就遇到了一个判断任意数是否是平方数的问题，正好利用递归来完成这个题目，原来的代码如下： var isSquare = function(n){ function square(index = 0,n){ var res = index*index; if(res === n){ return true; }else if(res &gt; n){ return false; } index++; return square(index,n) //这里如果不用return来调用递归就得不到正常的返回值。 } return square(0,n); } 这里有一个小细节，在递归时如果想要递归结果返回某个值，那么在递归调用函数的时候必须使用return，很好理解，被调用的时候返回的只是一个数值，并没有在外层函数中返回。 内存溢出 递归很容易导致内存溢出，上面的代码在n足够大的时候就会导致内存溢出，原因在于每次递归函数调用都会创建执行上下文，而js线程被分配的栈空间是有限的，每个执行上下文window分配为1M，在浏览器不支持尾调用优化的情况下，递归数量次数一旦过多就会内存溢出 在没有尾调用优化的情况下应该少用递归，尽量少用for循环。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-函数扩展（二）]]></title>
    <url>%2F2017%2F07%2F06%2Fes6%E6%80%BB%E7%BB%93%2F%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[箭头函数 箭头函数大大的简化了函数的写法，： var a = x =&gt; x*x; 箭头函数省去了function声明，省略了参数的写法，省略了返回的写法，有下面几个规则： 没有或者有多个参数，需要使用（）将参数包裹起来，只有一个参数则不用 如果箭头函数直接返回一个基础类型的值，则不需要使用{}，如果直接返回一个对象，那么需要使用（）括起来 箭头函数的函数体按照传统函数的写法使用{}括起来是永远没有错的， 如果函数体不只有一行代码，则需要使用{}括起来 箭头函数的特性： 箭头函数在创建执行上下文的时候有两个特性，确认this指向时直接指向上层函数的this，创建变量对象的时候回跳过arguments对象的创建。因此，箭头函数会绑定this对象，并且，无法使用arguments对象。 不能使用new关键字，箭头函数没有构造函数 不能使用yield命令，箭头函数不能用作generator函数。 函数绑定 就像箭头函数强行绑定了this一样，es7有了一条用来绑定函数的关键字提案天，而且babel也支持转化。 es7使用::来作为绑定obj1::obj2.sayName()会将sayName函数绑定到obj1对象上。虽然没有看出来到底有啥用，不过确实要好写一些。 尾调用优化 &nbsp;&nbsp;在函数的return语句里直接返回函数叫做尾调用，而被返回的函数在没有使用父函数的和参数变量有关的变量的情况下，呗返回函数会替换掉父函数的函数调用栈的情况叫做尾调用优化。 这种情况下可以极大的减少内存消耗，因此要尽量高些递归变量的写法，做到尾调用优化。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 目前es6支持尾调用优化，这将去掉一些不必要的闭包内存消耗。]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-函数扩展（一）]]></title>
    <url>%2F2017%2F07%2F05%2Fes6%E6%80%BB%E7%BB%93%2F%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数默认值 &nbsp;&nbsp;es5是不支持默认函数值的，在以前要实现默认函数值只能够通过 y = y||&apos;dadasd&apos; 这样的方法，而es6支持了函数默认值。 &nbsp;&nbsp;函数默认值的触发条件为undefined，只有在参数为undefined的时候才会默认赋值，参数为null或者false等值时不会默认赋值 函数默认值和结构赋值结合使用 &nbsp;&nbsp;函数默认值可以和解构赋值结合使用，需要弄清楚的规则只有一条： 1. 函数接受到参数的时候先判断参数是否是undefined，如果是，触发默认值，如果不是，则由传入参数进行解构赋值 2. 进行解构赋值的时候，如果解构得到的结果是undefined，则对被赋值对象赋予默认值 函数默认值的位置 &nbsp;&nbsp;函数的默认值只有在末尾的时候可以省略不谢，这时默认会传入undefined，而默认值如果不在末尾则不能省略不写，如果实在不能复制，也要传入一个undefined。 length属性失效 &nbsp;&nbsp;length会在读取到默认参数时失效。 在没有默认参数时，函数的length属性会得到函数参数的个数 在有默认参数时，函数的length属性会从设置默认参数的参数位置开始失效。 默认参数的作用域 &nbsp;&nbsp;函数的默认参数也有作用域。这里的作用域单凭函数代码很难判断： let x = 1; function f(y = x) { var x = 2;// let x =2 结果一样 console.log(y); } f()//1 在思考了这个例子以后我得出了一个结论： 默认参数作用域和传统作用域一样，先是函数作用域，然后是外部作用域。 但是这个结论的理解对js原理要有一定的理解，首先，什么是作用域？ 作用域是一套规则，创建执行上下文的时候就会创造作用域，js是词法作用域。 它规定了查找变量的路径和方式，也就是先在自己内部找，找不到再去外部找 默认参数在进行变量查找的时候就会按照作用域规则进行查找 然后要理解，默认参数的运行时机，它是什么时候运行，什么时候完成赋值？ 参数定义于赋值站在创建变量对象的第一步完成，前面提到过，先完成arguments 对象的创建与赋值，然后针对var和函数声明进行提前声明。 然而在默认参数进行赋值的时候函数内部的变量和函数其实还没有被初始化。 因此其实默认参数的作用域是不包括自己的， 狭义上可以这么理解 所以最后得到结论，默认参数的变量赋值是不参考内部作用域的。内部作用域找不到非参数变量，像y=x这种赋值，x只能去外部作用域找。 一个问题，let究竟有没有变量提升？ 在知乎上看到这个专栏，虽然对使用let没有影响，但对理解它有帮助，let也是有变量提升的，只是这个变量提升与我们传统的理解有些不同，我们熟悉的是声明提升，也就是把函数声明提升，还有一种提升是创建提升，在let变量没有被声明提升这是肯定的，但是js对它进行了创建提升，一个变量是先被创建，然后被声明，let声明只有创建提升，没有变量提升，所以在重复声明let的时候，可以提前报错错误，is already been decleared，js不允许重复创建，但是它允许重复声明。 可能莫名其妙看到这里的人已经乱了。。。。。但是我不准备花时间把这个不重要的深度知识点详细说一遍，想看的可以自己去看知乎的这篇专栏吧 https://zhuanlan.zhihu.com/p/28140450 rest参数写法 … &nbsp;&nbsp;es6支持使用rest参数的方式来获取多余的参数，rest会将参数扩展成一个数组，可以不再使用arguments对象，但是rest参数不能放在参数中间，只能坐在最后一个 扩展运算符 … &nbsp;&nbsp;rest参数和扩展运算符在形式上是一样的，但是作用完全相反，扩展运算符是用来将数组或者类似数组的具有iterable接口的对象转换成单个的元素。 扩展运算符使用场景很多，可以扩展字符串成为数组改进apply，可以改进apply函数参数的写法，可以和解构结合使用获取数组内容。 name属性 &nbsp;&nbsp;函数的name属性指向函数的名称。 对于函数声明的函数对象，name指向函数名，对于对象字面量声明的匿名函数，es5中name属性为空的字符串‘’，而es6中为对象名。 bind函数绑定使用的函数的名称前面都要加上bound。]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-数组扩展]]></title>
    <url>%2F2017%2F07%2F04%2Fes6%E6%80%BB%E7%BB%93%2Fes6%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;数组不管在那个语言里都是很重要的一种数据类型，数组的使用广泛让怎么合理高效率的使用它成为一个问题，我目前遇到的问题主要集中两个部分： 空间、时间复杂度：滥用数组，动不动就新建数组，针对存储列表类数据向来是直接使用数组来操作。也不怎么考虑事件复杂度，大多数时候会做多层遍历，结合起来很容易写出低质量的代码， 数组复制，在需要复制数组数据的时候面对复杂数据类型，有些复制做起来完全是无效的，或者就是增大空间复杂度。 &nbsp;&nbsp;我的编码经历来说，一段处理业务逻辑的代码很少有不用到数组或者说json这种这些数据结构的，对于数组、对象、json这些数据类型的操作要考虑清楚再动手敲代码 &nbsp;&nbsp;es6对数组的扩展一定程度上解决了一些问题 新的扩展 &nbsp;&nbsp;新的扩展主要集中于数组的生成、复制，填充，查找，遍历上 生成： Array.from()：可以将所有可遍历的类似数组的对象转化为数组，也就是有有iterable遍历接口的对象，进一步可以理解为只要是有length属性就可以转化，但是不是数值的length会被转化为空的数组[]。这样在这些类似数组的对象就可以使用数组遍历方法进行遍历，例如arguments对象，它并不是一个数组，不可以使用foreach等方法。 Array.of():扩展了数组的构造函数 复制：原先的数组可以使用concat、slicee函数来进行赋复制 填充：es5原有一个splice函数可以进行删除和新增，es6扩充了一个copyWith函数来将数组的某一个连续元素赋值到另一个位置。还有fill（）函数可用来填充数组 查找：es6扩充了find（）和findIndex（）函数来查找数组元素，includes（）函数可以用来判断数组是否包含某个元素 遍历，es6中，实现了iterable接口的对象都可以使用新的遍历函数进行遍历：entries（）和value（），结合keys()作为三个遍历函数。 关于遍历还有一个要注意的问题就是，传统的遍历方法，every、some、map、forEach在遍历时都会一定程度上忽略空的数组元素，map会直接返回一个空元素，而es6扩展的数组方法在生成数组时就会将空元素解析为undefined，并且在使用for。。。of遍历时也会遍历undefined元素]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-字符串扩展]]></title>
    <url>%2F2017%2F07%2F03%2Fes6%E6%80%BB%E7%BB%93%2Fes6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;es6很大程度上是对es5的扩展，完全向下兼容，并且扩展出新特性。 新特性 &nbsp;&nbsp;es6在字符串上增加了的新特性有一下面这几种特性。 对unicode字符的进一步支持 includes()、startsWith()、endsWith()函数用来增强indexOf()能力 repeat()、padStart()、padEnd()函数用来充填字符串 字符串模板和标签模板 unicode&nbsp;&nbsp;unicode的部分没能深入进去了解，javasccript内部使用utf-16来存储，首先unicode是一种能囊括全世界的文字符号的一种编码方式，每一个字符都有一个码点，而utf-8以及gbk以及utf-16等都是针对unicode的进一步汉字转码。 &nbsp;&nbsp;es5的汉字字符串很有可能并不只是占有一个32位的utf-16字符，很可能会超过32位，这个时候就会用两个utf-16码点来表示字符串，此时，length就会变成2，哪怕只是一个汉字，这是有问题的，es6扩充了一系列函数来解决这个问题。 字符串模板 &nbsp;&nbsp;字符串的重点扩展在于字符串模板，字符串模板简化了使用js拼写html内容，在模板内使用${}就可以嵌入变量，在以前只能通过jquery的tmpl等类似的插件才能实现。 &nbsp;&nbsp;而在字符串模板上进一步的标签模板则可以简化或者说扩充一种编写函数的新方式，标签模板作为参数传给函数，函数接受到的参数会有两部分，第一部分是字符串模板的静态部分被${}分隔开，以数组的方式传入，第二部分就是${}部分的内容，作为单个的参数传入。 &nbsp;&nbsp;标签模板有两个强大的作用，一个是过滤HTML字符串，可以过滤掉一些不合法的内容，一个是用来做国际化，可以把需要国际化的部分使用${}变量表示，然后使用国际化转义来重新写入字符串]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-解构赋值]]></title>
    <url>%2F2017%2F07%2F02%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;es6由于import、export模块化的能力，也推出了解构赋值这么一种能力，顾名思义，解析赋值，解析js代码然后进行赋值。这篇只是梳理并不设计代码例子。es6的解构赋值指的是在赋值表达式中解构右边部分的值然后将值赋给左边。 解构赋值的几种情况 &nbsp;&nbsp;解构赋值在于根据赋值表达式左边的匹配模式，来解构右边的表达式并且完成赋值。根据右边的表达式的不同解构的结果不同。 对数组的解构 对对象的解构 对字符串的解构 对函数的解构 对boolean的解构 &nbsp;&nbsp;解构虽然是根据被解构对象不同会有不同的差别，但是原理都是一致的：按照一定的模式，从对象中提取值，并完成赋值，只是有一些特殊的情况需要注意。 解构赋值是可以有默认值的。在没有默认值的情况，如果没有解析到值那么，值就是undefined，所以只有在值被解析完成以后为undefined才会触发默认值，解析为null或者false等都不算。 模式匹配必须和右边的解构完全一致，不一致则会因此导致错误。 对一个已经声明的变量进行解构赋值是很容易导致错误的一件事，没有变量声明var、let、const，解析器无法确定这是一个解构赋值语句还是一个代码块，因此需要使用（）来包裹整体，（）包裹住就不会被认为是一个代码块 在对字符串解构的时候，字符串被改为一个类似数组的对象，会解构出每一个字符 对数字和布尔值进行解构的时候，原始类型的值会被转化成引用类型的封装对象。 最复杂的是结合函数参数进行解构赋值，由于函数参数可以有默认值，解构赋值对象也可以有默认值，将函数参数的默认值设置为有默认值的解构赋值是最复杂和麻烦的事，需要根据原理细致的查看，编写相应代码时也要格外小心。 （）在解构赋值中的使用也需要小心，只有赋值语句的非模式部分可以使用圆括号，其他任何地方使用圆括号都会报错]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-let/const]]></title>
    <url>%2F2017%2F07%2F01%2Flet%20const%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;尝试在不查看文档的情况下写出es6知识点的相关内容，遇到没记清楚的再查阅才能加深记忆力，好记性不如烂笔头 let/const几个重要特性 没有变量提升 暂时性死区 不允许重复声明 全局声明的变量不再挂载到window上 &nbsp;&nbsp;理解没有变量提升，要先回顾变量提升的概念。js作为词法作用域的语言，js的作用域是在代码执行的时候确认的，代码执行的环境会有一个对应的执行上下文，每次进入一个执行环境都会创建一个执行上下文，执行上下文在创建阶段会做三件事。 确认作用域 创建变量对象 确认this指向 &nbsp;&nbsp;变量提升就发生在创建变量对象时，创建变量对象要做2件事。第一，查找var变量声明，不包括let和const声明，在变量对象里生成对应变量名称的属性，重名的声明会被覆盖。第二，查找函数声明，生成对应函数名的指针对象指向函数的堆内存空间存放位置，重名的函数不会生效。 &nbsp;&nbsp;在代码开始执行的时候，执行上下文就会进入执行阶段，变量对象就会变成活动对象，并且根据执行进度对活动对象里的提前声明的对象赋值。 &nbsp;&nbsp;由此可以知道为什么let、const没有变量提升，因为，在进行变量提升的时候没有对let、const的变量声明进行提升。 &nbsp;&nbsp;暂时性死区的概念其实和没有变量提升是一个意思，在let、const变量还没有声明的时候，在对应的作用域内使用它会直接导致报错，对于let、const变量而言，{}就是它们在还没有被声明时的死区。所以我认为阮一峰的es6入门在这一块的讲述是重复且有误导性的，没有变量提升其实是暂时性死区的原理，而不应该把两者都作为特性来说明。 &nbsp;&nbsp;关于不允许重复声明这一条特性，在原理上确实不好理解，目前我只能理解成语法糖，语法规定了就是这样，不过从这条语法糖的意义上倒是可以看出js视图纠正之前变量声明过于灵活的问题，我一直无法理解可以重复声明同名变量还不回报错到底有什么意义，除了不会报错以外，在使用上完全可能破坏代码，降低代码质量。 &nbsp;&nbsp;let、const声明的变量不再挂载到Window上野同样是为了规范变量声明，js不再默认允许随意的创建全局变量。 &nbsp;&nbsp;声明let、const变量导致的块级作用域不难理解，只要在{}内声明了let、const变量，{}就会成为一个es5里不支持的块级作用域。 &nbsp;&nbsp;难以理解的是es6规定了在{}里声明的函数也会导致会计作用域，不需要其他声明，函数就会被绑定到这个作用域里。其实这让人很难理解，es6并没有摒弃es5的内容，执行上下文依然会创建，那么块级作用域又是如何在原理上实现的呢，如何检测、创建、绑定一个块级作用域？ 问题：如何检测、创建、绑定一个块级作用域？]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react入门级教程（一）]]></title>
    <url>%2F2017%2F06%2F15%2Freact%E5%85%A5%E9%97%A8%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%B9%B2%E8%B4%A7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[react入门级教程（一） 1、前言 react的官方文档的逻辑和语言方式真的是难看，就像看外语翻译来的文学小说，再真挚再伟大的感情波动读起来都像是在看戏，还不如自己做一个总结。 react和vue我都系统学习过，两者对比起来，react的自由度会更高一些，react的开发更接近原生js代码，除了它基本的不多的几个语法，其他的都是es6来完成 ，而vue配置项要多很多，语法也相对多很多，这也是为什么我近期准备啃react的原因，对于es6的高度依赖对开发人员的成长更有好处，能学到更多东西。 写这个教程，最大的目的是巩固自己的基础，其次是希望能帮助到一些和我一样的初学者。 2、create-react-app 一个工程化的兼容性强的前端开发环境自己配置对于初学者来说是非常艰难的，需要配置es6环境，配置基于node的服务器，配置打包工具，配置模块化， 配置css3、html5支持，等等。对初学者，这会是一个很难受的过程，去年年初，我自己在不知道vue-cli的情况下研读了github上别人的项目，对着一堆 代码研究了好几天才搞明白，究竟在干嘛，还是在知道了vue-cli以后才知道是自动生成的代码，而不是自己写的，很难受。 因此，学习这些框架在不进行进一步webpack配置的情况下，完全可以直接用自动化工具来初始化一个项目，而不需要自己来搭建，vue项目使用vue-cli， react项目使用create-react-app。使用npm安装create-react-app： npm install create-react-app -g //建议全局安装 create-react-app构建了一个完善的开发环境，包括热替换等。 //创建一个项目 create-react-app 项目名称 //初始化项目 npm install //运行项目 npm start 执行上面代码就可以初始化并且运行项目，会得到一个demo页面，这里就不截图了。src下的index是react项目的入口文件，其他的是组件。 3、react基础语法 其实之前也做了好几次整理，但是还是容易变得模糊，不精准，只能说好记性不如烂笔头，这里主要对对react部分来说明语法，react-dom暂且放一放 这里会提到以下几个类和方法：react、Component、jsx、render、props。 下面是一个简单的react组件 import React,{Component} from &apos;react&apos;; //从react导入React相关环境以及组件环境 var root = document.querySelector(&quot;app&quot;);//拿到页面的根元素。 render(&lt;div&gt;haha&lt;/div&gt;,root);// 组件的render渲染方法，把虚拟的div组件绑定到root上 其实上面三行代码已经包含了react的精髓内容，react更多的是一种基于数据的新的开发思维模式。 第一行代码，在单页应用spa里依赖react的环境，这个环境有很多内容，这里只依赖了Component，一个组件相关的类 第二行代码，获取要挂载的根节点 第三行代码，创建一个虚拟DOM，也就是 haha,然后把这个虚拟DOM挂载到根节点上, react的精髓就在于创建虚拟DOM，挂载以后生成真实的DOM，用数据驱动虚拟DOM进行变化，虚拟DOM的变化反映到挂载的真实DOM上。 react的目的就是更小耦合度的划分功能模块成组件，一个功能或者几个功能划分成一个组件，组件的通信来完成复杂功能。 4、创建组件的两种方式 通过reactDOm来创建的方式并不被官方推介。 a、创建无状态组件 由react开创的组件化的模式在于转换操作DOM为操作数据，以前我们习惯于使用jquery操作DOM来做页面逻辑操作，react的思路是利用操作数据来改变虚拟DOM然后更新真实DOM，比如一个表单验证，使用jquery是操作DOM来获取表单元素的值，然后对值进行校验，然后再一次操作提示部分的DOM进行复制，使用react的思路是创建一个虚拟的DOM表单，直接进行表单数据验证，将验证结果反应到反应到数据上，然后根据数据重绘表单界面。jquery是一个工具，运用jquery是一个横向的单点的过程，只关心自己择器操作的DOM，而不关心使用场景。而使用react是一个纵向的连续的过程 一个react组件本身就是可以持续改变，多个组件通过父子关系，兄弟关系，在横向和纵向上可以组合拉伸。一个用户操作在jquery里只是一个普通的操作DOM改变界面，在react里却是能看到一条线，一条由用户操作引起的数据流向的线。更重要的一点是，react组件是可以积累的，是可复用的。 会到第一种创建组件的方式：无状态组件。一个组件的状态就是它的数据，数据变化，组件就会重新绘制，无状态组件就是没有自己状态的组件，这种组件不在少数，只展示信息的组件，它不需要有属于自己的数据，他只负责展示，用户操作的组件，一个button只代表一个用户点击操作，它于它的父组件不可分割，也不需要有自己的数据。我们通过函数式的写法来创建组件： ShowMessage.jsx import React from &apos;react&apos;; const ShowMessage = () =&gt; { return( &lt;div&gt;nihao&lt;/div&gt; ) } export default ShowMessage; () =&gt; {}箭头函数式es6的写法，用来固定this指向,简写function，它等于 function(){}, import和export是es6模块化的东西。上面这个组件就是一个没有自己状态的组件，但是它没有意义，一个静态div的组件是没有意义的，使它有意义的是他的父组件，它没有自己的数据，但是可以有父组件的数据，父组件传递数据给子组件的方式是通过属性，然后在子组件里通过props来获取数据. parent.jsx import showMessage from &apos;showMessage.jsx&apos;; import React,{Component} from &quot;react&quot;; class Parent extends Component{ state = { message：&quot;hello&quot; } render(){ return( &lt;ShowMessage message={message}/&gt; ) } } export default Parent; 这里使用属性的方式把message赋值给ShowMessage子组件。 {message}是jsx的语法，jsx是一个 js的扩充语言，它的写法于html一样，在读取编译的时候，会使用creatElement函数来根据标签创建js对象，{message}是在jsx里插入变量的写法。 ShowMessage.jsx import React from &quot;react&quot;; const ShowMessage = (props) =&gt; { return( &lt;div&gt;{props.message}&lt;/div&gt; ) } export default ShowMessage; 在子组件里通过props来接受父组件的数据,包括给子组件绑定事件，如下 &lt;ShowMessage message={message} method={this.method}/&gt; ShowMessage.jsx import React from &quot;react&quot;; const ShowMessage = (props) =&gt; { return( &lt;div onClick={props.method}&gt;{props.message}&lt;/div&gt; ) } export default ShowMessage; b、创建有状态的组件 上面的Parent组件其实就是有状态的组件 parent.jsx import showMessage from &apos;showMessage.jsx&apos;; import React,{Component} from &quot;react&quot;; class Parent extends Component{ state = { message：&quot;hello&quot; } render(){ return( &lt;ShowMessage message={message}/&gt; ) } } export default Parent; class是es6创建类的关键字，于创建一个函数其实差别不大；extends是es6进行继承的写法，es5必须通过原型链将圆形赋值给被继承对象的实例才能完成继承，es6简化了这个部分，现在只需要使用extends就可以完成继承，当然也可以使用supper函数。 Component是react里的组件相关的类，render是Component提供的渲染函数，用来渲染组件。 一个组件有了自己的状态就可以做很多事情了，要牢记的一点是：组件的数据发生改变就会调用render函数重新绘制组件，组件的数据包括自己状态state和来自父组件的数据props。 比如做一个提交功能，包含提交按钮，一个提示信息，提交时还要禁止点击 Button.jsx import React from &quot;react&quot;; const Button = (props) =&gt; { const {children, loading, submit} = props; return ( &lt;button onClick={submit} disabled={loading?&apos;disabled&apos;:null&gt; {loading &amp;&amp; &lt;i className=&quot;loading&quot;&gt;&lt;/i&gt;} {children} } &lt;/button&gt; ) } export default Button; 这个提交按钮Button组件没有自己的状态，只有父组件传递的提交函数，子元素，是否loadind。 className是为了和class关键字区分开，className表示css类名，const { … } = props是es 6解析结构的写法 Dialog.jsx import React from &quot;react&quot;; const Dialog = () =&gt; { const {message, close} = props; return( &lt;div className=&quot;dialog-backdrop&quot;&gt; &lt;div className=&quot;dialog-container&quot;&gt; &lt;div className=&quot;dialog-header&quot;&gt;提示&lt;/div&gt; &lt;div className=&quot;dialog-body&quot;&gt;{ message }&lt;/div&gt; &lt;div className=&quot;dialog-footer&quot;&gt; &lt;button className=&quot;btn&quot; onClick={ close }&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) } 这个弹出框组件接受父组件的消息和关闭函数 App.jsx import React, { Component} from &quot;react&quot;; import Button from &quot;Button.jsx&quot;; class App extends Component{ state = { message: &quot;&quot;, loading: false, dialog: false } submit = () =&gt; { this.setState({ loading: true }) setTimeout( () =&gt; { const res = Math.random(1); if(res &lt; 0.5){ this.setState({ message: &quot;提交成功&quot;, dialog: true }) }else{ this.setState({ message: &quot;提交成功&quot;, dialog: true }) } this.setState({ loading: false }) }) } close = () =&gt; { this.setState({ dialog: false, }) } render(){ const {loading, message, dialog} = this.state; return ( &lt;div className=&quot;app-wrap&quot;&gt; &lt;Button submit={this.submit} loading={loading}&gt;提交&lt;/Button&gt; {dialog &amp;&amp; &lt;Dialog message={message} close={this.close}/&gt;} &lt;/div&gt; ) } } 这个由三个组件组成的提交功能的组合组件中数据的流向从上到下，从用户点击开始，点击改变了父组件状态，组件状态改变了子组件的props。 5、react组件的声明周期钩子 任何流程和事物都有一个生命周期，react的声明周期有三种：挂载前后、更新前后、销毁前 挂载前后：componentWillMount（）、componentDidMount（） 更新前： componentWillReceiveProps接收到一个新的props时，在重新render之前调用 shouldComponentUpdate 接收到一个新的state或者props时，在重新render之前调用 componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用 更新后： componentDidUpdate 组件完成更新之后调用 销毁前： componentWillUnmount]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM新API fetch]]></title>
    <url>%2F2017%2F06%2F07%2Ffetch%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;之前刚刚总结了axios的用法，然后就突然发现了fetch这么一个东西，这个既然还是新的BOM标准之一，不得不感叹，前端技术推进真的是快，连ajax都要被取代了吗 &emsp;&emsp;fetch是定义在BOM标准中window上得一个功能集，它的目的在于取代现有的XMLHttpRequest。w3c认为XMLHttpRequest比较杂乱、异步请求是基于事件模型的，相比Promise和asyns/await来说不够友好、不符合长期以爱w3c关注分离的原则。因此，w3c发布了fecth标准，用来取代旧有的ajax。 &emsp;&emsp;其实浏览器请求天生就是异步操作，长久以来，一直都在致力于简化、规范化这个过程。jQuery的ajax方法，es6的Promise，es7的asyns/await、以及大量的前端框架，像angular-resource，axios等等。 &emsp;&emsp;但是w3c这个行为像是在搞事呀，ECMA组织发布了es6、es7中都包含有异步操作的内容，也都很强大，它在promise的基础上封装一个fetch出来有些瞎操心。不过从另一个角度来说，ajax以前也是w3c负责发布的标准，做这个改进也合情合理，但是fech像替换掉ajax甚至jquery的ajax，我并不看好。 fetch API fetch的API主要体现在它的接口实现上，分为以下几个接口，GolbalFetch、Body、Request、Response、Headers，其他的接口暂时不准备学习。 GolbalFetch 这个接口提供了fetch（）方法，window实现了这个接口，因此可以直接使用window.fetch()来请求资源，fetch()接受一个Request接口对象，或者一个URL。 var URL = &apos;https://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=your_api_key&amp;format=json&amp;nojsoncallback=1&amp;tags=penguins&apos;; function fetchDemo() { fetch(URL).then(function(response) { return response.json(); }).then(function(json) { insertPhotos(json); }); } fetchDemo(); Request]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS typeof总结---6种数据类型]]></title>
    <url>%2F2017%2F06%2F05%2Fjavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言 &emsp;为什么要写这个东西？因为typeof总是返回一些乱七八糟的词啊，各种基本数据类型莫名其妙的相等！不总结一下不行了？那么，typeof究竟会返回哪些值呢？ js有5种基本类型Undefined、Null、Boolean、String、Number，一种复杂类型Object，函数本质是一个对象，但是函数由于它在js中的特殊性，也需要从其他对象中被区分出来function，因此，typeof会返回7种值。 js五种基本数据类型 js有5种基本数据类型undefined、null、boolean、string、number，下面一一说明: 1、Undefined Undefined作为基本类型的意义，意如其名，未定义,Undefined作为变量的基本类型，是针对变量来说的，因此默认变量已经存在。 在ECMAScript里，Undefiend只有一个值，即特殊的undefiend 在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量 var a; a == undefined// true typeof a//&apos;undefined&apos; 我们考虑的是：什么样的变量 typeof会返回‘undefined’ 按照上面的定义，未初始化的变量会返回undefined；还有一种特殊情况也会返回undefined，那就是未声明变量 typeof b//&apos;undefined&apos; b == &apos;undefined&apos; // 会报错 这里我们要分清楚三个概念: 变量是否已定义 变量类型 变量的值 再结合typeof就不难理解为什么只有未初始化的变量值为undefined，而未定义和未初始化的变量数据类型都为Undefined。未定义的变量本来就不存在，把他归为Undefined变量只是为了更好的区分。 因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在 2、Null &emsp;Null和Undefined类似，表示为空，但是在js里，为空是什么意思呢？ 在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针 var a = null; typeof a //&apos;object&apos; typeof null // &apos;object&apos; 也就是说null表示一个没有指向的对象指针，这样我们就可以理解了。 这样看来，null和undefined其实并没有太大的区别，赋值一个空的对象指针null和赋值一个undefined，看起来没有区别，而且实际上 null == undefined// true undefined == null//true 更过分的是： var a = null; a == undefined // true var b; b == undefined // true //这个最过分 a == b //true，竟然是true，但是也引发出了一个大的猜想：在变量还没有被赋予实际值的时候，所有变量的值都是一样的，不一样的只有类型 这两个值还真的是相等的，每次看到这里肯定就已经绕进去了。。。。这两个基本属性在搞什么呀，乱七八糟，莫名其妙。 非要总结一下规则的话,可以说，这两种基本类型是一样的，一样的值；Undefined和Null就像两条线，两条一模一样的线，但是他们依然是不同的线。 他们的不同就在于类型的不同，在于意义的不同，undefiend是未初始化的值，null是空的对象指针。 ECMAScript引入这个undefined的最主要目的就是为了与空对象指针null做区分 3、Boolean &emsp;Boolean是ECMAScript中的布尔类型，有两个值：true和false，并且，这两个值区分大小写 Boolean()可以转换其他类型为Boolean类型，在进行if（）判断时，就是默认调用了Boolean（）方法。 数据类型 true false Boolean true false Strung 非空字符串 空字符串 Number 任何非0数字（包括无穷大） 0和NaN Object 任何Object null、 Undefined 不试用 undefined 4、Number ECMAScript是基于IEEE754数值格式的，由于IEEE754的通病，浮点数会有四舍五入的毛病，0.1+0.2并不等于0.3，而是等于0.30000000000000004，所以不要确定浮点数的值。 Number可以通过8进制、十进制、十六进制来表示，十进制和往常一样 八进制，首位数字为0,078表示八进制的78,十进制的64， 十六进制，首尾字符为0x，0x9表示十六进制的9，A~E表示11~15。 数值范围上来说，Number有一个上下线，一旦超过了上线就会变成Infinity，超过下线就会变成-Infinity。 而一个本来应该返回数值的数结果却没有返回数值，这个时候就会返回NaN，比如0/0就会返回NaN。NaN与任何值都不相等，包括它自身，它只是一个代表意义，表示不是数字。可以用isNaN来判断是否不是数字]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios随笔]]></title>
    <url>%2F2017%2F06%2F02%2Faxios%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介 &emsp;axios是一个基于es6 Promise的HTTP库，可以在浏览器和nodejs中使用。在vue2之后，官方不在推介vue-resource，然是推介使用axios，作为一个被很多人引用为项目依赖的模块，各方面的性能还是信得过的。在浏览器中发起XMLRequest，在node中发起http请求，在形式上支持Promise异步链式编程，也支持自动转化json，同样还可以做请求拦截和分发。是功能很强大的一个插件 安装 &emsp;直接引入官方axios.js或者使用npm安装 npm i axios 示例 //发起一个user请求，参数为给定的ID axios.get(&apos;/user?ID=1234&apos;) .then(function(res){ conole.log(res) }).catch(function(error){ console.log(error) }) //上面的请求也可选择下面的方式来写 axios.get(&apos;/user&apos;,{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error) }); axios语法 1.基础用法–发起请求 axios(config).then().catch(); &emsp;config的配置如下 config = { method: &apos;get/post/put/delete...&apos;, url: &apos;/api/dsdsd/dsd&apos;, data: { }, responseType: &apos;strean/json/string/...&apos; } //发起一个post请求 axios({ method:&apos;post&apos;,//方法 url:&apos;/user/12345&apos;,//地址 data:{//参数 firstName:&apos;Fred&apos;, lastName:&apos;Flintstone&apos; } }); 2.请求方法的重命名 &emsp;根据axios(config)，来重命名一批方法。 //请求配置外置化 axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,config]) axios.options(url[,config]) axios.post(url[,data[,config]]) axios.put(url[,data[,config]]) axios.patch(url[,data[,config]]) config中的url、data、method会被重命名方法中的参数替换掉 3.创建axios实例 axios.create(config) 创建实例的意义在于预定义一些参数值，那么采用这个实例来发起请求，这些参数就会默认载入。 //创建一个axios实例 var instance = axios.create({ baseURL:&apos;http://some-domain.com/api/&apos;, timeout:1000, headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;} }); //使用实例来发起请求 instance.get(&apos;/api/user/123&apos;); 同axios本身一样，实例也有方法重命名 instance.request(config) instance.get(url[,config]) instance.delete(url[,config]) instance.head(url[,config]) instance.options(url[,config]) instance.post(url[,data[,config]]) instance.put(url[,data[,config]]) instance.patch(url[,data[,config]]) 4.请求参数配置全局信息 { // url是服务器链接，用来请求 url:’/user’, // method是发起请求时的请求方法 method: get, // baseURL如果 url不是绝对地址，那么将会加在其前面。 //当axios使用相对地址时这个设置非常方便 //在其实例中的方法 baseURL:’ http://some-domain.com/api/‘, // transformRequest允许请求的数据在传到服务器之前进行转化。 //这个只适用于 PUT, GET, PATCH方法。 //数组中的最后一个函数必须返回一个字符串或者一个 ArrayBuffer,或者 Stream, Buffer实例, ArrayBuffer, FormData transformRequest:[function(data){ //依自己的需求对请求数据进行处理 return data; }], // transformResponse允许返回的数据传入then/catch之前进行处理 transformResponse:[function(data){ //依需要对数据进行处理 return data; }], // headers是自定义的要被发送的头信息 headers:{‘X-Requested-with’:’XMLHttpRequest’}, // params是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象 params:{ ID:12345 }, // paramsSerializer是一个可选的函数，是用来序列化参数 //例如：（ https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/) paramsSerializer: function(params){ return Qs.stringify(params,{arrayFormat:’brackets’}) }, // data是请求提需要设置的数据 //只适用于应用的’PUT’,’POST’,’PATCH’，请求方法 //当没有设置 transformRequest时，必须是以下其中之一的类型（不可重复？）： //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams //-仅浏览器：FormData,File,Blob //-仅Node：Stream data:{ firstName:’fred’ }, // timeout定义请求的时间，单位是毫秒。 //如果请求的时间超过这个设定时间，请求将会停止。 timeout:1000, // withCredentials表明是否跨网站访问协议， //应该使用证书 withCredentials:false //默认值 // adapter适配器，允许自定义处理请求，这会使测试更简单。 //返回一个promise，并且提供验证返回（查看 response docs） adapter:function(config){ / …/ }, // auth表明HTTP基础的认证应该被使用，并且提供证书。 //这个会设置一个 authorization 头（header），并且覆盖你在header设置的Authorization头信息。 auth:{ username:’janedoe’, password:’s00pers3cret’ }, // responsetype表明服务器返回的数据类型，这些类型的设置应该是 //‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’ responsetype:’json’, // xsrfHeaderName 是http头（header）的名字，并且该头携带xsrf的值 xrsfHeadername:’X-XSRF-TOKEN’，//默认值 // onUploadProgress允许处理上传过程的事件 onUploadProgress: function(progressEvent){ //本地过程事件发生时想做的事 }, // onDownloadProgress允许处理下载过程的事件 onDownloadProgress: function(progressEvent){ //下载过程中想做的事 }, // maxContentLength 定义http返回内容的最大容量 maxContentLength: 2000, // validateStatus 定义promise的resolve和reject。 //http返回状态码，如果 validateStatus返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。 validateStatus: function(status){ return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认 }, // httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 //这个允许设置一些选选个，像是 keepAlive–这个在默认中是没有开启的。 httpAgent: new http.Agent({keepAlive:treu}), httpsAgent: new https.Agent({keepAlive:true}), // proxy定义服务器的主机名字和端口号。 // auth表明HTTP基本认证应该跟 proxy相连接，并且提供证书。 //这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。 proxy:{ host:127.0.0.1, port:9000, auth:{ username:’cdd’, password:’123456’ } }, // cancelTaken 定义一个取消，能够用来取消请求 //（查看 下面的Cancellation 的详细部分） cancelToken: new CancelToken(function(cancel){ }) } 5.返回对象response包含对象 response包含以下5个对象： data：{}：服务器返回的数据 status: 200 服务器返回的http状态码 statusText： ‘ok’ 服务器返回的状态信息 header:{} : 服务器返回头信息 config：{} axiox的请求配置信息 6.默认配置 可以给axios或者axios的实例设置默认配置，axios中有三种配置信息： 默认配置，在模块的lib/defaults.js中的默认配置 其次是自定义的默认属性 最后是请求中的config配置 在定义实例的时候会在默认配置文件中创建一份临时数据，实例被销毁的时候，也销毁临时配置数据。 自定义默认数据的方式如下： instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 7.配置拦截器 axios支持配置两种拦截器：拦截请求、拦截响应 拦截请求： axios.interceptors.request.use(function(config){ //在请求之前做的一些事 },function(error){ //在请求错误之前做的一些事 return Promise.reject(error) }) 拦截响应： //添加一个返回拦截器 axios.interceptors.response.use(function(response){ //对返回的数据进行一些处理 return response; },function(error){ //对返回的错误进行一些处理 return Promise.reject(error); }); 取消拦截器需要使用eject函数 axios.interceptors.request.eject(&apos;拦截器名称&apos;)]]></content>
      <categories>
        <category>-- HTTP -- axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%97%A0%E6%A0%87%E9%A2%98Markdown%2F</url>
    <content type="text"><![CDATA[前言 最近领导和我聊了很多关于个人发展，关于职业规划方面的东西，对我确实有一些触动，也实实在在的点醒了我. 个人问题 长久以来，我深航都存在基础不稳的问题，大学阶段的浑浑噩噩，工作以后填填补补。靠着java找到的工作，但是自己却基本还是停留在对简单的框架使用，java基础没有好好总结过，spring也没有完全的好好看一遍，数据库sql更是不行，在后台开发这一块水得一塔糊涂. 这或许就是我谋求前端的原因之一吧，在前端技术的学习上我确实下了功夫，但是缺点也很明显，重心太多偏向js。 或许也是因为js是我技术的启蒙吧，大学阶段那么多的实习，从第一次读写文件MFC展示实习失败开始就一直没正真入门，但是js接纳了我，我第一次聚精会神写一份代码，站在图书馆一呆一天也是因为js。工作以后第一次的任务也是一份js编程的工作，DAP4，借助esayui我使用js完成了一个项目，当时的代码我都保留了起来，虽然现在看起来已经难以入目了，但是这引领了我进入了编程的世界。 后端java的缺点在于基础不扎实，代码都写过了，但是却不明白代码的运行规则。 前端的问题有两部分，基础上，对于js的编程自己还算满意，但是对于css和html标签的掌握不够。框架上，我只熟悉常用的框架，vue，react，webpack，scss，node，express，我只具备基础架构能力，自己也不能判断我是否具有框架的全局把控力。缺乏经验，大量缺乏经验，其实我也算是参与了三个成熟软件产品的研发，但是没有做到业务积累，没有培养自己的建模能力。很失败的一件事情，大学出来以后全部重心都放置在填补以前的空缺上了，没有对参与的项目进行非技术总结，没有细分业务需求的形成。 想法 面对基础的缺失，依然只能通过技术积累，通过看学习来积累，面对眼界，思维方式的缺失，却要自己多想多钻研。 多看文档博客，一点点补充缺失，特别是新特性，java8，css3，es6. 全方面理解web应用开发架构，明白每个模块，每个阶段用到了哪些技术，选取其中最流行最优秀的一个进行研究学习。 在真正理解了系统架构的基础上理解业务需求，加强建模能力。 路漫漫其修远兮，吾将上下而求索。]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown写法]]></title>
    <url>%2F2017%2F05%2F26%2FmarkDown%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown写法 1、定义标题文本写法 直接写和按一下tab’写是有区别的、#的个数指定字体大小 按tab,然后直接写就是正文文本 2、有序列表和无序列表 有序列表 1. DASDASD 2. DASDASD 3. DASDASFD 无序列表 1 2 3 3、使用”&gt;”来进行引用 你好，引用的字体会是灰白色 4、图片链接 博客中添加图片我们可以使用图床获取图片的URL， 可以去这个网址http://jiantuku.com/#/ 图片的写法是![]() ![nihao](http://dadasd/adasd/sdasd,jpg) 5、粗体斜体 使用 就是粗体，使用一个 就是一斜体 你好 你好 6、生成表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 使用这样的语法 “| Tables | Are | Cool | | ————- |:————-:| —–:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 |” 7、代码块 使用”`“来包裹 var a = &quot;name&quot;; var b = &quot;cv&quot;;]]></content>
      <categories>
        <category>markDown</category>
      </categories>
      <tags>
        <tag>markDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传项目到github“]]></title>
    <url>%2F2017%2F05%2F26%2F%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[要上传项目到github需要以下几个步骤 1、有或者新建一个github账户 2、创建一个和本地对应的仓库 3、本地安装git 一路默认即可 4、生成ssh key cd ~/.ssh 进入目录–》ls查看是否已有ssh key–》没有则新建 ssh-keygen -t rsa -C “754416804@qq.com”—&gt;不使用密码创建–》id_rsa.pub里面就是ssh key 5、到github网站关联自己的ssh key 到setting里进入ssh KEys–》增加ssh key–》填入自己的ssh key 保存 6、执行git命令，初始化空间，绑定远程仓库、添加提交代码、推送代码到远程仓库 git init –》git add . –》 git commit -m “” –》git remote add orign “你的git项目地址”–》git push -u orgin master 7、ok 可以看到已经添加成功]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>