<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS typeof总结---6种数据类型]]></title>
    <url>%2F2017%2F06%2F05%2Fjavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;为什么要写这个东西？因为typeof总是返回一些乱七八糟的词啊，各种基本数据类型莫名其妙的相等！不总结一下不行了？那么，typeof究竟会返回哪些值呢？js有5种基本类型Undefined、Null、Boolean、String、Number，一种复杂类型Object，函数本质是一个对象，但是函数由于它在js中的特殊性，也需要从其他对象中被区分出来function，因此，typeof会返回7种值。 js五种基本数据类型js有5种基本数据类型undefined、null、boolean、string、number，下面一一说明: 1、UndefinedUndefined作为基本类型的意义，意如其名，未定义,Undefined作为变量的基本类型，是针对变量来说的，因此默认变量已经存在。 在ECMAScript里，Undefiend只有一个值，即特殊的undefiend在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量var a; a == undefined// true typeof a//&apos;undefined&apos; 我们考虑的是：什么样的变量 typeof会返回‘undefined’按照上面的定义，未初始化的变量会返回undefined；还有一种特殊情况也会返回undefined，那就是未声明变量 typeof b//&apos;undefined&apos; b == &apos;undefined&apos; // 会报错 这里我们要分清楚三个概念: 变量是否已定义 变量类型 变量的值 再结合typeof就不难理解为什么只有未初始化的变量值为undefined，而未定义和未初始化的变量数据类型都为Undefined。未定义的变量本来就不存在，把他归为Undefined变量只是为了更好的区分。 因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在2、Null&emsp;Null和Undefined类似，表示为空，但是在js里，为空是什么意思呢？ 在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针var a = null; typeof a //&apos;object&apos; typeof null // &apos;object&apos; 也就是说null表示一个没有指向的对象指针，这样我们就可以理解了。 这样看来，null和undefined其实并没有太大的区别，赋值一个空的对象指针null和赋值一个undefined，看起来没有区别，而且实际上 null == undefined// true undefined == null//true 更过分的是： var a = null; a == undefined // true var b; b == undefined // true //这个最过分 a == b //true，竟然是true，但是也引发出了一个大的猜想：在变量还没有被赋予实际值的时候，所有变量的值都是一样的，不一样的只有类型 这两个值还真的是相等的，每次看到这里肯定就已经绕进去了。。。。这两个基本属性在搞什么呀，乱七八糟，莫名其妙。非要总结一下规则的话,可以说，这两种基本类型是一样的，一样的值；Undefined和Null就像两条线，两条一模一样的线，但是他们依然是不同的线。他们的不同就在于类型的不同，在于意义的不同，undefiend是未初始化的值，null是空的对象指针]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios随笔]]></title>
    <url>%2F2017%2F06%2F02%2Faxios%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介&emsp;axios是一个基于es6 Promise的HTTP库，可以在浏览器和nodejs中使用。在vue2之后，官方不在推介vue-resource，然是推介使用axios，作为一个被很多人引用为项目依赖的模块，各方面的性能还是信得过的。在浏览器中发起XMLRequest，在node中发起http请求，在形式上支持Promise异步链式编程，也支持自动转化json，同样还可以做请求拦截和分发。是功能很强大的一个插件 安装&emsp;直接引入官方axios.js或者使用npm安装npm i axios 示例//发起一个user请求，参数为给定的ID axios.get(&apos;/user?ID=1234&apos;) .then(function(res){ conole.log(res) }).catch(function(error){ console.log(error) }) //上面的请求也可选择下面的方式来写 axios.get(&apos;/user&apos;,{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error) }); axios语法1.基础用法–发起请求axios(config).then().catch(); &emsp;config的配置如下 config = { method: &apos;get/post/put/delete...&apos;, url: &apos;/api/dsdsd/dsd&apos;, data: { }, responseType: &apos;strean/json/string/...&apos; } //发起一个post请求 axios({ method:&apos;post&apos;,//方法 url:&apos;/user/12345&apos;,//地址 data:{//参数 firstName:&apos;Fred&apos;, lastName:&apos;Flintstone&apos; } }); 2.请求方法的重命名&emsp;根据axios(config)，来重命名一批方法。 //请求配置外置化 axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,config]) axios.options(url[,config]) axios.post(url[,data[,config]]) axios.put(url[,data[,config]]) axios.patch(url[,data[,config]]) config中的url、data、method会被重命名方法中的参数替换掉 3.创建axios实例axios.create(config) 创建实例的意义在于预定义一些参数值，那么采用这个实例来发起请求，这些参数就会默认载入。 //创建一个axios实例 var instance = axios.create({ baseURL:&apos;http://some-domain.com/api/&apos;, timeout:1000, headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;} }); //使用实例来发起请求 instance.get(&apos;/api/user/123&apos;); 同axios本身一样，实例也有方法重命名 instance.request(config) instance.get(url[,config]) instance.delete(url[,config]) instance.head(url[,config]) instance.options(url[,config]) instance.post(url[,data[,config]]) instance.put(url[,data[,config]]) instance.patch(url[,data[,config]]) 4.请求参数配置全局信息 { //url是服务器链接，用来请求 url:’/user’, //method是发起请求时的请求方法 method:get, //baseURL如果url不是绝对地址，那么将会加在其前面。 //当axios使用相对地址时这个设置非常方便 //在其实例中的方法 baseURL:’http://some-domain.com/api/‘, //transformRequest允许请求的数据在传到服务器之前进行转化。 //这个只适用于PUT,GET,PATCH方法。 //数组中的最后一个函数必须返回一个字符串或者一个ArrayBuffer,或者Stream,Buffer实例,ArrayBuffer,FormData transformRequest:[function(data){ //依自己的需求对请求数据进行处理 return data; }], //transformResponse允许返回的数据传入then/catch之前进行处理 transformResponse:[function(data){ //依需要对数据进行处理 return data; }], //headers是自定义的要被发送的头信息 headers:{‘X-Requested-with’:’XMLHttpRequest’}, //params是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象 params:{ ID:12345 }, //paramsSerializer是一个可选的函数，是用来序列化参数 //例如：（https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/) paramsSerializer: function(params){ return Qs.stringify(params,{arrayFormat:’brackets’}) }, //data是请求提需要设置的数据 //只适用于应用的’PUT’,’POST’,’PATCH’，请求方法 //当没有设置transformRequest时，必须是以下其中之一的类型（不可重复？）： //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams //-仅浏览器：FormData,File,Blob //-仅Node：Stream data:{ firstName:’fred’ }, //timeout定义请求的时间，单位是毫秒。 //如果请求的时间超过这个设定时间，请求将会停止。 timeout:1000, //withCredentials表明是否跨网站访问协议， //应该使用证书 withCredentials:false //默认值 //adapter适配器，允许自定义处理请求，这会使测试更简单。 //返回一个promise，并且提供验证返回（查看response docs） adapter:function(config){ /…/ }, //auth表明HTTP基础的认证应该被使用，并且提供证书。 //这个会设置一个authorization 头（header），并且覆盖你在header设置的Authorization头信息。 auth:{ username:’janedoe’, password:’s00pers3cret’ }, //responsetype表明服务器返回的数据类型，这些类型的设置应该是 //‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’ responsetype:’json’, //xsrfHeaderName 是http头（header）的名字，并且该头携带xsrf的值 xrsfHeadername:’X-XSRF-TOKEN’，//默认值 //onUploadProgress允许处理上传过程的事件 onUploadProgress: function(progressEvent){ //本地过程事件发生时想做的事 }, //onDownloadProgress允许处理下载过程的事件 onDownloadProgress: function(progressEvent){ //下载过程中想做的事 }, //maxContentLength 定义http返回内容的最大容量 maxContentLength: 2000, //validateStatus 定义promise的resolve和reject。 //http返回状态码，如果validateStatus返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。 validateStatus: function(status){ return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认 }, //httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 //这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 httpAgent: new http.Agent({keepAlive:treu}), httpsAgent: new https.Agent({keepAlive:true}), //proxy定义服务器的主机名字和端口号。 //auth表明HTTP基本认证应该跟proxy相连接，并且提供证书。 //这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。 proxy:{ host:127.0.0.1, port:9000, auth:{ username:’cdd’, password:’123456’ } }, //cancelTaken 定义一个取消，能够用来取消请求 //（查看 下面的Cancellation 的详细部分） cancelToken: new CancelToken(function(cancel){ }) } 5.返回对象response包含对象response包含以下5个对象： data：{}：服务器返回的数据 status: 200 服务器返回的http状态码 statusText： ‘ok’ 服务器返回的状态信息 header:{} : 服务器返回头信息 config：{} axiox的请求配置信息 6.默认配置可以给axios或者axios的实例设置默认配置，axios中有三种配置信息： 默认配置，在模块的lib/defaults.js中的默认配置 其次是自定义的默认属性 最后是请求中的config配置 在定义实例的时候会在默认配置文件中创建一份临时数据，实例被销毁的时候，也销毁临时配置数据。 自定义默认数据的方式如下： instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 7.配置拦截器axios支持配置两种拦截器：拦截请求、拦截响应拦截请求： axios.interceptors.request.use(function(config){ //在请求之前做的一些事 },function(error){ //在请求错误之前做的一些事 return Promise.reject(error) }) 拦截响应： //添加一个返回拦截器 axios.interceptors.response.use(function(response){ //对返回的数据进行一些处理 return response; },function(error){ //对返回的错误进行一些处理 return Promise.reject(error); }); 取消拦截器需要使用eject函数 axios.interceptors.request.eject(&apos;拦截器名称&apos;)]]></content>
      <categories>
        <category>-- HTTP -- axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%97%A0%E6%A0%87%E9%A2%98Markdown%2F</url>
    <content type="text"><![CDATA[前言最近领导和我聊了很多关于个人发展，关于职业规划方面的东西，对我确实有一些触动，也实实在在的点醒了我. 个人问题长久以来，我深航都存在基础不稳的问题，大学阶段的浑浑噩噩，工作以后填填补补。靠着java找到的工作，但是自己却基本还是停留在对简单的框架使用，java基础没有好好总结过，spring也没有完全的好好看一遍，数据库sql更是不行，在后台开发这一块水得一塔糊涂. 这或许就是我谋求前端的原因之一吧，在前端技术的学习上我确实下了功夫，但是缺点也很明显，重心太多偏向js。 或许也是因为js是我技术的启蒙吧，大学阶段那么多的实习，从第一次读写文件MFC展示实习失败开始就一直没正真入门，但是js接纳了我，我第一次聚精会神写一份代码，站在图书馆一呆一天也是因为js。工作以后第一次的任务也是一份js编程的工作，DAP4，借助esayui我使用js完成了一个项目，当时的代码我都保留了起来，虽然现在看起来已经难以入目了，但是这引领了我进入了编程的世界。 后端java的缺点在于基础不扎实，代码都写过了，但是却不明白代码的运行规则。 前端的问题有两部分，基础上，对于js的编程自己还算满意，但是对于css和html标签的掌握不够。框架上，我只熟悉常用的框架，vue，react，webpack，scss，node，express，我只具备基础架构能力，自己也不能判断我是否具有框架的全局把控力。缺乏经验，大量缺乏经验，其实我也算是参与了三个成熟软件产品的研发，但是没有做到业务积累，没有培养自己的建模能力。很失败的一件事情，大学出来以后全部重心都放置在填补以前的空缺上了，没有对参与的项目进行非技术总结，没有细分业务需求的形成。 想法面对基础的缺失，依然只能通过技术积累，通过看学习来积累，面对眼界，思维方式的缺失，却要自己多想多钻研。 多看文档博客，一点点补充缺失，特别是新特性，java8，css3，es6. 全方面理解web应用开发架构，明白每个模块，每个阶段用到了哪些技术，选取其中最流行最优秀的一个进行研究学习。 在真正理解了系统架构的基础上理解业务需求，加强建模能力。 路漫漫其修远兮，吾将上下而求索。]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown写法]]></title>
    <url>%2F2017%2F05%2F26%2FmarkDown%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown写法1、定义标题文本写法直接写和按一下tab’写是有区别的、#的个数指定字体大小 按tab,然后直接写就是正文文本 2、有序列表和无序列表有序列表1. DASDASD 2. DASDASD 3. DASDASFD 无序列表 1 2 3 3、使用”&gt;”来进行引用 你好，引用的字体会是灰白色 4、图片链接博客中添加图片我们可以使用图床获取图片的URL， 可以去这个网址http://jiantuku.com/#/ 图片的写法是![]() ![nihao](http://dadasd/adasd/sdasd,jpg) 5、粗体斜体使用 就是粗体，使用一个 就是一斜体你好 你好 6、生成表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 使用这样的语法 “| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |” 7、代码块使用”`“来包裹var a = &quot;name&quot;; var b = &quot;cv&quot;;]]></content>
      <categories>
        <category>markDown</category>
      </categories>
      <tags>
        <tag>markDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传项目到github“]]></title>
    <url>%2F2017%2F05%2F26%2F%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[要上传项目到github需要以下几个步骤1、有或者新建一个github账户 2、创建一个和本地对应的仓库 3、本地安装git一路默认即可4、生成ssh key cd ~/.ssh 进入目录–》ls查看是否已有ssh key–》没有则新建 ssh-keygen -t rsa -C “754416804@qq.com”—&gt;不使用密码创建–》id_rsa.pub里面就是ssh key 5、到github网站关联自己的ssh key 到setting里进入ssh KEys–》增加ssh key–》填入自己的ssh key 保存 6、执行git命令，初始化空间，绑定远程仓库、添加提交代码、推送代码到远程仓库 git init –》git add . –》 git commit -m “” –》git remote add orign “你的git项目地址”–》git push -u orgin master 7、ok可以看到已经添加成功]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>