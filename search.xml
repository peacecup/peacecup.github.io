<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js事件循环机制（二）]]></title>
    <url>%2F2017%2F08%2F02%2Fs%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88v8%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件循环的另一种解释 jsvascript是单线程高级脚本语言，每个线程拥有唯一的一个事件循环。 jsvascript代码在执行过程中，除了通过函数调用栈来解决函数执行顺序外，还依靠任务队列来搞定另外一些代码的执行顺序。 一个线程中，函数调用栈是唯一的，事件循环是唯一的，任务队列可以有多个。 任务队列又分为mocro-tasks（宏任务）和（micro-tasks）微任务，在最新的标准中也被称为tasks和jobs 宏任务mocro-tasks包括srcipt（整体代码）、setTimeout、 setInterval、 setImmediate、I/O、UI renering（页面渲染）。 微任务micro-tasks包括process.nextTrick、Promise、Mutation Observer（HTML5新特性）以及其他DOM事件 setTimeout、Promise、DOM事件等被称为任务源，而进入任务队列的是他们指定的具体执行的任务。setTimeout作为一个任务分发器，这个函数是会立即执行的，而他所要分发的任务是它的第一个参数，才会延迟执行。 来自不同任务源的任务会进入不同的任务队列，setTimeout和setInterval是同一个任务源。 不同任务源的执行有先后顺序。宏任务：script &gt; setTimeout/setInterval &gt; setImmediate &gt;I/O &gt; UI rendering.微任务：process.nextTrick() &gt; Promise &gt;DOM事件 事件循环的顺序决定了javascript代码的执行顺序，事件循环从宏任务script开始执行，执行过程中遇到任务源就会分发对应的任务到任务队列，script全局代码运行完毕并退出函数调用栈，然后执行所有的微任务micro-tasks，第一次循环结束。第二次循环从宏任务开始，根据宏任务队列的先后顺序，执行完一条任务队列后执行，执行所有的微任务micro-tasks，然后回到宏任务执行下一个宏任务队列，之后执行所有的微任务队列事件，循环直到所有任务队列都为空，此时第二次事件循环结束。 这里不准备结合例子展开了。 setTimeout定时函数的原理依然摸不清楚但是有一点可以肯定：定时器函数是在定时时间结束后才将定时器函数放入宏队列。所以就当是运行setTimeout函数的时候先休眠延迟时间，然后把回调事件发送到事件队列。 补充（17-08-02）之前一直忽略了一个细节，那就是setTimeout函数是DOM API的东西，属于浏览器定时器，想到这里就瞬间想通了这个问题。 浏览器本身是多线程的。 浏览器线程有4种： javascript引擎 GUI页面渲染 浏览器事件触发线程 http请求线程 其中，前三个线程是常驻线程，http线程请求完成以后就会close。这四个线程这怎么互相协作的呢？&nbsp;&nbsp;&nbsp;浏览器最重要的线程就是javascript引擎线程，其他的线程都是借助javascript引擎线程的事件循环机制来执行的。 GUI页面渲染线程，在需要渲染页面的时候就会给javascript宏任务中队列中添加一个事件，利用事件循环来执行。 http请求线程，在完成http请求以后将请求完成的回调事件添加到任务列表中。 浏览器事件触发线程，在触发浏览器事件，比如点击、界面缩放、滚动等事件时，就会将对应的回调函数事件添加在宏任务队列中，利用事件循环来进行， javascript引擎线程是所有线程的核心中枢，是师执行者，其他的几个线程都是消息捕获的执行者和消息分发的分配者。 &nbsp;&nbsp;&nbsp;理解了这些就不难理解setTimeout的时间循环机制。javascript的任务队列中的任务并不是全部由它自己分发的，更多的是浏览器的其他线程分发的。setTimeout事件就是由浏览器事件触发线程分发。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件循环机制（一）]]></title>
    <url>%2F2017%2F07%2F09%2Fjs%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%EF%BC%88v8%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题&nbsp;&nbsp;对于js事件循环机自会的理解不清楚，经常导致一些代码执行顺序上的混乱，js事件循环机制决定了代码的执行顺序，下面将对事件循环机制的规则进行总结。&nbsp;&nbsp;自己写的博客不是为了写教程，更多的个人总结，我总喜欢带入第三人的角度去写这些东西 事件循环&nbsp;&nbsp;什么是js事件循环呢我在网上看到的博文，我也不知道是否是完全正确的，阮一峰的博文在解释事件循环机制的时候只讲到时间循环的概念，简书签约作者波同学的博文更深一层的讲解了事件循环的执行规则，我暂时也不能确认哪些是正确的，哪些是错误的，后面的工作学习，我自己再慢慢总结吧。 阮一峰的博文解释实际上，我对阮一峰的博文还是有些怀疑的，写得很混乱也不清晰。反而波同学的相对写得清楚一些。 为什么js是单线程？&nbsp;&nbsp;js作为单线程的设计是事出有因的，其他语言大多都有设计多线程来满足并发需求。但是js没有，究其根本也正是因为js某种程度上不需要多线程。js语言本质上是浏览器的脚本语言，js固然可以进行逻辑业务运算，但是最后的目的还是为了控制界面展示，操作DOM。而操作DOM是不能兼容多线程的，比如一个线程修改了DOM节点，一个线程删除了DOM节点，这种矛盾逻辑作为页面体现是不可取的，因此js只能是单线程语言，现在是，以后也是。 &nbsp;&nbsp;HTML5的新特性web Worker是js在多线程的尝试，但是也有主线程和子线程的区别，浏览器js线程是主线程，能完全控制web Worker线程，web worker线程也不能操作DOM，只能进行业务逻辑运算。 什么是任务队列？&nbsp;&nbsp;js作为单线程语言，就意味着任务的执行必须排队，和java等语言一样，单一线程的执行任务只能排队进行。而这个队列就是j任务队列。&nbsp;&nbsp;js的任务队列于qianww语言不通，java由于支持多线程，所以并不支持异步操作，异步操作完全由多线程完成。js则不行，单线程同步运行会导致线程阻塞，比如在进行IO操作的时候，一个ajax请求，已经请求到了数据，但是由于要进行io操作需要延迟执行，这就会导致阻塞。&nbsp;&nbsp;因此js有了异步任务这个概念，将同步任务和异步任务分开来处理，同步任务在主线程中处理，js主线程使用函数调用栈来处理任务运行，同步任务被直接分配到函数调用栈也就是主线程里运行，异步任务则被分配到异步任务队列，而异步任务队列里的任务通知主线程：“我可以执行了”，此时才会进入函数调用栈执行。&nbsp;&nbsp;这个异步任务的任务队列就是js的任务队列。 什么是事件循环？&nbsp;&nbsp;任务队列就是一个事件队列，或者说消息队列，这个事件指的是异步操作已经完成的事件，异步操作已经完成时就会在异步任务队列里新增一条事件完成的回调事件。IO操作完成以后就会在任务队列里增加一天IO操作已经完成的回调事件。&nbsp;&nbsp;任务队列的事件包括：IO、DOM事件、setTimeout等指定了回调函数的任务。&nbsp;&nbsp;主线程在同步任务执行完毕后会读取异步任务队列，事件队列是一个先进先出的队列。先进入的异步事件会优先执行。&nbsp;&nbsp;对于setTimeout和setInterval定时函数是怎么分配分配任务到任务队列的呢，阮一峰的博客里说定时器事件会在主线程最早空闲的时候执行，在读取定时器事件时会检查执行延迟时间，时间到了才能进入主线程，这里还是没有解释清楚，延迟时间是怎么处理的。 这是个死循环 &nbsp;&nbsp;我去查了MDN，MDN上关于定时器是这么说的： 调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间。 MDN的意思是会延迟给定时间后将讲事件放入队列。MDN该市不会有错的，也可以想到肯定有一个东西把异步事件分配到异步队列，这个东西还具有定时延迟的问题，但是这是个死循环，一个已经具备延迟执行能力的东西把异步事件分配到异步队列，那这个东西又是怎么实现延迟执行能力的呢？晕]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6对象扩展]]></title>
    <url>%2F2017%2F07%2F08%2Fes6%E6%80%BB%E7%BB%93%2Fes6%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[基础回顾&nbsp;&nbsp;在js高级程序设计中已经知道了关于对象的一些定义和特性，对象是无序的属性的集合。 对象的属性和分为数据属性和访问器属性。 数据特性有value、configurable（能否被配置除）、writable（是否只读）、enumerable（是否可以被枚举遍历出来） 访问器特性有get、set、configurable、enumerable 获取特性的函数Object.getOwnPropertyDescriptor()、定义属性特性的函数Object.defineProperty()和Object.defineProperties() 一旦一个属性已经修改了configurable特性，被设定为false不可配置以后，就不能再次被修改除value外的其他属性了。 创建对象的发展历史：工厂模式-》构造函数模式-》原型模式-》组合使用构造函数和原型模式-》动态圆形模式-》计生/稳妥构造函数模式 原型、prototype属性、对象实例实例、构造函数、proto属性之间的关系：对象的prototype指向对象的原型，对象的实例的proto属性指向对象的原型，原型的constructor属性指向对象的构造函数。 函数的继承就是利用了原型链的原理，将对象的实例的原型赋值为被继承函数。 这些对象的知识点看起来不多，但是每一条都展开确实还是要花费好一些时间。只是，原型相关的知识现在越来越用不到了，不论是继承还是封装对象，es6里都进行了扩展。有时候真觉得花的这么些时间来理解吃透原型究竟有多少用。 属性的简写&nbsp;&nbsp;es6支持对属性名进行简写，就像解构里的模式一样，可以使用模式简写的方式来简写对象属性，对于属性方法，也可以省略掉function关键字。确实是很好用的简写方式，节省了大量冗余代码。 Object.is()函数&nbsp;&nbsp;传统的判断上是否相等函数有一定的漏洞，比如-0不等于+0，NaN等于NaN，但是其实正确结果是相反的，es6使用了新的算法来进行全等判断，比===更加有效。 Object.assign()函数&nbsp;&nbsp;Object.assign(target,source)函数会将source对象中的所有可枚举属性复制到target对象中，并且会覆盖同名的对象。&nbsp;&nbsp;这个对象复制的方法并不是深复制，在面对可枚举属性是对象的时候，只是进行了浅复制，复制了引用地址。对于这一点要格外小心 属性的遍历&nbsp;&nbsp;属性石头可被遍历和它的enumerable属性有关，若是enumerable属性为false不可被枚举，此时使用for in就不能遍历该对象，这里在总结列举一下遍历对象的方式： for in：会遍历出自身的可枚举属性以及继承的可枚举属性 for of：会遍历出所有自身的可枚举属性 Object.keys()/values()/entries()：自身的可枚举属性 JSON.stringify()：只会串行化自身的可枚举属性 Object.assign()：可枚举的自身属性 Reflect.enumerate()：和for in 一样 对象扩展运算符&nbsp;&nbsp;也可以对对象使用扩展运算符 … 。有下面两种用法。 解构赋值的时候使用…进行扩展 复制对象]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js递归的一个问题]]></title>
    <url>%2F2017%2F07%2F07%2Fes6%E6%80%BB%E7%BB%93%2F%E5%85%B3%E4%BA%8Ejs%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发现的两个递归问题之前学习了es6递归的尾调用优化了，刚好在codewars刷题的时候就遇到了一个判断任意数是否是平方数的问题，正好利用递归来完成这个题目，原来的代码如下： var isSquare = function(n){ function square(index = 0,n){ var res = index*index; if(res === n){ return true; }else if(res &gt; n){ return false; } index++; return square(index,n) //这里如果不用return来调用递归就得不到正常的返回值。 } return square(0,n); } 这里有一个小细节，在递归时如果想要递归结果返回某个值，那么在递归调用函数的时候必须使用return，很好理解，被调用的时候返回的只是一个数值，并没有在外层函数中返回。 内存溢出递归很容易导致内存溢出，上面的代码在n足够大的时候就会导致内存溢出，原因在于每次递归函数调用都会创建执行上下文，而js线程被分配的栈空间是有限的，每个执行上下文window分配为1M，在浏览器不支持尾调用优化的情况下，递归数量次数一旦过多就会内存溢出 在没有尾调用优化的情况下应该少用递归，尽量少用for循环。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6函数扩展（二）]]></title>
    <url>%2F2017%2F07%2F06%2Fes6%E6%80%BB%E7%BB%93%2F%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[箭头函数箭头函数大大的简化了函数的写法，： var a = x =&gt; x*x; 箭头函数省去了function声明，省略了参数的写法，省略了返回的写法，有下面几个规则： 没有或者有多个参数，需要使用（）将参数包裹起来，只有一个参数则不用 如果箭头函数直接返回一个基础类型的值，则不需要使用{}，如果直接返回一个对象，那么需要使用（）括起来 箭头函数的函数体按照传统函数的写法使用{}括起来是永远没有错的， 如果函数体不只有一行代码，则需要使用{}括起来 箭头函数的特性： 箭头函数在创建执行上下文的时候有两个特性，确认this指向时直接指向上层函数的this，创建变量对象的时候回跳过arguments对象的创建。因此，箭头函数会绑定this对象，并且，无法使用arguments对象。 不能使用new关键字，箭头函数没有构造函数 不能使用yield命令，箭头函数不能用作generator函数。 函数绑定就像箭头函数强行绑定了this一样，es7有了一条用来绑定函数的关键字提案天，而且babel也支持转化。es7使用::来作为绑定obj1::obj2.sayName()会将sayName函数绑定到obj1对象上。虽然没有看出来到底有啥用，不过确实要好写一些。 尾调用优化&nbsp;&nbsp;在函数的return语句里直接返回函数叫做尾调用，而被返回的函数在没有使用父函数的和参数变量有关的变量的情况下，呗返回函数会替换掉父函数的函数调用栈的情况叫做尾调用优化。这种情况下可以极大的减少内存消耗，因此要尽量高些递归变量的写法，做到尾调用优化。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 目前es6支持尾调用优化，这将去掉一些不必要的闭包内存消耗。]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6函数扩展（一）]]></title>
    <url>%2F2017%2F07%2F05%2Fes6%E6%80%BB%E7%BB%93%2F%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数默认值&nbsp;&nbsp;es5是不支持默认函数值的，在以前要实现默认函数值只能够通过 y = y||&apos;dadasd&apos; 这样的方法，而es6支持了函数默认值。&nbsp;&nbsp;函数默认值的触发条件为undefined，只有在参数为undefined的时候才会默认赋值，参数为null或者false等值时不会默认赋值 函数默认值和结构赋值结合使用&nbsp;&nbsp;函数默认值可以和解构赋值结合使用，需要弄清楚的规则只有一条： 1. 函数接受到参数的时候先判断参数是否是undefined，如果是，触发默认值，如果不是，则由传入参数进行解构赋值 2. 进行解构赋值的时候，如果解构得到的结果是undefined，则对被赋值对象赋予默认值 函数默认值的位置&nbsp;&nbsp;函数的默认值只有在末尾的时候可以省略不谢，这时默认会传入undefined，而默认值如果不在末尾则不能省略不写，如果实在不能复制，也要传入一个undefined。 length属性失效&nbsp;&nbsp;length会在读取到默认参数时失效。 在没有默认参数时，函数的length属性会得到函数参数的个数 在有默认参数时，函数的length属性会从设置默认参数的参数位置开始失效。 默认参数的作用域&nbsp;&nbsp;函数的默认参数也有作用域。这里的作用域单凭函数代码很难判断： let x = 1; function f(y = x) { var x = 2;// let x =2 结果一样 console.log(y); } f()//1 在思考了这个例子以后我得出了一个结论： 默认参数作用域和传统作用域一样，先是函数作用域，然后是外部作用域。 但是这个结论的理解对js原理要有一定的理解，首先，什么是作用域？ 作用域是一套规则，创建执行上下文的时候就会创造作用域，js是词法作用域。 它规定了查找变量的路径和方式，也就是先在自己内部找，找不到再去外部找 默认参数在进行变量查找的时候就会按照作用域规则进行查找然后要理解，默认参数的运行时机，它是什么时候运行，什么时候完成赋值？ 参数定义于赋值站在创建变量对象的第一步完成，前面提到过，先完成arguments 对象的创建与赋值，然后针对var和函数声明进行提前声明。 然而在默认参数进行赋值的时候函数内部的变量和函数其实还没有被初始化。 因此其实默认参数的作用域是不包括自己的， 狭义上可以这么理解 所以最后得到结论，默认参数的变量赋值是不参考内部作用域的。内部作用域找不到非参数变量，像y=x这种赋值，x只能去外部作用域找。 一个问题，let究竟有没有变量提升？在知乎上看到这个专栏，虽然对使用let没有影响，但对理解它有帮助，let也是有变量提升的，只是这个变量提升与我们传统的理解有些不同，我们熟悉的是声明提升，也就是把函数声明提升，还有一种提升是创建提升，在let变量没有被声明提升这是肯定的，但是js对它进行了创建提升，一个变量是先被创建，然后被声明，let声明只有创建提升，没有变量提升，所以在重复声明let的时候，可以提前报错错误，is already been decleared，js不允许重复创建，但是它允许重复声明。可能莫名其妙看到这里的人已经乱了。。。。。但是我不准备花时间把这个不重要的深度知识点详细说一遍，想看的可以自己去看知乎的这篇专栏吧https://zhuanlan.zhihu.com/p/28140450 rest参数写法 …&nbsp;&nbsp;es6支持使用rest参数的方式来获取多余的参数，rest会将参数扩展成一个数组，可以不再使用arguments对象，但是rest参数不能放在参数中间，只能坐在最后一个 扩展运算符 …&nbsp;&nbsp;rest参数和扩展运算符在形式上是一样的，但是作用完全相反，扩展运算符是用来将数组或者类似数组的具有iterable接口的对象转换成单个的元素。扩展运算符使用场景很多，可以扩展字符串成为数组改进apply，可以改进apply函数参数的写法，可以和解构结合使用获取数组内容。 name属性&nbsp;&nbsp;函数的name属性指向函数的名称。 对于函数声明的函数对象，name指向函数名，对于对象字面量声明的匿名函数，es5中name属性为空的字符串‘’，而es6中为对象名。 bind函数绑定使用的函数的名称前面都要加上bound。]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6数组扩展]]></title>
    <url>%2F2017%2F07%2F04%2Fes6%E6%80%BB%E7%BB%93%2Fes6%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;数组不管在那个语言里都是很重要的一种数据类型，数组的使用广泛让怎么合理高效率的使用它成为一个问题，我目前遇到的问题主要集中两个部分： 空间、时间复杂度：滥用数组，动不动就新建数组，针对存储列表类数据向来是直接使用数组来操作。也不怎么考虑事件复杂度，大多数时候会做多层遍历，结合起来很容易写出低质量的代码， 数组复制，在需要复制数组数据的时候面对复杂数据类型，有些复制做起来完全是无效的，或者就是增大空间复杂度。 &nbsp;&nbsp;我的编码经历来说，一段处理业务逻辑的代码很少有不用到数组或者说json这种这些数据结构的，对于数组、对象、json这些数据类型的操作要考虑清楚再动手敲代码 &nbsp;&nbsp;es6对数组的扩展一定程度上解决了一些问题 新的扩展&nbsp;&nbsp;新的扩展主要集中于数组的生成、复制，填充，查找，遍历上 生成： Array.from()：可以将所有可遍历的类似数组的对象转化为数组，也就是有有iterable遍历接口的对象，进一步可以理解为只要是有length属性就可以转化，但是不是数值的length会被转化为空的数组[]。这样在这些类似数组的对象就可以使用数组遍历方法进行遍历，例如arguments对象，它并不是一个数组，不可以使用foreach等方法。 Array.of():扩展了数组的构造函数 复制：原先的数组可以使用concat、slicee函数来进行赋复制 填充：es5原有一个splice函数可以进行删除和新增，es6扩充了一个copyWith函数来将数组的某一个连续元素赋值到另一个位置。还有fill（）函数可用来填充数组 查找：es6扩充了find（）和findIndex（）函数来查找数组元素，includes（）函数可以用来判断数组是否包含某个元素 遍历，es6中，实现了iterable接口的对象都可以使用新的遍历函数进行遍历：entries（）和value（），结合keys()作为三个遍历函数。 关于遍历还有一个要注意的问题就是，传统的遍历方法，every、some、map、forEach在遍历时都会一定程度上忽略空的数组元素，map会直接返回一个空元素，而es6扩展的数组方法在生成数组时就会将空元素解析为undefined，并且在使用for。。。of遍历时也会遍历undefined元素]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6字符串扩展]]></title>
    <url>%2F2017%2F07%2F03%2Fes6%E6%80%BB%E7%BB%93%2Fes6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;es6很大程度上是对es5的扩展，完全向下兼容，并且扩展出新特性。 新特性&nbsp;&nbsp;es6在字符串上增加了的新特性有一下面这几种特性。 对unicode字符的进一步支持 includes()、startsWith()、endsWith()函数用来增强indexOf()能力 repeat()、padStart()、padEnd()函数用来充填字符串 字符串模板和标签模板unicode&nbsp;&nbsp;unicode的部分没能深入进去了解，javasccript内部使用utf-16来存储，首先unicode是一种能囊括全世界的文字符号的一种编码方式，每一个字符都有一个码点，而utf-8以及gbk以及utf-16等都是针对unicode的进一步汉字转码。&nbsp;&nbsp;es5的汉字字符串很有可能并不只是占有一个32位的utf-16字符，很可能会超过32位，这个时候就会用两个utf-16码点来表示字符串，此时，length就会变成2，哪怕只是一个汉字，这是有问题的，es6扩充了一系列函数来解决这个问题。 字符串模板&nbsp;&nbsp;字符串的重点扩展在于字符串模板，字符串模板简化了使用js拼写html内容，在模板内使用${}就可以嵌入变量，在以前只能通过jquery的tmpl等类似的插件才能实现。&nbsp;&nbsp;而在字符串模板上进一步的标签模板则可以简化或者说扩充一种编写函数的新方式，标签模板作为参数传给函数，函数接受到的参数会有两部分，第一部分是字符串模板的静态部分被${}分隔开，以数组的方式传入，第二部分就是${}部分的内容，作为单个的参数传入。&nbsp;&nbsp;标签模板有两个强大的作用，一个是过滤HTML字符串，可以过滤掉一些不合法的内容，一个是用来做国际化，可以把需要国际化的部分使用${}变量表示，然后使用国际化转义来重新写入字符串]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值]]></title>
    <url>%2F2017%2F07%2F02%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;es6由于import、export模块化的能力，也推出了解构赋值这么一种能力，顾名思义，解析赋值，解析js代码然后进行赋值。这篇只是梳理并不设计代码例子。es6的解构赋值指的是在赋值表达式中解构右边部分的值然后将值赋给左边。 解构赋值的几种情况&nbsp;&nbsp;解构赋值在于根据赋值表达式左边的匹配模式，来解构右边的表达式并且完成赋值。根据右边的表达式的不同解构的结果不同。 对数组的解构 对对象的解构 对字符串的解构 对函数的解构 对boolean的解构 &nbsp;&nbsp;解构虽然是根据被解构对象不同会有不同的差别，但是原理都是一致的：按照一定的模式，从对象中提取值，并完成赋值，只是有一些特殊的情况需要注意。 解构赋值是可以有默认值的。在没有默认值的情况，如果没有解析到值那么，值就是undefined，所以只有在值被解析完成以后为undefined才会触发默认值，解析为null或者false等都不算。 模式匹配必须和右边的解构完全一致，不一致则会因此导致错误。 对一个已经声明的变量进行解构赋值是很容易导致错误的一件事，没有变量声明var、let、const，解析器无法确定这是一个解构赋值语句还是一个代码块，因此需要使用（）来包裹整体，（）包裹住就不会被认为是一个代码块 在对字符串解构的时候，字符串被改为一个类似数组的对象，会解构出每一个字符 对数字和布尔值进行解构的时候，原始类型的值会被转化成引用类型的封装对象。 最复杂的是结合函数参数进行解构赋值，由于函数参数可以有默认值，解构赋值对象也可以有默认值，将函数参数的默认值设置为有默认值的解构赋值是最复杂和麻烦的事，需要根据原理细致的查看，编写相应代码时也要格外小心。 （）在解构赋值中的使用也需要小心，只有赋值语句的非模式部分可以使用圆括号，其他任何地方使用圆括号都会报错]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let/const]]></title>
    <url>%2F2017%2F07%2F01%2Flet%20const%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;尝试在不查看文档的情况下写出es6知识点的相关内容，遇到没记清楚的再查阅才能加深记忆力，好记性不如烂笔头 let/const几个重要特性 没有变量提升 暂时性死区 不允许重复声明 全局声明的变量不再挂载到window上 &nbsp;&nbsp;理解没有变量提升，要先回顾变量提升的概念。js作为词法作用域的语言，js的作用域是在代码执行的时候确认的，代码执行的环境会有一个对应的执行上下文，每次进入一个执行环境都会创建一个执行上下文，执行上下文在创建阶段会做三件事。 确认作用域 创建变量对象 确认this指向 &nbsp;&nbsp;变量提升就发生在创建变量对象时，创建变量对象要做2件事。第一，查找var变量声明，不包括let和const声明，在变量对象里生成对应变量名称的属性，重名的声明会被覆盖。第二，查找函数声明，生成对应函数名的指针对象指向函数的堆内存空间存放位置，重名的函数不会生效。 &nbsp;&nbsp;在代码开始执行的时候，执行上下文就会进入执行阶段，变量对象就会变成活动对象，并且根据执行进度对活动对象里的提前声明的对象赋值。&nbsp;&nbsp;由此可以知道为什么let、const没有变量提升，因为，在进行变量提升的时候没有对let、const的变量声明进行提升。 &nbsp;&nbsp;暂时性死区的概念其实和没有变量提升是一个意思，在let、const变量还没有声明的时候，在对应的作用域内使用它会直接导致报错，对于let、const变量而言，{}就是它们在还没有被声明时的死区。所以我认为阮一峰的es6入门在这一块的讲述是重复且有误导性的，没有变量提升其实是暂时性死区的原理，而不应该把两者都作为特性来说明。 &nbsp;&nbsp;关于不允许重复声明这一条特性，在原理上确实不好理解，目前我只能理解成语法糖，语法规定了就是这样，不过从这条语法糖的意义上倒是可以看出js视图纠正之前变量声明过于灵活的问题，我一直无法理解可以重复声明同名变量还不回报错到底有什么意义，除了不会报错以外，在使用上完全可能破坏代码，降低代码质量。&nbsp;&nbsp;let、const声明的变量不再挂载到Window上野同样是为了规范变量声明，js不再默认允许随意的创建全局变量。 &nbsp;&nbsp;声明let、const变量导致的块级作用域不难理解，只要在{}内声明了let、const变量，{}就会成为一个es5里不支持的块级作用域。 &nbsp;&nbsp;难以理解的是es6规定了在{}里声明的函数也会导致会计作用域，不需要其他声明，函数就会被绑定到这个作用域里。其实这让人很难理解，es6并没有摒弃es5的内容，执行上下文依然会创建，那么块级作用域又是如何在原理上实现的呢，如何检测、创建、绑定一个块级作用域？ 问题：如何检测、创建、绑定一个块级作用域？]]></content>
      <categories>
        <category>es6知识梳理</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react入门级教程（一）]]></title>
    <url>%2F2017%2F06%2F15%2Freact%E5%85%A5%E9%97%A8%E7%BA%A7%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E5%B9%B2%E8%B4%A7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[react入门级教程（一）1、前言react的官方文档的逻辑和语言方式真的是难看，就像看外语翻译来的文学小说，再真挚再伟大的感情波动读起来都像是在看戏，还不如自己做一个总结。react和vue我都系统学习过，两者对比起来，react的自由度会更高一些，react的开发更接近原生js代码，除了它基本的不多的几个语法，其他的都是es6来完成，而vue配置项要多很多，语法也相对多很多，这也是为什么我近期准备啃react的原因，对于es6的高度依赖对开发人员的成长更有好处，能学到更多东西。写这个教程，最大的目的是巩固自己的基础，其次是希望能帮助到一些和我一样的初学者。 2、create-react-app一个工程化的兼容性强的前端开发环境自己配置对于初学者来说是非常艰难的，需要配置es6环境，配置基于node的服务器，配置打包工具，配置模块化，配置css3、html5支持，等等。对初学者，这会是一个很难受的过程，去年年初，我自己在不知道vue-cli的情况下研读了github上别人的项目，对着一堆代码研究了好几天才搞明白，究竟在干嘛，还是在知道了vue-cli以后才知道是自动生成的代码，而不是自己写的，很难受。因此，学习这些框架在不进行进一步webpack配置的情况下，完全可以直接用自动化工具来初始化一个项目，而不需要自己来搭建，vue项目使用vue-cli，react项目使用create-react-app。使用npm安装create-react-app： npm install create-react-app -g //建议全局安装 create-react-app构建了一个完善的开发环境，包括热替换等。 //创建一个项目 create-react-app 项目名称 //初始化项目 npm install //运行项目 npm start 执行上面代码就可以初始化并且运行项目，会得到一个demo页面，这里就不截图了。src下的index是react项目的入口文件，其他的是组件。 3、react基础语法其实之前也做了好几次整理，但是还是容易变得模糊，不精准，只能说好记性不如烂笔头，这里主要对对react部分来说明语法，react-dom暂且放一放这里会提到以下几个类和方法：react、Component、jsx、render、props。下面是一个简单的react组件 import React,{Component} from &apos;react&apos;; //从react导入React相关环境以及组件环境 var root = document.querySelector(&quot;app&quot;);//拿到页面的根元素。 render(&lt;div&gt;haha&lt;/div&gt;,root);// 组件的render渲染方法，把虚拟的div组件绑定到root上 其实上面三行代码已经包含了react的精髓内容，react更多的是一种基于数据的新的开发思维模式。第一行代码，在单页应用spa里依赖react的环境，这个环境有很多内容，这里只依赖了Component，一个组件相关的类第二行代码，获取要挂载的根节点第三行代码，创建一个虚拟DOM，也就是haha,然后把这个虚拟DOM挂载到根节点上,react的精髓就在于创建虚拟DOM，挂载以后生成真实的DOM，用数据驱动虚拟DOM进行变化，虚拟DOM的变化反映到挂载的真实DOM上。react的目的就是更小耦合度的划分功能模块成组件，一个功能或者几个功能划分成一个组件，组件的通信来完成复杂功能。 4、创建组件的两种方式通过reactDOm来创建的方式并不被官方推介。 a、创建无状态组件由react开创的组件化的模式在于转换操作DOM为操作数据，以前我们习惯于使用jquery操作DOM来做页面逻辑操作，react的思路是利用操作数据来改变虚拟DOM然后更新真实DOM，比如一个表单验证，使用jquery是操作DOM来获取表单元素的值，然后对值进行校验，然后再一次操作提示部分的DOM进行复制，使用react的思路是创建一个虚拟的DOM表单，直接进行表单数据验证，将验证结果反应到反应到数据上，然后根据数据重绘表单界面。jquery是一个工具，运用jquery是一个横向的单点的过程，只关心自己择器操作的DOM，而不关心使用场景。而使用react是一个纵向的连续的过程一个react组件本身就是可以持续改变，多个组件通过父子关系，兄弟关系，在横向和纵向上可以组合拉伸。一个用户操作在jquery里只是一个普通的操作DOM改变界面，在react里却是能看到一条线，一条由用户操作引起的数据流向的线。更重要的一点是，react组件是可以积累的，是可复用的。会到第一种创建组件的方式：无状态组件。一个组件的状态就是它的数据，数据变化，组件就会重新绘制，无状态组件就是没有自己状态的组件，这种组件不在少数，只展示信息的组件，它不需要有属于自己的数据，他只负责展示，用户操作的组件，一个button只代表一个用户点击操作，它于它的父组件不可分割，也不需要有自己的数据。我们通过函数式的写法来创建组件： ShowMessage.jsx import React from &apos;react&apos;; const ShowMessage = () =&gt; { return( &lt;div&gt;nihao&lt;/div&gt; ) } export default ShowMessage; () =&gt; {}箭头函数式es6的写法，用来固定this指向,简写function，它等于 function(){},import和export是es6模块化的东西。上面这个组件就是一个没有自己状态的组件，但是它没有意义，一个静态div的组件是没有意义的，使它有意义的是他的父组件，它没有自己的数据，但是可以有父组件的数据，父组件传递数据给子组件的方式是通过属性，然后在子组件里通过props来获取数据. parent.jsx import showMessage from &apos;showMessage.jsx&apos;; import React,{Component} from &quot;react&quot;; class Parent extends Component{ state = { message：&quot;hello&quot; } render(){ return( &lt;ShowMessage message={message}/&gt; ) } } export default Parent; 这里使用属性的方式把message赋值给ShowMessage子组件。 {message}是jsx的语法，jsx是一个js的扩充语言，它的写法于html一样，在读取编译的时候，会使用creatElement函数来根据标签创建js对象，{message}是在jsx里插入变量的写法。 ShowMessage.jsx import React from &quot;react&quot;; const ShowMessage = (props) =&gt; { return( &lt;div&gt;{props.message}&lt;/div&gt; ) } export default ShowMessage; 在子组件里通过props来接受父组件的数据,包括给子组件绑定事件，如下 &lt;ShowMessage message={message} method={this.method}/&gt; ShowMessage.jsx import React from &quot;react&quot;; const ShowMessage = (props) =&gt; { return( &lt;div onClick={props.method}&gt;{props.message}&lt;/div&gt; ) } export default ShowMessage; b、创建有状态的组件上面的Parent组件其实就是有状态的组件 parent.jsx import showMessage from &apos;showMessage.jsx&apos;; import React,{Component} from &quot;react&quot;; class Parent extends Component{ state = { message：&quot;hello&quot; } render(){ return( &lt;ShowMessage message={message}/&gt; ) } } export default Parent; class是es6创建类的关键字，于创建一个函数其实差别不大；extends是es6进行继承的写法，es5必须通过原型链将圆形赋值给被继承对象的实例才能完成继承，es6简化了这个部分，现在只需要使用extends就可以完成继承，当然也可以使用supper函数。Component是react里的组件相关的类，render是Component提供的渲染函数，用来渲染组件。一个组件有了自己的状态就可以做很多事情了，要牢记的一点是：组件的数据发生改变就会调用render函数重新绘制组件，组件的数据包括自己状态state和来自父组件的数据props。比如做一个提交功能，包含提交按钮，一个提示信息，提交时还要禁止点击 Button.jsx import React from &quot;react&quot;; const Button = (props) =&gt; { const {children, loading, submit} = props; return ( &lt;button onClick={submit} disabled={loading?&apos;disabled&apos;:null&gt; {loading &amp;&amp; &lt;i className=&quot;loading&quot;&gt;&lt;/i&gt;} {children} } &lt;/button&gt; ) } export default Button; 这个提交按钮Button组件没有自己的状态，只有父组件传递的提交函数，子元素，是否loadind。className是为了和class关键字区分开，className表示css类名，const { … } = props是es6解析结构的写法 Dialog.jsx import React from &quot;react&quot;; const Dialog = () =&gt; { const {message, close} = props; return( &lt;div className=&quot;dialog-backdrop&quot;&gt; &lt;div className=&quot;dialog-container&quot;&gt; &lt;div className=&quot;dialog-header&quot;&gt;提示&lt;/div&gt; &lt;div className=&quot;dialog-body&quot;&gt;{ message }&lt;/div&gt; &lt;div className=&quot;dialog-footer&quot;&gt; &lt;button className=&quot;btn&quot; onClick={ close }&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) } 这个弹出框组件接受父组件的消息和关闭函数 App.jsx import React, { Component} from &quot;react&quot;; import Button from &quot;Button.jsx&quot;; class App extends Component{ state = { message: &quot;&quot;, loading: false, dialog: false } submit = () =&gt; { this.setState({ loading: true }) setTimeout( () =&gt; { const res = Math.random(1); if(res &lt; 0.5){ this.setState({ message: &quot;提交成功&quot;, dialog: true }) }else{ this.setState({ message: &quot;提交成功&quot;, dialog: true }) } this.setState({ loading: false }) }) } close = () =&gt; { this.setState({ dialog: false, }) } render(){ const {loading, message, dialog} = this.state; return ( &lt;div className=&quot;app-wrap&quot;&gt; &lt;Button submit={this.submit} loading={loading}&gt;提交&lt;/Button&gt; {dialog &amp;&amp; &lt;Dialog message={message} close={this.close}/&gt;} &lt;/div&gt; ) } } 这个由三个组件组成的提交功能的组合组件中数据的流向从上到下，从用户点击开始，点击改变了父组件状态，组件状态改变了子组件的props。 5、react组件的声明周期钩子任何流程和事物都有一个生命周期，react的声明周期有三种：挂载前后、更新前后、销毁前挂载前后：componentWillMount（）、componentDidMount（） 更新前： componentWillReceiveProps接收到一个新的props时，在重新render之前调用 shouldComponentUpdate 接收到一个新的state或者props时，在重新render之前调用 componentWillUpdate 接收到一个新的state或者props时，在重新render之前调用 更新后： componentDidUpdate 组件完成更新之后调用 销毁前： componentWillUnmount]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM新API fetch]]></title>
    <url>%2F2017%2F06%2F07%2Ffetch%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;之前刚刚总结了axios的用法，然后就突然发现了fetch这么一个东西，这个既然还是新的BOM标准之一，不得不感叹，前端技术推进真的是快，连ajax都要被取代了吗&emsp;&emsp;fetch是定义在BOM标准中window上得一个功能集，它的目的在于取代现有的XMLHttpRequest。w3c认为XMLHttpRequest比较杂乱、异步请求是基于事件模型的，相比Promise和asyns/await来说不够友好、不符合长期以爱w3c关注分离的原则。因此，w3c发布了fecth标准，用来取代旧有的ajax。&emsp;&emsp;其实浏览器请求天生就是异步操作，长久以来，一直都在致力于简化、规范化这个过程。jQuery的ajax方法，es6的Promise，es7的asyns/await、以及大量的前端框架，像angular-resource，axios等等。&emsp;&emsp;但是w3c这个行为像是在搞事呀，ECMA组织发布了es6、es7中都包含有异步操作的内容，也都很强大，它在promise的基础上封装一个fetch出来有些瞎操心。不过从另一个角度来说，ajax以前也是w3c负责发布的标准，做这个改进也合情合理，但是fech像替换掉ajax甚至jquery的ajax，我并不看好。 fetch APIfetch的API主要体现在它的接口实现上，分为以下几个接口，GolbalFetch、Body、Request、Response、Headers，其他的接口暂时不准备学习。 GolbalFetch这个接口提供了fetch（）方法，window实现了这个接口，因此可以直接使用window.fetch()来请求资源，fetch()接受一个Request接口对象，或者一个URL。 var URL = &apos;https://api.flickr.com/services/rest/?method=flickr.photos.search&amp;api_key=your_api_key&amp;format=json&amp;nojsoncallback=1&amp;tags=penguins&apos;; function fetchDemo() { fetch(URL).then(function(response) { return response.json(); }).then(function(json) { insertPhotos(json); }); } fetchDemo(); Request]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS typeof总结---6种数据类型]]></title>
    <url>%2F2017%2F06%2F05%2Fjavascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言&emsp;为什么要写这个东西？因为typeof总是返回一些乱七八糟的词啊，各种基本数据类型莫名其妙的相等！不总结一下不行了？那么，typeof究竟会返回哪些值呢？js有5种基本类型Undefined、Null、Boolean、String、Number，一种复杂类型Object，函数本质是一个对象，但是函数由于它在js中的特殊性，也需要从其他对象中被区分出来function，因此，typeof会返回7种值。 js五种基本数据类型js有5种基本数据类型undefined、null、boolean、string、number，下面一一说明: 1、UndefinedUndefined作为基本类型的意义，意如其名，未定义,Undefined作为变量的基本类型，是针对变量来说的，因此默认变量已经存在。 在ECMAScript里，Undefiend只有一个值，即特殊的undefiend在js里只有一种变量是Undefiend类型，具有undefiend值，那就是未初始化变量var a; a == undefined// true typeof a//&apos;undefined&apos; 我们考虑的是：什么样的变量 typeof会返回‘undefined’按照上面的定义，未初始化的变量会返回undefined；还有一种特殊情况也会返回undefined，那就是未声明变量 typeof b//&apos;undefined&apos; b == &apos;undefined&apos; // 会报错 这里我们要分清楚三个概念: 变量是否已定义 变量类型 变量的值 再结合typeof就不难理解为什么只有未初始化的变量值为undefined，而未定义和未初始化的变量数据类型都为Undefined。未定义的变量本来就不存在，把他归为Undefined变量只是为了更好的区分。 因此在定义变量的时候显示的初始化变量是有意义的，可以帮助判断变量是否存在2、Null&emsp;Null和Undefined类似，表示为空，但是在js里，为空是什么意思呢？ 在ECMAScript里，Null是第二个只有一个值的数据类型，那就是null，null表示一个空的对象指针var a = null; typeof a //&apos;object&apos; typeof null // &apos;object&apos; 也就是说null表示一个没有指向的对象指针，这样我们就可以理解了。 这样看来，null和undefined其实并没有太大的区别，赋值一个空的对象指针null和赋值一个undefined，看起来没有区别，而且实际上 null == undefined// true undefined == null//true 更过分的是： var a = null; a == undefined // true var b; b == undefined // true //这个最过分 a == b //true，竟然是true，但是也引发出了一个大的猜想：在变量还没有被赋予实际值的时候，所有变量的值都是一样的，不一样的只有类型 这两个值还真的是相等的，每次看到这里肯定就已经绕进去了。。。。这两个基本属性在搞什么呀，乱七八糟，莫名其妙。非要总结一下规则的话,可以说，这两种基本类型是一样的，一样的值；Undefined和Null就像两条线，两条一模一样的线，但是他们依然是不同的线。他们的不同就在于类型的不同，在于意义的不同，undefiend是未初始化的值，null是空的对象指针。ECMAScript引入这个undefined的最主要目的就是为了与空对象指针null做区分 3、Boolean&emsp;Boolean是ECMAScript中的布尔类型，有两个值：true和false，并且，这两个值区分大小写Boolean()可以转换其他类型为Boolean类型，在进行if（）判断时，就是默认调用了Boolean（）方法。 数据类型 true false Boolean true false Strung 非空字符串 空字符串 Number 任何非0数字（包括无穷大） 0和NaN Object 任何Object null、 Undefined 不试用 undefined 4、NumberECMAScript是基于IEEE754数值格式的，由于IEEE754的通病，浮点数会有四舍五入的毛病，0.1+0.2并不等于0.3，而是等于0.30000000000000004，所以不要确定浮点数的值。Number可以通过8进制、十进制、十六进制来表示，十进制和往常一样 八进制，首位数字为0,078表示八进制的78,十进制的64， 十六进制，首尾字符为0x，0x9表示十六进制的9，A~E表示11~15。 数值范围上来说，Number有一个上下线，一旦超过了上线就会变成Infinity，超过下线就会变成-Infinity。而一个本来应该返回数值的数结果却没有返回数值，这个时候就会返回NaN，比如0/0就会返回NaN。NaN与任何值都不相等，包括它自身，它只是一个代表意义，表示不是数字。可以用isNaN来判断是否不是数字]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios随笔]]></title>
    <url>%2F2017%2F06%2F02%2Faxios%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介&emsp;axios是一个基于es6 Promise的HTTP库，可以在浏览器和nodejs中使用。在vue2之后，官方不在推介vue-resource，然是推介使用axios，作为一个被很多人引用为项目依赖的模块，各方面的性能还是信得过的。在浏览器中发起XMLRequest，在node中发起http请求，在形式上支持Promise异步链式编程，也支持自动转化json，同样还可以做请求拦截和分发。是功能很强大的一个插件 安装&emsp;直接引入官方axios.js或者使用npm安装npm i axios 示例//发起一个user请求，参数为给定的ID axios.get(&apos;/user?ID=1234&apos;) .then(function(res){ conole.log(res) }).catch(function(error){ console.log(error) }) //上面的请求也可选择下面的方式来写 axios.get(&apos;/user&apos;,{ params:{ ID:12345 } }) .then(function(response){ console.log(response); }) .catch(function(error){ console.log(error) }); axios语法1.基础用法–发起请求axios(config).then().catch(); &emsp;config的配置如下 config = { method: &apos;get/post/put/delete...&apos;, url: &apos;/api/dsdsd/dsd&apos;, data: { }, responseType: &apos;strean/json/string/...&apos; } //发起一个post请求 axios({ method:&apos;post&apos;,//方法 url:&apos;/user/12345&apos;,//地址 data:{//参数 firstName:&apos;Fred&apos;, lastName:&apos;Flintstone&apos; } }); 2.请求方法的重命名&emsp;根据axios(config)，来重命名一批方法。 //请求配置外置化 axios.request(config) axios.get(url[,config]) axios.delete(url[,config]) axios.head(url[,config]) axios.options(url[,config]) axios.post(url[,data[,config]]) axios.put(url[,data[,config]]) axios.patch(url[,data[,config]]) config中的url、data、method会被重命名方法中的参数替换掉 3.创建axios实例axios.create(config) 创建实例的意义在于预定义一些参数值，那么采用这个实例来发起请求，这些参数就会默认载入。 //创建一个axios实例 var instance = axios.create({ baseURL:&apos;http://some-domain.com/api/&apos;, timeout:1000, headers:{&apos;X-Custom-Header&apos;:&apos;foobar&apos;} }); //使用实例来发起请求 instance.get(&apos;/api/user/123&apos;); 同axios本身一样，实例也有方法重命名 instance.request(config) instance.get(url[,config]) instance.delete(url[,config]) instance.head(url[,config]) instance.options(url[,config]) instance.post(url[,data[,config]]) instance.put(url[,data[,config]]) instance.patch(url[,data[,config]]) 4.请求参数配置全局信息 { //url是服务器链接，用来请求 url:’/user’, //method是发起请求时的请求方法 method:get, //baseURL如果url不是绝对地址，那么将会加在其前面。 //当axios使用相对地址时这个设置非常方便 //在其实例中的方法 baseURL:’http://some-domain.com/api/‘, //transformRequest允许请求的数据在传到服务器之前进行转化。 //这个只适用于PUT,GET,PATCH方法。 //数组中的最后一个函数必须返回一个字符串或者一个ArrayBuffer,或者Stream,Buffer实例,ArrayBuffer,FormData transformRequest:[function(data){ //依自己的需求对请求数据进行处理 return data; }], //transformResponse允许返回的数据传入then/catch之前进行处理 transformResponse:[function(data){ //依需要对数据进行处理 return data; }], //headers是自定义的要被发送的头信息 headers:{‘X-Requested-with’:’XMLHttpRequest’}, //params是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象 params:{ ID:12345 }, //paramsSerializer是一个可选的函数，是用来序列化参数 //例如：（https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/) paramsSerializer: function(params){ return Qs.stringify(params,{arrayFormat:’brackets’}) }, //data是请求提需要设置的数据 //只适用于应用的’PUT’,’POST’,’PATCH’，请求方法 //当没有设置transformRequest时，必须是以下其中之一的类型（不可重复？）： //-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams //-仅浏览器：FormData,File,Blob //-仅Node：Stream data:{ firstName:’fred’ }, //timeout定义请求的时间，单位是毫秒。 //如果请求的时间超过这个设定时间，请求将会停止。 timeout:1000, //withCredentials表明是否跨网站访问协议， //应该使用证书 withCredentials:false //默认值 //adapter适配器，允许自定义处理请求，这会使测试更简单。 //返回一个promise，并且提供验证返回（查看response docs） adapter:function(config){ /…/ }, //auth表明HTTP基础的认证应该被使用，并且提供证书。 //这个会设置一个authorization 头（header），并且覆盖你在header设置的Authorization头信息。 auth:{ username:’janedoe’, password:’s00pers3cret’ }, //responsetype表明服务器返回的数据类型，这些类型的设置应该是 //‘arraybuffer’,’blob’,’document’,’json’,’text’,stream’ responsetype:’json’, //xsrfHeaderName 是http头（header）的名字，并且该头携带xsrf的值 xrsfHeadername:’X-XSRF-TOKEN’，//默认值 //onUploadProgress允许处理上传过程的事件 onUploadProgress: function(progressEvent){ //本地过程事件发生时想做的事 }, //onDownloadProgress允许处理下载过程的事件 onDownloadProgress: function(progressEvent){ //下载过程中想做的事 }, //maxContentLength 定义http返回内容的最大容量 maxContentLength: 2000, //validateStatus 定义promise的resolve和reject。 //http返回状态码，如果validateStatus返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。 validateStatus: function(status){ return status &gt;= 200 &amp;&amp; stauts &lt; 300;//默认 }, //httpAgent 和 httpsAgent当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。 //这个允许设置一些选选个，像是keepAlive–这个在默认中是没有开启的。 httpAgent: new http.Agent({keepAlive:treu}), httpsAgent: new https.Agent({keepAlive:true}), //proxy定义服务器的主机名字和端口号。 //auth表明HTTP基本认证应该跟proxy相连接，并且提供证书。 //这个将设置一个’Proxy-Authorization’头(header)，覆盖原先自定义的。 proxy:{ host:127.0.0.1, port:9000, auth:{ username:’cdd’, password:’123456’ } }, //cancelTaken 定义一个取消，能够用来取消请求 //（查看 下面的Cancellation 的详细部分） cancelToken: new CancelToken(function(cancel){ }) } 5.返回对象response包含对象response包含以下5个对象： data：{}：服务器返回的数据 status: 200 服务器返回的http状态码 statusText： ‘ok’ 服务器返回的状态信息 header:{} : 服务器返回头信息 config：{} axiox的请求配置信息 6.默认配置可以给axios或者axios的实例设置默认配置，axios中有三种配置信息： 默认配置，在模块的lib/defaults.js中的默认配置 其次是自定义的默认属性 最后是请求中的config配置 在定义实例的时候会在默认配置文件中创建一份临时数据，实例被销毁的时候，也销毁临时配置数据。 自定义默认数据的方式如下： instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN; 7.配置拦截器axios支持配置两种拦截器：拦截请求、拦截响应拦截请求： axios.interceptors.request.use(function(config){ //在请求之前做的一些事 },function(error){ //在请求错误之前做的一些事 return Promise.reject(error) }) 拦截响应： //添加一个返回拦截器 axios.interceptors.response.use(function(response){ //对返回的数据进行一些处理 return response; },function(error){ //对返回的错误进行一些处理 return Promise.reject(error); }); 取消拦截器需要使用eject函数 axios.interceptors.request.eject(&apos;拦截器名称&apos;)]]></content>
      <categories>
        <category>-- HTTP -- axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%97%A0%E6%A0%87%E9%A2%98Markdown%2F</url>
    <content type="text"><![CDATA[前言最近领导和我聊了很多关于个人发展，关于职业规划方面的东西，对我确实有一些触动，也实实在在的点醒了我. 个人问题长久以来，我深航都存在基础不稳的问题，大学阶段的浑浑噩噩，工作以后填填补补。靠着java找到的工作，但是自己却基本还是停留在对简单的框架使用，java基础没有好好总结过，spring也没有完全的好好看一遍，数据库sql更是不行，在后台开发这一块水得一塔糊涂. 这或许就是我谋求前端的原因之一吧，在前端技术的学习上我确实下了功夫，但是缺点也很明显，重心太多偏向js。 或许也是因为js是我技术的启蒙吧，大学阶段那么多的实习，从第一次读写文件MFC展示实习失败开始就一直没正真入门，但是js接纳了我，我第一次聚精会神写一份代码，站在图书馆一呆一天也是因为js。工作以后第一次的任务也是一份js编程的工作，DAP4，借助esayui我使用js完成了一个项目，当时的代码我都保留了起来，虽然现在看起来已经难以入目了，但是这引领了我进入了编程的世界。 后端java的缺点在于基础不扎实，代码都写过了，但是却不明白代码的运行规则。 前端的问题有两部分，基础上，对于js的编程自己还算满意，但是对于css和html标签的掌握不够。框架上，我只熟悉常用的框架，vue，react，webpack，scss，node，express，我只具备基础架构能力，自己也不能判断我是否具有框架的全局把控力。缺乏经验，大量缺乏经验，其实我也算是参与了三个成熟软件产品的研发，但是没有做到业务积累，没有培养自己的建模能力。很失败的一件事情，大学出来以后全部重心都放置在填补以前的空缺上了，没有对参与的项目进行非技术总结，没有细分业务需求的形成。 想法面对基础的缺失，依然只能通过技术积累，通过看学习来积累，面对眼界，思维方式的缺失，却要自己多想多钻研。 多看文档博客，一点点补充缺失，特别是新特性，java8，css3，es6. 全方面理解web应用开发架构，明白每个模块，每个阶段用到了哪些技术，选取其中最流行最优秀的一个进行研究学习。 在真正理解了系统架构的基础上理解业务需求，加强建模能力。 路漫漫其修远兮，吾将上下而求索。]]></content>
      <categories>
        <category>个人总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markDown写法]]></title>
    <url>%2F2017%2F05%2F26%2FmarkDown%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markDown写法1、定义标题文本写法直接写和按一下tab’写是有区别的、#的个数指定字体大小 按tab,然后直接写就是正文文本 2、有序列表和无序列表有序列表1. DASDASD 2. DASDASD 3. DASDASFD 无序列表 1 2 3 3、使用”&gt;”来进行引用 你好，引用的字体会是灰白色 4、图片链接博客中添加图片我们可以使用图床获取图片的URL， 可以去这个网址http://jiantuku.com/#/ 图片的写法是![]() ![nihao](http://dadasd/adasd/sdasd,jpg) 5、粗体斜体使用 就是粗体，使用一个 就是一斜体你好 你好 6、生成表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 使用这样的语法 “| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |” 7、代码块使用”`“来包裹var a = &quot;name&quot;; var b = &quot;cv&quot;;]]></content>
      <categories>
        <category>markDown</category>
      </categories>
      <tags>
        <tag>markDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传项目到github“]]></title>
    <url>%2F2017%2F05%2F26%2F%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[要上传项目到github需要以下几个步骤1、有或者新建一个github账户 2、创建一个和本地对应的仓库 3、本地安装git一路默认即可4、生成ssh key cd ~/.ssh 进入目录–》ls查看是否已有ssh key–》没有则新建 ssh-keygen -t rsa -C “754416804@qq.com”—&gt;不使用密码创建–》id_rsa.pub里面就是ssh key 5、到github网站关联自己的ssh key 到setting里进入ssh KEys–》增加ssh key–》填入自己的ssh key 保存 6、执行git命令，初始化空间，绑定远程仓库、添加提交代码、推送代码到远程仓库 git init –》git add . –》 git commit -m “” –》git remote add orign “你的git项目地址”–》git push -u orgin master 7、ok可以看到已经添加成功]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
</search>